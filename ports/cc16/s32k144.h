//
// AUTOMATICALLY GENERATED BY svd2cpp.py - DO NOT EDIT
//
// vendor      : NXP
// name        : S32K144
// version     : 1.6
// description : S32K144 NXP Microcontroller
//

#pragma once

typedef enum {
    Reset_IRQn                     = -15,
    NonMaskableInt_IRQn            = -14,
    HardFault_IRQn                 = -13,
    MemoryManagement_IRQn          = -12,
    BusFault_IRQn                  = -11,
    UsageFault_IRQn                = -10,
    SVCall_IRQn                    =  -5,
    DebugMonitor_IRQn              =  -4,
    PendSV_IRQn                    =  -2,
    SysTick_IRQn                   =  -1,
    DMA0_IRQn                      = 0,
    DMA1_IRQn                      = 1,
    DMA2_IRQn                      = 2,
    DMA3_IRQn                      = 3,
    DMA4_IRQn                      = 4,
    DMA5_IRQn                      = 5,
    DMA6_IRQn                      = 6,
    DMA7_IRQn                      = 7,
    DMA8_IRQn                      = 8,
    DMA9_IRQn                      = 9,
    DMA10_IRQn                     = 10,
    DMA11_IRQn                     = 11,
    DMA12_IRQn                     = 12,
    DMA13_IRQn                     = 13,
    DMA14_IRQn                     = 14,
    DMA15_IRQn                     = 15,
    DMA_Error_IRQn                 = 16,
    MCM_IRQn                       = 17,
    FTFC_IRQn                      = 18,
    Read_Collision_IRQn            = 19,
    LVD_LVW_IRQn                   = 20,
    FTFC_Fault_IRQn                = 21,
    WDOG_EWM_IRQn                  = 22,
    RCM_IRQn                       = 23,
    LPI2C0_Master_IRQn             = 24,
    LPI2C0_Slave_IRQn              = 25,
    LPSPI0_IRQn                    = 26,
    LPSPI1_IRQn                    = 27,
    LPSPI2_IRQn                    = 28,
    LPUART0_RxTx_IRQn              = 31,
    LPUART1_RxTx_IRQn              = 33,
    LPUART2_RxTx_IRQn              = 35,
    ADC0_IRQn                      = 39,
    ADC1_IRQn                      = 40,
    CMP0_IRQn                      = 41,
    ERM_single_fault_IRQn          = 44,
    ERM_double_fault_IRQn          = 45,
    RTC_IRQn                       = 46,
    RTC_Seconds_IRQn               = 47,
    LPIT0_Ch0_IRQn                 = 48,
    LPIT0_Ch1_IRQn                 = 49,
    LPIT0_Ch2_IRQn                 = 50,
    LPIT0_Ch3_IRQn                 = 51,
    PDB0_IRQn                      = 52,
    SCG_IRQn                       = 57,
    LPTMR0_IRQn                    = 58,
    PORTA_IRQn                     = 59,
    PORTB_IRQn                     = 60,
    PORTC_IRQn                     = 61,
    PORTD_IRQn                     = 62,
    PORTE_IRQn                     = 63,
    SWI_IRQn                       = 64,
    PDB1_IRQn                      = 68,
    FLEXIO_IRQn                    = 69,
    CAN0_ORed_IRQn                 = 78,
    CAN0_Error_IRQn                = 79,
    CAN0_Wake_Up_IRQn              = 80,
    CAN0_ORed_0_15_MB_IRQn         = 81,
    CAN0_ORed_16_31_MB_IRQn        = 82,
    CAN1_ORed_IRQn                 = 85,
    CAN1_Error_IRQn                = 86,
    CAN1_ORed_0_15_MB_IRQn         = 88,
    CAN2_ORed_IRQn                 = 92,
    CAN2_Error_IRQn                = 93,
    CAN2_ORed_0_15_MB_IRQn         = 95,
    FTM0_Ch0_Ch1_IRQn              = 99,
    FTM0_Ch2_Ch3_IRQn              = 100,
    FTM0_Ch4_Ch5_IRQn              = 101,
    FTM0_Ch6_Ch7_IRQn              = 102,
    FTM0_Fault_IRQn                = 103,
    FTM0_Ovf_Reload_IRQn           = 104,
    FTM1_Ch0_Ch1_IRQn              = 105,
    FTM1_Ch2_Ch3_IRQn              = 106,
    FTM1_Ch4_Ch5_IRQn              = 107,
    FTM1_Ch6_Ch7_IRQn              = 108,
    FTM1_Fault_IRQn                = 109,
    FTM1_Ovf_Reload_IRQn           = 110,
    FTM2_Ch0_Ch1_IRQn              = 111,
    FTM2_Ch2_Ch3_IRQn              = 112,
    FTM2_Ch4_Ch5_IRQn              = 113,
    FTM2_Ch6_Ch7_IRQn              = 114,
    FTM2_Fault_IRQn                = 115,
    FTM2_Ovf_Reload_IRQn           = 116,
    FTM3_Ch0_Ch1_IRQn              = 117,
    FTM3_Ch2_Ch3_IRQn              = 118,
    FTM3_Ch4_Ch5_IRQn              = 119,
    FTM3_Ch6_Ch7_IRQn              = 120,
    FTM3_Fault_IRQn                = 121,
    FTM3_Ovf_Reload_IRQn           = 122,
} IRQn_Type;

#define __CM4_REV               0x0001U
#define __NVIC_PRIO_BITS        4
#define __Vendor_SysTickConfig  0
#define __MPU_PRESENT           0
#define __FPU_PRESENT           1

#include <core_cm4.h>
                                                                        // --------------------
                                                                        // CSE_PRAM
typedef struct                                                          // --------------------
{
    uint32_t             _EmbeddedRAM0;                                 // CSE PRAM 0 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM0_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM0_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM0_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM0_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM0_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM0_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM0_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM0_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM0_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM0_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM0_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM0_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM0LL;                               // CSE PRAM0LL register.
    uint8_t              _EmbeddedRAM0LU;                               // CSE PRAM0LU register.
    uint8_t              _EmbeddedRAM0HL;                               // CSE PRAM0HL register.
    uint8_t              _EmbeddedRAM0HU;                               // CSE PRAM0HU register.
    uint32_t             _EmbeddedRAM1;                                 // CSE PRAM 1 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM1_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM1_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM1_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM1_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM1_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM1_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM1_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM1_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM1_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM1_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM1_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM1_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM1LL;                               // CSE PRAM1LL register.
    uint8_t              _EmbeddedRAM1LU;                               // CSE PRAM1LU register.
    uint8_t              _EmbeddedRAM1HL;                               // CSE PRAM1HL register.
    uint8_t              _EmbeddedRAM1HU;                               // CSE PRAM1HU register.
    uint32_t             _EmbeddedRAM2;                                 // CSE PRAM 2 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM2_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM2_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM2_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM2_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM2_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM2_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM2_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM2_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM2_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM2_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM2_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM2_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM2LL;                               // CSE PRAM2LL register.
    uint8_t              _EmbeddedRAM2LU;                               // CSE PRAM2LU register.
    uint8_t              _EmbeddedRAM2HL;                               // CSE PRAM2HL register.
    uint8_t              _EmbeddedRAM2HU;                               // CSE PRAM2HU register.
    uint32_t             _EmbeddedRAM3;                                 // CSE PRAM 3 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM3_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM3_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM3_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM3_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM3_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM3_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM3_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM3_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM3_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM3_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM3_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM3_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM3LL;                               // CSE PRAM3LL register.
    uint8_t              _EmbeddedRAM3LU;                               // CSE PRAM3LU register.
    uint8_t              _EmbeddedRAM3HL;                               // CSE PRAM3HL register.
    uint8_t              _EmbeddedRAM3HU;                               // CSE PRAM3HU register.
    uint32_t             _EmbeddedRAM4;                                 // CSE PRAM 4 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM4_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM4_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM4_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM4_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM4_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM4_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM4_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM4_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM4_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM4_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM4_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM4_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM4LL;                               // CSE PRAM4LL register.
    uint8_t              _EmbeddedRAM4LU;                               // CSE PRAM4LU register.
    uint8_t              _EmbeddedRAM4HL;                               // CSE PRAM4HL register.
    uint8_t              _EmbeddedRAM4HU;                               // CSE PRAM4HU register.
    uint32_t             _EmbeddedRAM5;                                 // CSE PRAM 5 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM5_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM5_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM5_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM5_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM5_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM5_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM5_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM5_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM5_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM5_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM5_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM5_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM5LL;                               // CSE PRAM5LL register.
    uint8_t              _EmbeddedRAM5LU;                               // CSE PRAM5LU register.
    uint8_t              _EmbeddedRAM5HL;                               // CSE PRAM5HL register.
    uint8_t              _EmbeddedRAM5HU;                               // CSE PRAM5HU register.
    uint32_t             _EmbeddedRAM6;                                 // CSE PRAM 6 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM6_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM6_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM6_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM6_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM6_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM6_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM6_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM6_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM6_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM6_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM6_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM6_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM6LL;                               // CSE PRAM6LL register.
    uint8_t              _EmbeddedRAM6LU;                               // CSE PRAM6LU register.
    uint8_t              _EmbeddedRAM6HL;                               // CSE PRAM6HL register.
    uint8_t              _EmbeddedRAM6HU;                               // CSE PRAM6HU register.
    uint32_t             _EmbeddedRAM7;                                 // CSE PRAM 7 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM7_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM7_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM7_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM7_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM7_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM7_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM7_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM7_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM7_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM7_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM7_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM7_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM7LL;                               // CSE PRAM7LL register.
    uint8_t              _EmbeddedRAM7LU;                               // CSE PRAM7LU register.
    uint8_t              _EmbeddedRAM7HL;                               // CSE PRAM7HL register.
    uint8_t              _EmbeddedRAM7HU;                               // CSE PRAM7HU register.
    uint32_t             _EmbeddedRAM8;                                 // CSE PRAM 8 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM8_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM8_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM8_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM8_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM8_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM8_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM8_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM8_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM8_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM8_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM8_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM8_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM8LL;                               // CSE PRAM8LL register.
    uint8_t              _EmbeddedRAM8LU;                               // CSE PRAM8LU register.
    uint8_t              _EmbeddedRAM8HL;                               // CSE PRAM8HL register.
    uint8_t              _EmbeddedRAM8HU;                               // CSE PRAM8HU register.
    uint32_t             _EmbeddedRAM9;                                 // CSE PRAM 9 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM9_BYTE_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM9_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM9_BYTE_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM9_BYTE_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM9_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM9_BYTE_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM9_BYTE_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM9_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM9_BYTE_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM9_BYTE_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM9_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM9_BYTE_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM9LL;                               // CSE PRAM9LL register.
    uint8_t              _EmbeddedRAM9LU;                               // CSE PRAM9LU register.
    uint8_t              _EmbeddedRAM9HL;                               // CSE PRAM9HL register.
    uint8_t              _EmbeddedRAM9HU;                               // CSE PRAM9HU register.
    uint32_t             _EmbeddedRAM10;                                // CSE PRAM 10 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM10_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM10_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM10_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM10_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM10_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM10_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM10_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM10_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM10_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM10_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM10_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM10_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM10LL;                              // CSE PRAM10LL register.
    uint8_t              _EmbeddedRAM10LU;                              // CSE PRAM10LU register.
    uint8_t              _EmbeddedRAM10HL;                              // CSE PRAM10HL register.
    uint8_t              _EmbeddedRAM10HU;                              // CSE PRAM10HU register.
    uint32_t             _EmbeddedRAM11;                                // CSE PRAM 11 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM11_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM11_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM11_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM11_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM11_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM11_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM11_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM11_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM11_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM11_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM11_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM11_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM11LL;                              // CSE PRAM11LL register.
    uint8_t              _EmbeddedRAM11LU;                              // CSE PRAM11LU register.
    uint8_t              _EmbeddedRAM11HL;                              // CSE PRAM11HL register.
    uint8_t              _EmbeddedRAM11HU;                              // CSE PRAM11HU register.
    uint32_t             _EmbeddedRAM12;                                // CSE PRAM 12 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM12_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM12_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM12_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM12_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM12_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM12_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM12_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM12_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM12_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM12_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM12_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM12_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM12LL;                              // CSE PRAM12LL register.
    uint8_t              _EmbeddedRAM12LU;                              // CSE PRAM12LU register.
    uint8_t              _EmbeddedRAM12HL;                              // CSE PRAM12HL register.
    uint8_t              _EmbeddedRAM12HU;                              // CSE PRAM12HU register.
    uint32_t             _EmbeddedRAM13;                                // CSE PRAM 13 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM13_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM13_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM13_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM13_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM13_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM13_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM13_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM13_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM13_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM13_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM13_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM13_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM13LL;                              // CSE PRAM13LL register.
    uint8_t              _EmbeddedRAM13LU;                              // CSE PRAM13LU register.
    uint8_t              _EmbeddedRAM13HL;                              // CSE PRAM13HL register.
    uint8_t              _EmbeddedRAM13HU;                              // CSE PRAM13HU register.
    uint32_t             _EmbeddedRAM14;                                // CSE PRAM 14 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM14_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM14_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM14_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM14_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM14_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM14_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM14_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM14_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM14_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM14_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM14_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM14_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM14LL;                              // CSE PRAM14LL register.
    uint8_t              _EmbeddedRAM14LU;                              // CSE PRAM14LU register.
    uint8_t              _EmbeddedRAM14HL;                              // CSE PRAM14HL register.
    uint8_t              _EmbeddedRAM14HU;                              // CSE PRAM14HU register.
    uint32_t             _EmbeddedRAM15;                                // CSE PRAM 15 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM15_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM15_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM15_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM15_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM15_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM15_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM15_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM15_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM15_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM15_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM15_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM15_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM15LL;                              // CSE PRAM15LL register.
    uint8_t              _EmbeddedRAM15LU;                              // CSE PRAM15LU register.
    uint8_t              _EmbeddedRAM15HL;                              // CSE PRAM15HL register.
    uint8_t              _EmbeddedRAM15HU;                              // CSE PRAM15HU register.
    uint32_t             _EmbeddedRAM16;                                // CSE PRAM 16 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM16_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM16_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM16_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM16_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM16_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM16_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM16_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM16_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM16_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM16_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM16_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM16_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM16LL;                              // CSE PRAM16LL register.
    uint8_t              _EmbeddedRAM16LU;                              // CSE PRAM16LU register.
    uint8_t              _EmbeddedRAM16HL;                              // CSE PRAM16HL register.
    uint8_t              _EmbeddedRAM16HU;                              // CSE PRAM16HU register.
    uint32_t             _EmbeddedRAM17;                                // CSE PRAM 17 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM17_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM17_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM17_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM17_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM17_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM17_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM17_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM17_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM17_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM17_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM17_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM17_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM17LL;                              // CSE PRAM17LL register.
    uint8_t              _EmbeddedRAM17LU;                              // CSE PRAM17LU register.
    uint8_t              _EmbeddedRAM17HL;                              // CSE PRAM17HL register.
    uint8_t              _EmbeddedRAM17HU;                              // CSE PRAM17HU register.
    uint32_t             _EmbeddedRAM18;                                // CSE PRAM 18 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM18_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM18_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM18_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM18_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM18_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM18_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM18_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM18_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM18_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM18_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM18_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM18_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM18LL;                              // CSE PRAM18LL register.
    uint8_t              _EmbeddedRAM18LU;                              // CSE PRAM18LU register.
    uint8_t              _EmbeddedRAM18HL;                              // CSE PRAM18HL register.
    uint8_t              _EmbeddedRAM18HU;                              // CSE PRAM18HU register.
    uint32_t             _EmbeddedRAM19;                                // CSE PRAM 19 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM19_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM19_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM19_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM19_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM19_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM19_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM19_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM19_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM19_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM19_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM19_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM19_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM19LL;                              // CSE PRAM19LL register.
    uint8_t              _EmbeddedRAM19LU;                              // CSE PRAM19LU register.
    uint8_t              _EmbeddedRAM19HL;                              // CSE PRAM19HL register.
    uint8_t              _EmbeddedRAM19HU;                              // CSE PRAM19HU register.
    uint32_t             _EmbeddedRAM20;                                // CSE PRAM 20 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM20_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM20_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM20_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM20_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM20_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM20_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM20_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM20_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM20_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM20_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM20_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM20_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM20LL;                              // CSE PRAM20LL register.
    uint8_t              _EmbeddedRAM20LU;                              // CSE PRAM20LU register.
    uint8_t              _EmbeddedRAM20HL;                              // CSE PRAM20HL register.
    uint8_t              _EmbeddedRAM20HU;                              // CSE PRAM20HU register.
    uint32_t             _EmbeddedRAM21;                                // CSE PRAM 21 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM21_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM21_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM21_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM21_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM21_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM21_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM21_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM21_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM21_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM21_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM21_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM21_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM21LL;                              // CSE PRAM21LL register.
    uint8_t              _EmbeddedRAM21LU;                              // CSE PRAM21LU register.
    uint8_t              _EmbeddedRAM21HL;                              // CSE PRAM21HL register.
    uint8_t              _EmbeddedRAM21HU;                              // CSE PRAM21HU register.
    uint32_t             _EmbeddedRAM22;                                // CSE PRAM 22 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM22_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM22_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM22_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM22_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM22_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM22_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM22_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM22_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM22_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM22_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM22_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM22_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM22LL;                              // CSE PRAM22LL register.
    uint8_t              _EmbeddedRAM22LU;                              // CSE PRAM22LU register.
    uint8_t              _EmbeddedRAM22HL;                              // CSE PRAM22HL register.
    uint8_t              _EmbeddedRAM22HU;                              // CSE PRAM22HU register.
    uint32_t             _EmbeddedRAM23;                                // CSE PRAM 23 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM23_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM23_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM23_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM23_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM23_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM23_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM23_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM23_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM23_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM23_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM23_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM23_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM23LL;                              // CSE PRAM23LL register.
    uint8_t              _EmbeddedRAM23LU;                              // CSE PRAM23LU register.
    uint8_t              _EmbeddedRAM23HL;                              // CSE PRAM23HL register.
    uint8_t              _EmbeddedRAM23HU;                              // CSE PRAM23HU register.
    uint32_t             _EmbeddedRAM24;                                // CSE PRAM 24 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM24_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM24_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM24_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM24_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM24_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM24_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM24_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM24_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM24_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM24_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM24_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM24_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM24LL;                              // CSE PRAM24LL register.
    uint8_t              _EmbeddedRAM24LU;                              // CSE PRAM24LU register.
    uint8_t              _EmbeddedRAM24HL;                              // CSE PRAM24HL register.
    uint8_t              _EmbeddedRAM24HU;                              // CSE PRAM24HU register.
    uint32_t             _EmbeddedRAM25;                                // CSE PRAM 25 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM25_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM25_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM25_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM25_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM25_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM25_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM25_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM25_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM25_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM25_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM25_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM25_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM25LL;                              // CSE PRAM25LL register.
    uint8_t              _EmbeddedRAM25LU;                              // CSE PRAM25LU register.
    uint8_t              _EmbeddedRAM25HL;                              // CSE PRAM25HL register.
    uint8_t              _EmbeddedRAM25HU;                              // CSE PRAM25HU register.
    uint32_t             _EmbeddedRAM26;                                // CSE PRAM 26 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM26_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM26_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM26_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM26_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM26_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM26_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM26_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM26_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM26_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM26_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM26_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM26_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM26LL;                              // CSE PRAM26LL register.
    uint8_t              _EmbeddedRAM26LU;                              // CSE PRAM26LU register.
    uint8_t              _EmbeddedRAM26HL;                              // CSE PRAM26HL register.
    uint8_t              _EmbeddedRAM26HU;                              // CSE PRAM26HU register.
    uint32_t             _EmbeddedRAM27;                                // CSE PRAM 27 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM27_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM27_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM27_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM27_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM27_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM27_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM27_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM27_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM27_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM27_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM27_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM27_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM27LL;                              // CSE PRAM27LL register.
    uint8_t              _EmbeddedRAM27LU;                              // CSE PRAM27LU register.
    uint8_t              _EmbeddedRAM27HL;                              // CSE PRAM27HL register.
    uint8_t              _EmbeddedRAM27HU;                              // CSE PRAM27HU register.
    uint32_t             _EmbeddedRAM28;                                // CSE PRAM 28 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM28_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM28_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM28_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM28_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM28_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM28_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM28_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM28_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM28_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM28_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM28_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM28_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM28LL;                              // CSE PRAM28LL register.
    uint8_t              _EmbeddedRAM28LU;                              // CSE PRAM28LU register.
    uint8_t              _EmbeddedRAM28HL;                              // CSE PRAM28HL register.
    uint8_t              _EmbeddedRAM28HU;                              // CSE PRAM28HU register.
    uint32_t             _EmbeddedRAM29;                                // CSE PRAM 29 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM29_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM29_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM29_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM29_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM29_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM29_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM29_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM29_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM29_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM29_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM29_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM29_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM29LL;                              // CSE PRAM29LL register.
    uint8_t              _EmbeddedRAM29LU;                              // CSE PRAM29LU register.
    uint8_t              _EmbeddedRAM29HL;                              // CSE PRAM29HL register.
    uint8_t              _EmbeddedRAM29HU;                              // CSE PRAM29HU register.
    uint32_t             _EmbeddedRAM30;                                // CSE PRAM 30 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM30_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM30_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM30_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM30_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM30_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM30_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM30_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM30_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM30_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM30_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM30_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM30_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM30LL;                              // CSE PRAM30LL register.
    uint8_t              _EmbeddedRAM30LU;                              // CSE PRAM30LU register.
    uint8_t              _EmbeddedRAM30HL;                              // CSE PRAM30HL register.
    uint8_t              _EmbeddedRAM30HU;                              // CSE PRAM30HU register.
    uint32_t             _EmbeddedRAM31;                                // CSE PRAM 31 Register
                                                                        // Data byte 3 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM31_BYTE_3(_n)       (((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM31_BYTE_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CSE_PRAM__EmbeddedRAM31_BYTE_3_EXTRACT(_v)   (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM31_BYTE_2(_n)       (((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM31_BYTE_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CSE_PRAM__EmbeddedRAM31_BYTE_2_EXTRACT(_v)   (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM31_BYTE_1(_n)       (((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM31_BYTE_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CSE_PRAM__EmbeddedRAM31_BYTE_1_EXTRACT(_v)   (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CSE_PRAM__EmbeddedRAM31_BYTE_0(_n)       (((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM31_BYTE_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CSE_PRAM__EmbeddedRAM31_BYTE_0_EXTRACT(_v)   (((_v) >> 24) & 0xff)

    uint8_t              _EmbeddedRAM31LL;                              // CSE PRAM31LL register.
    uint8_t              _EmbeddedRAM31LU;                              // CSE PRAM31LU register.
    uint8_t              _EmbeddedRAM31HL;                              // CSE PRAM31HL register.
    uint8_t              _EmbeddedRAM31HU;                              // CSE PRAM31HU register.
} CSE_PRAM_regs_t;
                                                                        // --------------------
                                                                        // AIPS-Lite Bridge
typedef struct                                                          // --------------------
{
    uint32_t             MPRA;                                          // Master Privilege Register A
#define AIPS_MPRA_MPL2                           ((uint32_t)1 << 20)    // Master 2 Privilege Level
#define   AIPS_MPRA_MPL2_0                       (uint32_t)0x0          // Accesses from this master are forced to user-mode.
#define   AIPS_MPRA_MPL2_1                       (uint32_t)0x1          // Accesses from this master are not forced to user-mode.
#define AIPS_MPRA_MTW2                           ((uint32_t)1 << 21)    // Master 2 Trusted For Writes
#define   AIPS_MPRA_MTW2_0                       (uint32_t)0x0          // This master is not trusted for write accesses.
#define   AIPS_MPRA_MTW2_1                       (uint32_t)0x1          // This master is trusted for write accesses.
#define AIPS_MPRA_MTR2                           ((uint32_t)1 << 22)    // Master 2 Trusted For Read
#define   AIPS_MPRA_MTR2_0                       (uint32_t)0x0          // This master is not trusted for read accesses.
#define   AIPS_MPRA_MTR2_1                       (uint32_t)0x1          // This master is trusted for read accesses.
#define AIPS_MPRA_MPL1                           ((uint32_t)1 << 24)    // Master 1 Privilege Level
#define   AIPS_MPRA_MPL1_0                       (uint32_t)0x0          // Accesses from this master are forced to user-mode.
#define   AIPS_MPRA_MPL1_1                       (uint32_t)0x1          // Accesses from this master are not forced to user-mode.
#define AIPS_MPRA_MTW1                           ((uint32_t)1 << 25)    // Master 1 Trusted for Writes
#define   AIPS_MPRA_MTW1_0                       (uint32_t)0x0          // This master is not trusted for write accesses.
#define   AIPS_MPRA_MTW1_1                       (uint32_t)0x1          // This master is trusted for write accesses.
#define AIPS_MPRA_MTR1                           ((uint32_t)1 << 26)    // Master 1 Trusted for Read
#define   AIPS_MPRA_MTR1_0                       (uint32_t)0x0          // This master is not trusted for read accesses.
#define   AIPS_MPRA_MTR1_1                       (uint32_t)0x1          // This master is trusted for read accesses.
#define AIPS_MPRA_MPL0                           ((uint32_t)1 << 28)    // Master 0 Privilege Level
#define   AIPS_MPRA_MPL0_0                       (uint32_t)0x0          // Accesses from this master are forced to user-mode.
#define   AIPS_MPRA_MPL0_1                       (uint32_t)0x1          // Accesses from this master are not forced to user-mode.
#define AIPS_MPRA_MTW0                           ((uint32_t)1 << 29)    // Master 0 Trusted For Writes
#define   AIPS_MPRA_MTW0_0                       (uint32_t)0x0          // This master is not trusted for write accesses.
#define   AIPS_MPRA_MTW0_1                       (uint32_t)0x1          // This master is trusted for write accesses.
#define AIPS_MPRA_MTR0                           ((uint32_t)1 << 30)    // Master 0 Trusted For Read
#define   AIPS_MPRA_MTR0_0                       (uint32_t)0x0          // This master is not trusted for read accesses.
#define   AIPS_MPRA_MTR0_1                       (uint32_t)0x1          // This master is trusted for read accesses.

    uint8_t _res0[28];
    uint32_t             PACRA;                                         // Peripheral Access Control Register
#define AIPS_PACRA_TP1                           ((uint32_t)1 << 24)    // Trusted Protect
#define   AIPS_PACRA_TP1_0                       (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_PACRA_TP1_1                       (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_PACRA_WP1                           ((uint32_t)1 << 25)    // Write Protect
#define   AIPS_PACRA_WP1_0                       (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_PACRA_WP1_1                       (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_PACRA_SP1                           ((uint32_t)1 << 26)    // Supervisor Protect
#define   AIPS_PACRA_SP1_0                       (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_PACRA_SP1_1                       (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_PACRA_TP0                           ((uint32_t)1 << 28)    // Trusted Protect
#define   AIPS_PACRA_TP0_0                       (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_PACRA_TP0_1                       (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_PACRA_WP0                           ((uint32_t)1 << 29)    // Write Protect
#define   AIPS_PACRA_WP0_0                       (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_PACRA_WP0_1                       (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_PACRA_SP0                           ((uint32_t)1 << 30)    // Supervisor Protect
#define   AIPS_PACRA_SP0_0                       (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_PACRA_SP0_1                       (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             PACRB;                                         // Peripheral Access Control Register
#define AIPS_PACRB_TP5                           ((uint32_t)1 << 8)     // Trusted Protect
#define   AIPS_PACRB_TP5_0                       (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_PACRB_TP5_1                       (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_PACRB_WP5                           ((uint32_t)1 << 9)     // Write Protect
#define   AIPS_PACRB_WP5_0                       (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_PACRB_WP5_1                       (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_PACRB_SP5                           ((uint32_t)1 << 10)    // Supervisor Protect
#define   AIPS_PACRB_SP5_0                       (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_PACRB_SP5_1                       (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_PACRB_TP1                           ((uint32_t)1 << 24)    // Trusted Protect
#define   AIPS_PACRB_TP1_0                       (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_PACRB_TP1_1                       (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_PACRB_WP1                           ((uint32_t)1 << 25)    // Write Protect
#define   AIPS_PACRB_WP1_0                       (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_PACRB_WP1_1                       (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_PACRB_SP1                           ((uint32_t)1 << 26)    // Supervisor Protect
#define   AIPS_PACRB_SP1_0                       (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_PACRB_SP1_1                       (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_PACRB_TP0                           ((uint32_t)1 << 28)    // Trusted Protect
#define   AIPS_PACRB_TP0_0                       (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_PACRB_TP0_1                       (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_PACRB_WP0                           ((uint32_t)1 << 29)    // Write Protect
#define   AIPS_PACRB_WP0_0                       (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_PACRB_WP0_1                       (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_PACRB_SP0                           ((uint32_t)1 << 30)    // Supervisor Protect
#define   AIPS_PACRB_SP0_0                       (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_PACRB_SP0_1                       (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    const uint32_t       PACRC;                                         // Peripheral Access Control Register
    uint32_t             PACRD;                                         // Peripheral Access Control Register
#define AIPS_PACRD_TP1                           ((uint32_t)1 << 24)    // Trusted Protect
#define   AIPS_PACRD_TP1_0                       (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_PACRD_TP1_1                       (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_PACRD_WP1                           ((uint32_t)1 << 25)    // Write Protect
#define   AIPS_PACRD_WP1_0                       (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_PACRD_WP1_1                       (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_PACRD_SP1                           ((uint32_t)1 << 26)    // Supervisor Protect
#define   AIPS_PACRD_SP1_0                       (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_PACRD_SP1_1                       (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_PACRD_TP0                           ((uint32_t)1 << 28)    // Trusted Protect
#define   AIPS_PACRD_TP0_0                       (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_PACRD_TP0_1                       (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_PACRD_WP0                           ((uint32_t)1 << 29)    // Write Protect
#define   AIPS_PACRD_WP0_0                       (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_PACRD_WP0_1                       (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_PACRD_SP0                           ((uint32_t)1 << 30)    // Supervisor Protect
#define   AIPS_PACRD_SP0_0                       (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_PACRD_SP0_1                       (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint8_t _res1[16];
    uint32_t             OPACRA;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRA_TP7                          ((uint32_t)1 << 0)     // Trusted Protect
#define   AIPS_OPACRA_TP7_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRA_TP7_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRA_WP7                          ((uint32_t)1 << 1)     // Write Protect
#define   AIPS_OPACRA_WP7_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRA_WP7_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRA_SP7                          ((uint32_t)1 << 2)     // Supervisor Protect
#define   AIPS_OPACRA_SP7_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRA_SP7_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRA_TP6                          ((uint32_t)1 << 4)     // Trusted Protect
#define   AIPS_OPACRA_TP6_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRA_TP6_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRA_WP6                          ((uint32_t)1 << 5)     // Write Protect
#define   AIPS_OPACRA_WP6_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRA_WP6_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRA_SP6                          ((uint32_t)1 << 6)     // Supervisor Protect
#define   AIPS_OPACRA_SP6_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRA_SP6_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRA_TP5                          ((uint32_t)1 << 8)     // Trusted Protect
#define   AIPS_OPACRA_TP5_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRA_TP5_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRA_WP5                          ((uint32_t)1 << 9)     // Write Protect
#define   AIPS_OPACRA_WP5_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRA_WP5_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRA_SP5                          ((uint32_t)1 << 10)    // Supervisor Protect
#define   AIPS_OPACRA_SP5_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRA_SP5_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRA_TP4                          ((uint32_t)1 << 12)    // Trusted Protect
#define   AIPS_OPACRA_TP4_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRA_TP4_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRA_WP4                          ((uint32_t)1 << 13)    // Write Protect
#define   AIPS_OPACRA_WP4_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRA_WP4_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRA_SP4                          ((uint32_t)1 << 14)    // Supervisor Protect
#define   AIPS_OPACRA_SP4_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRA_SP4_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRA_TP1                          ((uint32_t)1 << 24)    // Trusted Protect
#define   AIPS_OPACRA_TP1_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRA_TP1_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRA_WP1                          ((uint32_t)1 << 25)    // Write Protect
#define   AIPS_OPACRA_WP1_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRA_WP1_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRA_SP1                          ((uint32_t)1 << 26)    // Supervisor Protect
#define   AIPS_OPACRA_SP1_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRA_SP1_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRA_TP0                          ((uint32_t)1 << 28)    // Trusted Protect
#define   AIPS_OPACRA_TP0_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRA_TP0_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRA_WP0                          ((uint32_t)1 << 29)    // Write Protect
#define   AIPS_OPACRA_WP0_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRA_WP0_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRA_SP0                          ((uint32_t)1 << 30)    // Supervisor Protect
#define   AIPS_OPACRA_SP0_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRA_SP0_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRB;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRB_TP6                          ((uint32_t)1 << 4)     // Trusted Protect
#define   AIPS_OPACRB_TP6_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRB_TP6_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRB_WP6                          ((uint32_t)1 << 5)     // Write Protect
#define   AIPS_OPACRB_WP6_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRB_WP6_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRB_SP6                          ((uint32_t)1 << 6)     // Supervisor Protect
#define   AIPS_OPACRB_SP6_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRB_SP6_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRB_TP5                          ((uint32_t)1 << 8)     // Trusted Protect
#define   AIPS_OPACRB_TP5_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRB_TP5_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRB_WP5                          ((uint32_t)1 << 9)     // Write Protect
#define   AIPS_OPACRB_WP5_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRB_WP5_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRB_SP5                          ((uint32_t)1 << 10)    // Supervisor Protect
#define   AIPS_OPACRB_SP5_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRB_SP5_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRB_TP4                          ((uint32_t)1 << 12)    // Trusted Protect
#define   AIPS_OPACRB_TP4_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRB_TP4_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRB_WP4                          ((uint32_t)1 << 13)    // Write Protect
#define   AIPS_OPACRB_WP4_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRB_WP4_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRB_SP4                          ((uint32_t)1 << 14)    // Supervisor Protect
#define   AIPS_OPACRB_SP4_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRB_SP4_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRB_TP3                          ((uint32_t)1 << 16)    // Trusted Protect
#define   AIPS_OPACRB_TP3_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRB_TP3_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRB_WP3                          ((uint32_t)1 << 17)    // Write Protect
#define   AIPS_OPACRB_WP3_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRB_WP3_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRB_SP3                          ((uint32_t)1 << 18)    // Supervisor Protect
#define   AIPS_OPACRB_SP3_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRB_SP3_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRC;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRC_TP7                          ((uint32_t)1 << 0)     // Trusted Protect
#define   AIPS_OPACRC_TP7_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRC_TP7_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRC_WP7                          ((uint32_t)1 << 1)     // Write Protect
#define   AIPS_OPACRC_WP7_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRC_WP7_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRC_SP7                          ((uint32_t)1 << 2)     // Supervisor Protect
#define   AIPS_OPACRC_SP7_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRC_SP7_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRC_TP6                          ((uint32_t)1 << 4)     // Trusted Protect
#define   AIPS_OPACRC_TP6_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRC_TP6_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRC_WP6                          ((uint32_t)1 << 5)     // Write Protect
#define   AIPS_OPACRC_WP6_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRC_WP6_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRC_SP6                          ((uint32_t)1 << 6)     // Supervisor Protect
#define   AIPS_OPACRC_SP6_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRC_SP6_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRC_TP2                          ((uint32_t)1 << 20)    // Trusted Protect
#define   AIPS_OPACRC_TP2_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRC_TP2_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRC_WP2                          ((uint32_t)1 << 21)    // Write Protect
#define   AIPS_OPACRC_WP2_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRC_WP2_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRC_SP2                          ((uint32_t)1 << 22)    // Supervisor Protect
#define   AIPS_OPACRC_SP2_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRC_SP2_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRC_TP1                          ((uint32_t)1 << 24)    // Trusted Protect
#define   AIPS_OPACRC_TP1_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRC_TP1_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRC_WP1                          ((uint32_t)1 << 25)    // Write Protect
#define   AIPS_OPACRC_WP1_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRC_WP1_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRC_SP1                          ((uint32_t)1 << 26)    // Supervisor Protect
#define   AIPS_OPACRC_SP1_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRC_SP1_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRD;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRD_TP5                          ((uint32_t)1 << 8)     // Trusted Protect
#define   AIPS_OPACRD_TP5_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRD_TP5_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRD_WP5                          ((uint32_t)1 << 9)     // Write Protect
#define   AIPS_OPACRD_WP5_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRD_WP5_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRD_SP5                          ((uint32_t)1 << 10)    // Supervisor Protect
#define   AIPS_OPACRD_SP5_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRD_SP5_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRD_TP3                          ((uint32_t)1 << 16)    // Trusted Protect
#define   AIPS_OPACRD_TP3_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRD_TP3_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRD_WP3                          ((uint32_t)1 << 17)    // Write Protect
#define   AIPS_OPACRD_WP3_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRD_WP3_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRD_SP3                          ((uint32_t)1 << 18)    // Supervisor Protect
#define   AIPS_OPACRD_SP3_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRD_SP3_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRD_TP2                          ((uint32_t)1 << 20)    // Trusted Protect
#define   AIPS_OPACRD_TP2_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRD_TP2_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRD_WP2                          ((uint32_t)1 << 21)    // Write Protect
#define   AIPS_OPACRD_WP2_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRD_WP2_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRD_SP2                          ((uint32_t)1 << 22)    // Supervisor Protect
#define   AIPS_OPACRD_SP2_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRD_SP2_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRD_TP1                          ((uint32_t)1 << 24)    // Trusted Protect
#define   AIPS_OPACRD_TP1_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRD_TP1_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRD_WP1                          ((uint32_t)1 << 25)    // Write Protect
#define   AIPS_OPACRD_WP1_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRD_WP1_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRD_SP1                          ((uint32_t)1 << 26)    // Supervisor Protect
#define   AIPS_OPACRD_SP1_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRD_SP1_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRD_TP0                          ((uint32_t)1 << 28)    // Trusted Protect
#define   AIPS_OPACRD_TP0_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRD_TP0_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRD_WP0                          ((uint32_t)1 << 29)    // Write Protect
#define   AIPS_OPACRD_WP0_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRD_WP0_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRD_SP0                          ((uint32_t)1 << 30)    // Supervisor Protect
#define   AIPS_OPACRD_SP0_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRD_SP0_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRE;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRE_TP6                          ((uint32_t)1 << 4)     // Trusted Protect
#define   AIPS_OPACRE_TP6_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRE_TP6_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRE_WP6                          ((uint32_t)1 << 5)     // Write Protect
#define   AIPS_OPACRE_WP6_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRE_WP6_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRE_SP6                          ((uint32_t)1 << 6)     // Supervisor Protect
#define   AIPS_OPACRE_SP6_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRE_SP6_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRE_TP0                          ((uint32_t)1 << 28)    // Trusted Protect
#define   AIPS_OPACRE_TP0_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRE_TP0_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRE_WP0                          ((uint32_t)1 << 29)    // Write Protect
#define   AIPS_OPACRE_WP0_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRE_WP0_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRE_SP0                          ((uint32_t)1 << 30)    // Supervisor Protect
#define   AIPS_OPACRE_SP0_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRE_SP0_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRF;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRF_TP5                          ((uint32_t)1 << 8)     // Trusted Protect
#define   AIPS_OPACRF_TP5_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRF_TP5_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRF_WP5                          ((uint32_t)1 << 9)     // Write Protect
#define   AIPS_OPACRF_WP5_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRF_WP5_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRF_SP5                          ((uint32_t)1 << 10)    // Supervisor Protect
#define   AIPS_OPACRF_SP5_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRF_SP5_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRF_TP4                          ((uint32_t)1 << 12)    // Trusted Protect
#define   AIPS_OPACRF_TP4_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRF_TP4_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRF_WP4                          ((uint32_t)1 << 13)    // Write Protect
#define   AIPS_OPACRF_WP4_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRF_WP4_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRF_SP4                          ((uint32_t)1 << 14)    // Supervisor Protect
#define   AIPS_OPACRF_SP4_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRF_SP4_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRF_TP3                          ((uint32_t)1 << 16)    // Trusted Protect
#define   AIPS_OPACRF_TP3_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRF_TP3_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRF_WP3                          ((uint32_t)1 << 17)    // Write Protect
#define   AIPS_OPACRF_WP3_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRF_WP3_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRF_SP3                          ((uint32_t)1 << 18)    // Supervisor Protect
#define   AIPS_OPACRF_SP3_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRF_SP3_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRF_TP2                          ((uint32_t)1 << 20)    // Trusted Protect
#define   AIPS_OPACRF_TP2_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRF_TP2_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRF_WP2                          ((uint32_t)1 << 21)    // Write Protect
#define   AIPS_OPACRF_WP2_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRF_WP2_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRF_SP2                          ((uint32_t)1 << 22)    // Supervisor Protect
#define   AIPS_OPACRF_SP2_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRF_SP2_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRF_TP1                          ((uint32_t)1 << 24)    // Trusted Protect
#define   AIPS_OPACRF_TP1_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRF_TP1_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRF_WP1                          ((uint32_t)1 << 25)    // Write Protect
#define   AIPS_OPACRF_WP1_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRF_WP1_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRF_SP1                          ((uint32_t)1 << 26)    // Supervisor Protect
#define   AIPS_OPACRF_SP1_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRF_SP1_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRF_TP0                          ((uint32_t)1 << 28)    // Trusted Protect
#define   AIPS_OPACRF_TP0_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRF_TP0_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRF_WP0                          ((uint32_t)1 << 29)    // Write Protect
#define   AIPS_OPACRF_WP0_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRF_WP0_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRF_SP0                          ((uint32_t)1 << 30)    // Supervisor Protect
#define   AIPS_OPACRF_SP0_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRF_SP0_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRG;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRG_TP2                          ((uint32_t)1 << 20)    // Trusted Protect
#define   AIPS_OPACRG_TP2_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRG_TP2_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRG_WP2                          ((uint32_t)1 << 21)    // Write Protect
#define   AIPS_OPACRG_WP2_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRG_WP2_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRG_SP2                          ((uint32_t)1 << 22)    // Supervisor Protect
#define   AIPS_OPACRG_SP2_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRG_SP2_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRH;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRH_TP2                          ((uint32_t)1 << 20)    // Trusted Protect
#define   AIPS_OPACRH_TP2_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRH_TP2_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRH_WP2                          ((uint32_t)1 << 21)    // Write Protect
#define   AIPS_OPACRH_WP2_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRH_WP2_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRH_SP2                          ((uint32_t)1 << 22)    // Supervisor Protect
#define   AIPS_OPACRH_SP2_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRH_SP2_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRI;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRI_TP6                          ((uint32_t)1 << 4)     // Trusted Protect
#define   AIPS_OPACRI_TP6_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRI_TP6_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRI_WP6                          ((uint32_t)1 << 5)     // Write Protect
#define   AIPS_OPACRI_WP6_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRI_WP6_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRI_SP6                          ((uint32_t)1 << 6)     // Supervisor Protect
#define   AIPS_OPACRI_SP6_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRI_SP6_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRI_TP5                          ((uint32_t)1 << 8)     // Trusted Protect
#define   AIPS_OPACRI_TP5_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRI_TP5_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRI_WP5                          ((uint32_t)1 << 9)     // Write Protect
#define   AIPS_OPACRI_WP5_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRI_WP5_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRI_SP5                          ((uint32_t)1 << 10)    // Supervisor Protect
#define   AIPS_OPACRI_SP5_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRI_SP5_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRI_TP4                          ((uint32_t)1 << 12)    // Trusted Protect
#define   AIPS_OPACRI_TP4_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRI_TP4_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRI_WP4                          ((uint32_t)1 << 13)    // Write Protect
#define   AIPS_OPACRI_WP4_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRI_WP4_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRI_SP4                          ((uint32_t)1 << 14)    // Supervisor Protect
#define   AIPS_OPACRI_SP4_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRI_SP4_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRI_TP3                          ((uint32_t)1 << 16)    // Trusted Protect
#define   AIPS_OPACRI_TP3_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRI_TP3_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRI_WP3                          ((uint32_t)1 << 17)    // Write Protect
#define   AIPS_OPACRI_WP3_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRI_WP3_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRI_SP3                          ((uint32_t)1 << 18)    // Supervisor Protect
#define   AIPS_OPACRI_SP3_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRI_SP3_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRI_TP1                          ((uint32_t)1 << 24)    // Trusted Protect
#define   AIPS_OPACRI_TP1_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRI_TP1_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRI_WP1                          ((uint32_t)1 << 25)    // Write Protect
#define   AIPS_OPACRI_WP1_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRI_WP1_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRI_SP1                          ((uint32_t)1 << 26)    // Supervisor Protect
#define   AIPS_OPACRI_SP1_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRI_SP1_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRJ;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRJ_TP4                          ((uint32_t)1 << 12)    // Trusted Protect
#define   AIPS_OPACRJ_TP4_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRJ_TP4_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRJ_WP4                          ((uint32_t)1 << 13)    // Write Protect
#define   AIPS_OPACRJ_WP4_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRJ_WP4_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRJ_SP4                          ((uint32_t)1 << 14)    // Supervisor Protect
#define   AIPS_OPACRJ_SP4_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRJ_SP4_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRJ_TP3                          ((uint32_t)1 << 16)    // Trusted Protect
#define   AIPS_OPACRJ_TP3_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRJ_TP3_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRJ_WP3                          ((uint32_t)1 << 17)    // Write Protect
#define   AIPS_OPACRJ_WP3_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRJ_WP3_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRJ_SP3                          ((uint32_t)1 << 18)    // Supervisor Protect
#define   AIPS_OPACRJ_SP3_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRJ_SP3_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRJ_TP2                          ((uint32_t)1 << 20)    // Trusted Protect
#define   AIPS_OPACRJ_TP2_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRJ_TP2_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRJ_WP2                          ((uint32_t)1 << 21)    // Write Protect
#define   AIPS_OPACRJ_WP2_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRJ_WP2_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRJ_SP2                          ((uint32_t)1 << 22)    // Supervisor Protect
#define   AIPS_OPACRJ_SP2_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRJ_SP2_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRK;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRK_TP3                          ((uint32_t)1 << 16)    // Trusted Protect
#define   AIPS_OPACRK_TP3_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRK_TP3_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRK_WP3                          ((uint32_t)1 << 17)    // Write Protect
#define   AIPS_OPACRK_WP3_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRK_WP3_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRK_SP3                          ((uint32_t)1 << 18)    // Supervisor Protect
#define   AIPS_OPACRK_SP3_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRK_SP3_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

    uint32_t             OPACRL;                                        // Off-Platform Peripheral Access Control Register
#define AIPS_OPACRL_TP7                          ((uint32_t)1 << 0)     // Trusted Protect
#define   AIPS_OPACRL_TP7_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRL_TP7_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRL_WP7                          ((uint32_t)1 << 1)     // Write Protect
#define   AIPS_OPACRL_WP7_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRL_WP7_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRL_SP7                          ((uint32_t)1 << 2)     // Supervisor Protect
#define   AIPS_OPACRL_SP7_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRL_SP7_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRL_TP6                          ((uint32_t)1 << 4)     // Trusted Protect
#define   AIPS_OPACRL_TP6_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRL_TP6_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRL_WP6                          ((uint32_t)1 << 5)     // Write Protect
#define   AIPS_OPACRL_WP6_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRL_WP6_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRL_SP6                          ((uint32_t)1 << 6)     // Supervisor Protect
#define   AIPS_OPACRL_SP6_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRL_SP6_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.
#define AIPS_OPACRL_TP5                          ((uint32_t)1 << 8)     // Trusted Protect
#define   AIPS_OPACRL_TP5_0                      (uint32_t)0x0          // Accesses from an untrusted master are allowed.
#define   AIPS_OPACRL_TP5_1                      (uint32_t)0x1          // Accesses from an untrusted master are not allowed.
#define AIPS_OPACRL_WP5                          ((uint32_t)1 << 9)     // Write Protect
#define   AIPS_OPACRL_WP5_0                      (uint32_t)0x0          // This peripheral allows write accesses.
#define   AIPS_OPACRL_WP5_1                      (uint32_t)0x1          // This peripheral is write protected.
#define AIPS_OPACRL_SP5                          ((uint32_t)1 << 10)    // Supervisor Protect
#define   AIPS_OPACRL_SP5_0                      (uint32_t)0x0          // This peripheral does not require supervisor privilege level for accesses.
#define   AIPS_OPACRL_SP5_1                      (uint32_t)0x1          // This peripheral requires supervisor privilege level for accesses.

} AIPS_regs_t;
                                                                        // --------------------
                                                                        // MSCM
typedef struct                                                          // --------------------
{
    const uint32_t       CPxTYPE;                                       // Processor X Type Register
                                                                        // Processor x Revision
#define MSCM_CPxTYPE_RYPZ_EXTRACT(_v)                (((_v) >> 0) & 0xff)
                                                                        // Processor x Personality
#define MSCM_CPxTYPE_PERSONALITY_EXTRACT(_v)         (((_v) >> 8) & 0xffffff)

    const uint32_t       CPxNUM;                                        // Processor X Number Register
#define MSCM_CPxNUM_CPN                          ((uint32_t)1 << 0)     // Processor x Number

    const uint32_t       CPxMASTER;                                     // Processor X Master Register
                                                                        // Processor x Physical Master Number
#define MSCM_CPxMASTER_PPMN_EXTRACT(_v)              (((_v) >> 0) & 0x3f)

    const uint32_t       CPxCOUNT;                                      // Processor X Count Register
                                                                        // Processor Count
#define MSCM_CPxCOUNT_PCNT_EXTRACT(_v)               (((_v) >> 0) & 0x3)

    const uint32_t       CPxCFG0;                                       // Processor X Configuration Register 0
                                                                        // Level 1 Data Cache Ways
#define MSCM_CPxCFG0_DCWY_EXTRACT(_v)                (((_v) >> 0) & 0xff)
                                                                        // Level 1 Data Cache Size
#define MSCM_CPxCFG0_DCSZ_EXTRACT(_v)                (((_v) >> 8) & 0xff)
                                                                        // Level 1 Instruction Cache Ways
#define MSCM_CPxCFG0_ICWY_EXTRACT(_v)                (((_v) >> 16) & 0xff)
                                                                        // Level 1 Instruction Cache Size
#define MSCM_CPxCFG0_ICSZ_EXTRACT(_v)                (((_v) >> 24) & 0xff)

    const uint32_t       CPxCFG1;                                       // Processor X Configuration Register 1
                                                                        // Level 2 Instruction Cache Ways
#define MSCM_CPxCFG1_L2WY_EXTRACT(_v)                (((_v) >> 16) & 0xff)
                                                                        // Level 2 Instruction Cache Size
#define MSCM_CPxCFG1_L2SZ_EXTRACT(_v)                (((_v) >> 24) & 0xff)

    const uint32_t       CPxCFG2;                                       // Processor X Configuration Register 2
                                                                        // Tightly-coupled Memory Upper Size
#define MSCM_CPxCFG2_TMUSZ_EXTRACT(_v)               (((_v) >> 8) & 0xff)
                                                                        // Tightly-coupled Memory Lower Size
#define MSCM_CPxCFG2_TMLSZ_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    const uint32_t       CPxCFG3;                                       // Processor X Configuration Register 3
#define MSCM_CPxCFG3_FPU                         ((uint32_t)1 << 0)     // Floating Point Unit
#define   MSCM_CPxCFG3_FPU_0                     (uint32_t)0x0          // FPU support is not included.
#define   MSCM_CPxCFG3_FPU_1                     (uint32_t)0x1          // FPU support is included.
#define MSCM_CPxCFG3_SIMD                        ((uint32_t)1 << 1)     // SIMD/NEON instruction support
#define   MSCM_CPxCFG3_SIMD_0                    (uint32_t)0x0          // SIMD/NEON support is not included.
#define   MSCM_CPxCFG3_SIMD_1                    (uint32_t)0x1          // SIMD/NEON support is included.
#define MSCM_CPxCFG3_JAZ                         ((uint32_t)1 << 2)     // Jazelle support
#define   MSCM_CPxCFG3_JAZ_0                     (uint32_t)0x0          // Jazelle support is not included.
#define   MSCM_CPxCFG3_JAZ_1                     (uint32_t)0x1          // Jazelle support is included.
#define MSCM_CPxCFG3_MMU                         ((uint32_t)1 << 3)     // Memory Management Unit
#define   MSCM_CPxCFG3_MMU_0                     (uint32_t)0x0          // MMU support is not included.
#define   MSCM_CPxCFG3_MMU_1                     (uint32_t)0x1          // MMU support is included.
#define MSCM_CPxCFG3_TZ                          ((uint32_t)1 << 4)     // Trust Zone
#define   MSCM_CPxCFG3_TZ_0                      (uint32_t)0x0          // Trust Zone support is not included.
#define   MSCM_CPxCFG3_TZ_1                      (uint32_t)0x1          // Trust Zone support is included.
#define MSCM_CPxCFG3_CMP                         ((uint32_t)1 << 5)     // Core Memory Protection unit
#define   MSCM_CPxCFG3_CMP_0                     (uint32_t)0x0          // Core Memory Protection is not included.
#define   MSCM_CPxCFG3_CMP_1                     (uint32_t)0x1          // Core Memory Protection is included.
#define MSCM_CPxCFG3_BB                          ((uint32_t)1 << 6)     // Bit Banding
#define   MSCM_CPxCFG3_BB_0                      (uint32_t)0x0          // Bit Banding is not supported.
#define   MSCM_CPxCFG3_BB_1                      (uint32_t)0x1          // Bit Banding is supported.
                                                                        // System Bus Ports
#define MSCM_CPxCFG3_SBP_EXTRACT(_v)                 (((_v) >> 8) & 0x3)

    const uint32_t       CP0TYPE;                                       // Processor 0 Type Register
                                                                        // Processor 0 Revision
#define MSCM_CP0TYPE_RYPZ_EXTRACT(_v)                (((_v) >> 0) & 0xff)
                                                                        // Processor 0 Personality
#define MSCM_CP0TYPE_PERSONALITY_EXTRACT(_v)         (((_v) >> 8) & 0xffffff)

    const uint32_t       CP0NUM;                                        // Processor 0 Number Register
#define MSCM_CP0NUM_CPN                          ((uint32_t)1 << 0)     // Processor 0 Number

    const uint32_t       CP0MASTER;                                     // Processor 0 Master Register
                                                                        // Processor 0 Physical Master Number
#define MSCM_CP0MASTER_PPMN_EXTRACT(_v)              (((_v) >> 0) & 0x3f)

    const uint32_t       CP0COUNT;                                      // Processor 0 Count Register
                                                                        // Processor Count
#define MSCM_CP0COUNT_PCNT_EXTRACT(_v)               (((_v) >> 0) & 0x3)

    const uint32_t       CP0CFG0;                                       // Processor 0 Configuration Register 0
                                                                        // Level 1 Data Cache Ways
#define MSCM_CP0CFG0_DCWY_EXTRACT(_v)                (((_v) >> 0) & 0xff)
                                                                        // Level 1 Data Cache Size
#define MSCM_CP0CFG0_DCSZ_EXTRACT(_v)                (((_v) >> 8) & 0xff)
                                                                        // Level 1 Instruction Cache Ways
#define MSCM_CP0CFG0_ICWY_EXTRACT(_v)                (((_v) >> 16) & 0xff)
                                                                        // Level 1 Instruction Cache Size
#define MSCM_CP0CFG0_ICSZ_EXTRACT(_v)                (((_v) >> 24) & 0xff)

    const uint32_t       CP0CFG1;                                       // Processor 0 Configuration Register 1
                                                                        // Level 2 Instruction Cache Ways
#define MSCM_CP0CFG1_L2WY_EXTRACT(_v)                (((_v) >> 16) & 0xff)
                                                                        // Level 2 Instruction Cache Size
#define MSCM_CP0CFG1_L2SZ_EXTRACT(_v)                (((_v) >> 24) & 0xff)

    const uint32_t       CP0CFG2;                                       // Processor 0 Configuration Register 2
                                                                        // Tightly-coupled Memory Upper Size
#define MSCM_CP0CFG2_TMUSZ_EXTRACT(_v)               (((_v) >> 8) & 0xff)
                                                                        // Tightly-coupled Memory Lower Size
#define MSCM_CP0CFG2_TMLSZ_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    const uint32_t       CP0CFG3;                                       // Processor 0 Configuration Register 3
#define MSCM_CP0CFG3_FPU                         ((uint32_t)1 << 0)     // Floating Point Unit
#define   MSCM_CP0CFG3_FPU_0                     (uint32_t)0x0          // FPU support is not included.
#define   MSCM_CP0CFG3_FPU_1                     (uint32_t)0x1          // FPU support is included.
#define MSCM_CP0CFG3_SIMD                        ((uint32_t)1 << 1)     // SIMD/NEON instruction support
#define   MSCM_CP0CFG3_SIMD_0                    (uint32_t)0x0          // SIMD/NEON support is not included.
#define   MSCM_CP0CFG3_SIMD_1                    (uint32_t)0x1          // SIMD/NEON support is included.
#define MSCM_CP0CFG3_JAZ                         ((uint32_t)1 << 2)     // Jazelle support
#define   MSCM_CP0CFG3_JAZ_0                     (uint32_t)0x0          // Jazelle support is not included.
#define   MSCM_CP0CFG3_JAZ_1                     (uint32_t)0x1          // Jazelle support is included.
#define MSCM_CP0CFG3_MMU                         ((uint32_t)1 << 3)     // Memory Management Unit
#define   MSCM_CP0CFG3_MMU_0                     (uint32_t)0x0          // MMU support is not included.
#define   MSCM_CP0CFG3_MMU_1                     (uint32_t)0x1          // MMU support is included.
#define MSCM_CP0CFG3_TZ                          ((uint32_t)1 << 4)     // Trust Zone
#define   MSCM_CP0CFG3_TZ_0                      (uint32_t)0x0          // Trust Zone support is not included.
#define   MSCM_CP0CFG3_TZ_1                      (uint32_t)0x1          // Trust Zone support is included.
#define MSCM_CP0CFG3_CMP                         ((uint32_t)1 << 5)     // Core Memory Protection unit
#define   MSCM_CP0CFG3_CMP_0                     (uint32_t)0x0          // Core Memory Protection is not included.
#define   MSCM_CP0CFG3_CMP_1                     (uint32_t)0x1          // Core Memory Protection is included.
#define MSCM_CP0CFG3_BB                          ((uint32_t)1 << 6)     // Bit Banding
#define   MSCM_CP0CFG3_BB_0                      (uint32_t)0x0          // Bit Banding is not supported.
#define   MSCM_CP0CFG3_BB_1                      (uint32_t)0x1          // Bit Banding is supported.
                                                                        // System Bus Ports
#define MSCM_CP0CFG3_SBP_EXTRACT(_v)                 (((_v) >> 8) & 0x3)

    uint8_t _res0[960];
    uint32_t             OCMDR0;                                        // On-Chip Memory Descriptor Register
                                                                        // OCMEM Control Field 1
#define MSCM_OCMDR0_OCM1(_n)                     (((uint32_t)(_n) & 0x3) << 4)
#define MSCM_OCMDR0_OCM1_INSERT(_v, _n)              (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define MSCM_OCMDR0_OCM1_EXTRACT(_v)                 (((_v) >> 4) & 0x3)
#define MSCM_OCMDR0_OCMPU                        ((uint32_t)1 << 12)    // OCMPU
                                                                        // OCMT
#define MSCM_OCMDR0_OCMT(_n)                     (((uint32_t)(_n) & 0x7) << 13)
#define MSCM_OCMDR0_OCMT_INSERT(_v, _n)              (((_v) & ~0xe000) | ((uint32_t)(_n) & 0x7) << 13)
#define MSCM_OCMDR0_OCMT_EXTRACT(_v)                 (((_v) >> 13) & 0x7)
#define   MSCM_OCMDR0_OCMT_100                   (uint32_t)0x4          // OCMEMn is a Program Flash.
#define   MSCM_OCMDR0_OCMT_101                   (uint32_t)0x5          // OCMEMn is a Data Flash.
#define   MSCM_OCMDR0_OCMT_110                   (uint32_t)0x6          // OCMEMn is an EEE.
#define MSCM_OCMDR0_RO                           ((uint32_t)1 << 16)    // RO
#define   MSCM_OCMDR0_RO_0                       (uint32_t)0x0          // Writes to the OCMDRn[11:0] are allowed
#define   MSCM_OCMDR0_RO_1                       (uint32_t)0x1          // Writes to the OCMDRn[11:0] are ignored
                                                                        // OCMW
#define MSCM_OCMDR0_OCMW(_n)                     (((uint32_t)(_n) & 0x7) << 17)
#define MSCM_OCMDR0_OCMW_INSERT(_v, _n)              (((_v) & ~0xe0000) | ((uint32_t)(_n) & 0x7) << 17)
#define MSCM_OCMDR0_OCMW_EXTRACT(_v)                 (((_v) >> 17) & 0x7)
#define   MSCM_OCMDR0_OCMW_010                   (uint32_t)0x2          // OCMEMn 32-bits wide
#define   MSCM_OCMDR0_OCMW_011                   (uint32_t)0x3          // OCMEMn 64-bits wide
#define   MSCM_OCMDR0_OCMW_100                   (uint32_t)0x4          // OCMEMn 128-bits wide
#define   MSCM_OCMDR0_OCMW_101                   (uint32_t)0x5          // OCMEMn 256-bits wide
                                                                        // OCMSZ
#define MSCM_OCMDR0_OCMSZ(_n)                    (((uint32_t)(_n) & 0xf) << 24)
#define MSCM_OCMDR0_OCMSZ_INSERT(_v, _n)             (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define MSCM_OCMDR0_OCMSZ_EXTRACT(_v)                (((_v) >> 24) & 0xf)
#define   MSCM_OCMDR0_OCMSZ_0000                 (uint32_t)0x0          // no OCMEMn
#define   MSCM_OCMDR0_OCMSZ_0001                 (uint32_t)0x1          // 1KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_0010                 (uint32_t)0x2          // 2KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_0011                 (uint32_t)0x3          // 4KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_0100                 (uint32_t)0x4          // 8KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_0101                 (uint32_t)0x5          // 16KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_0110                 (uint32_t)0x6          // 32KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_0111                 (uint32_t)0x7          // 64KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_1000                 (uint32_t)0x8          // 128KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_1001                 (uint32_t)0x9          // 256KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_1010                 (uint32_t)0xa          // 512KB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_1011                 (uint32_t)0xb          // 1MB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_1100                 (uint32_t)0xc          // 2MB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_1101                 (uint32_t)0xd          // 4MB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_1110                 (uint32_t)0xe          // 8MB OCMEMn
#define   MSCM_OCMDR0_OCMSZ_1111                 (uint32_t)0xf          // 16MB OCMEMn
#define MSCM_OCMDR0_OCMSZH                       ((uint32_t)1 << 28)    // OCMSZH
#define   MSCM_OCMDR0_OCMSZH_0                   (uint32_t)0x0          // OCMEMn is a power-of-2 capacity.
#define   MSCM_OCMDR0_OCMSZH_1                   (uint32_t)0x1          // OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.
#define MSCM_OCMDR0_V                            ((uint32_t)1 << 31)    // V
#define   MSCM_OCMDR0_V_0                        (uint32_t)0x0          // OCMEMn is not present.
#define   MSCM_OCMDR0_V_1                        (uint32_t)0x1          // OCMEMn is present.

    uint32_t             OCMDR1;                                        // On-Chip Memory Descriptor Register
                                                                        // OCMEM Control Field 1
#define MSCM_OCMDR1_OCM1(_n)                     (((uint32_t)(_n) & 0x3) << 4)
#define MSCM_OCMDR1_OCM1_INSERT(_v, _n)              (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define MSCM_OCMDR1_OCM1_EXTRACT(_v)                 (((_v) >> 4) & 0x3)
#define MSCM_OCMDR1_OCMPU                        ((uint32_t)1 << 12)    // OCMPU
                                                                        // OCMT
#define MSCM_OCMDR1_OCMT(_n)                     (((uint32_t)(_n) & 0x7) << 13)
#define MSCM_OCMDR1_OCMT_INSERT(_v, _n)              (((_v) & ~0xe000) | ((uint32_t)(_n) & 0x7) << 13)
#define MSCM_OCMDR1_OCMT_EXTRACT(_v)                 (((_v) >> 13) & 0x7)
#define   MSCM_OCMDR1_OCMT_100                   (uint32_t)0x4          // OCMEMn is a Program Flash.
#define   MSCM_OCMDR1_OCMT_101                   (uint32_t)0x5          // OCMEMn is a Data Flash.
#define   MSCM_OCMDR1_OCMT_110                   (uint32_t)0x6          // OCMEMn is an EEE.
#define MSCM_OCMDR1_RO                           ((uint32_t)1 << 16)    // RO
#define   MSCM_OCMDR1_RO_0                       (uint32_t)0x0          // Writes to the OCMDRn[11:0] are allowed
#define   MSCM_OCMDR1_RO_1                       (uint32_t)0x1          // Writes to the OCMDRn[11:0] are ignored
                                                                        // OCMW
#define MSCM_OCMDR1_OCMW(_n)                     (((uint32_t)(_n) & 0x7) << 17)
#define MSCM_OCMDR1_OCMW_INSERT(_v, _n)              (((_v) & ~0xe0000) | ((uint32_t)(_n) & 0x7) << 17)
#define MSCM_OCMDR1_OCMW_EXTRACT(_v)                 (((_v) >> 17) & 0x7)
#define   MSCM_OCMDR1_OCMW_010                   (uint32_t)0x2          // OCMEMn 32-bits wide
#define   MSCM_OCMDR1_OCMW_011                   (uint32_t)0x3          // OCMEMn 64-bits wide
#define   MSCM_OCMDR1_OCMW_100                   (uint32_t)0x4          // OCMEMn 128-bits wide
#define   MSCM_OCMDR1_OCMW_101                   (uint32_t)0x5          // OCMEMn 256-bits wide
                                                                        // OCMSZ
#define MSCM_OCMDR1_OCMSZ(_n)                    (((uint32_t)(_n) & 0xf) << 24)
#define MSCM_OCMDR1_OCMSZ_INSERT(_v, _n)             (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define MSCM_OCMDR1_OCMSZ_EXTRACT(_v)                (((_v) >> 24) & 0xf)
#define   MSCM_OCMDR1_OCMSZ_0000                 (uint32_t)0x0          // no OCMEMn
#define   MSCM_OCMDR1_OCMSZ_0001                 (uint32_t)0x1          // 1KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_0010                 (uint32_t)0x2          // 2KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_0011                 (uint32_t)0x3          // 4KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_0100                 (uint32_t)0x4          // 8KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_0101                 (uint32_t)0x5          // 16KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_0110                 (uint32_t)0x6          // 32KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_0111                 (uint32_t)0x7          // 64KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_1000                 (uint32_t)0x8          // 128KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_1001                 (uint32_t)0x9          // 256KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_1010                 (uint32_t)0xa          // 512KB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_1011                 (uint32_t)0xb          // 1MB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_1100                 (uint32_t)0xc          // 2MB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_1101                 (uint32_t)0xd          // 4MB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_1110                 (uint32_t)0xe          // 8MB OCMEMn
#define   MSCM_OCMDR1_OCMSZ_1111                 (uint32_t)0xf          // 16MB OCMEMn
#define MSCM_OCMDR1_OCMSZH                       ((uint32_t)1 << 28)    // OCMSZH
#define   MSCM_OCMDR1_OCMSZH_0                   (uint32_t)0x0          // OCMEMn is a power-of-2 capacity.
#define   MSCM_OCMDR1_OCMSZH_1                   (uint32_t)0x1          // OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.
#define MSCM_OCMDR1_V                            ((uint32_t)1 << 31)    // V
#define   MSCM_OCMDR1_V_0                        (uint32_t)0x0          // OCMEMn is not present.
#define   MSCM_OCMDR1_V_1                        (uint32_t)0x1          // OCMEMn is present.

    uint32_t             OCMDR2;                                        // On-Chip Memory Descriptor Register
#define MSCM_OCMDR2_OCMPU                        ((uint32_t)1 << 12)    // OCMPU
                                                                        // OCMT
#define MSCM_OCMDR2_OCMT(_n)                     (((uint32_t)(_n) & 0x7) << 13)
#define MSCM_OCMDR2_OCMT_INSERT(_v, _n)              (((_v) & ~0xe000) | ((uint32_t)(_n) & 0x7) << 13)
#define MSCM_OCMDR2_OCMT_EXTRACT(_v)                 (((_v) >> 13) & 0x7)
#define   MSCM_OCMDR2_OCMT_100                   (uint32_t)0x4          // OCMEMn is a Program Flash.
#define   MSCM_OCMDR2_OCMT_101                   (uint32_t)0x5          // OCMEMn is a Data Flash.
#define   MSCM_OCMDR2_OCMT_110                   (uint32_t)0x6          // OCMEMn is an EEE.
#define MSCM_OCMDR2_RO                           ((uint32_t)1 << 16)    // RO
#define   MSCM_OCMDR2_RO_0                       (uint32_t)0x0          // Writes to the OCMDRn[11:0] are allowed
#define   MSCM_OCMDR2_RO_1                       (uint32_t)0x1          // Writes to the OCMDRn[11:0] are ignored
                                                                        // OCMW
#define MSCM_OCMDR2_OCMW(_n)                     (((uint32_t)(_n) & 0x7) << 17)
#define MSCM_OCMDR2_OCMW_INSERT(_v, _n)              (((_v) & ~0xe0000) | ((uint32_t)(_n) & 0x7) << 17)
#define MSCM_OCMDR2_OCMW_EXTRACT(_v)                 (((_v) >> 17) & 0x7)
#define   MSCM_OCMDR2_OCMW_010                   (uint32_t)0x2          // OCMEMn 32-bits wide
#define   MSCM_OCMDR2_OCMW_011                   (uint32_t)0x3          // OCMEMn 64-bits wide
#define   MSCM_OCMDR2_OCMW_100                   (uint32_t)0x4          // OCMEMn 128-bits wide
#define   MSCM_OCMDR2_OCMW_101                   (uint32_t)0x5          // OCMEMn 256-bits wide
                                                                        // OCMSZ
#define MSCM_OCMDR2_OCMSZ(_n)                    (((uint32_t)(_n) & 0xf) << 24)
#define MSCM_OCMDR2_OCMSZ_INSERT(_v, _n)             (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define MSCM_OCMDR2_OCMSZ_EXTRACT(_v)                (((_v) >> 24) & 0xf)
#define   MSCM_OCMDR2_OCMSZ_0000                 (uint32_t)0x0          // no OCMEMn
#define   MSCM_OCMDR2_OCMSZ_0001                 (uint32_t)0x1          // 1KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_0010                 (uint32_t)0x2          // 2KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_0011                 (uint32_t)0x3          // 4KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_0100                 (uint32_t)0x4          // 8KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_0101                 (uint32_t)0x5          // 16KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_0110                 (uint32_t)0x6          // 32KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_0111                 (uint32_t)0x7          // 64KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_1000                 (uint32_t)0x8          // 128KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_1001                 (uint32_t)0x9          // 256KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_1010                 (uint32_t)0xa          // 512KB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_1011                 (uint32_t)0xb          // 1MB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_1100                 (uint32_t)0xc          // 2MB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_1101                 (uint32_t)0xd          // 4MB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_1110                 (uint32_t)0xe          // 8MB OCMEMn
#define   MSCM_OCMDR2_OCMSZ_1111                 (uint32_t)0xf          // 16MB OCMEMn
#define MSCM_OCMDR2_OCMSZH                       ((uint32_t)1 << 28)    // OCMSZH
#define   MSCM_OCMDR2_OCMSZH_0                   (uint32_t)0x0          // OCMEMn is a power-of-2 capacity.
#define   MSCM_OCMDR2_OCMSZH_1                   (uint32_t)0x1          // OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.
#define MSCM_OCMDR2_V                            ((uint32_t)1 << 31)    // V
#define   MSCM_OCMDR2_V_0                        (uint32_t)0x0          // OCMEMn is not present.
#define   MSCM_OCMDR2_V_1                        (uint32_t)0x1          // OCMEMn is present.

} MSCM_regs_t;
                                                                        // --------------------
                                                                        // Enhanced Direct Memory Access
typedef struct                                                          // --------------------
{
    uint32_t             CR;                                            // Control Register
#define DMA_CR_EDBG                              ((uint32_t)1 << 1)     // Enable Debug
#define DMA_CR_ERCA                              ((uint32_t)1 << 2)     // Enable Round Robin Channel Arbitration
#define DMA_CR_HOE                               ((uint32_t)1 << 4)     // Halt On Error
#define   DMA_CR_HOE_0                           (uint32_t)0x0          // Normal operation
#define   DMA_CR_HOE_1                           (uint32_t)0x1          // Any error causes the HALT bit to set. Subsequently, all service requests are ignored until the HALT bit is cleared.
#define DMA_CR_HALT                              ((uint32_t)1 << 5)     // Halt DMA Operations
#define   DMA_CR_HALT_0                          (uint32_t)0x0          // Normal operation
#define   DMA_CR_HALT_1                          (uint32_t)0x1          // Stall the start of any new channels. Executing channels are allowed to complete. Channel execution resumes when this bit is cleared.
#define DMA_CR_CLM                               ((uint32_t)1 << 6)     // Continuous Link Mode
#define   DMA_CR_CLM_0                           (uint32_t)0x0          // A minor loop channel link made to itself goes through channel arbitration before being activated again.
#define   DMA_CR_CLM_1                           (uint32_t)0x1          // A minor loop channel link made to itself does not go through channel arbitration before being activated again. Upon minor loop completion, the channel activates again if that channel has a minor loop channel link enabled and the link channel is itself. This effectively applies the minor loop offsets and restarts the next minor loop.
#define DMA_CR_EMLM                              ((uint32_t)1 << 7)     // Enable Minor Loop Mapping
#define   DMA_CR_EMLM_0                          (uint32_t)0x0          // Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
#define   DMA_CR_EMLM_1                          (uint32_t)0x1          // Enabled. TCDn.word2 is redefined to include individual enable fields, an offset field, and the NBYTES field. The individual enable fields allow the minor loop offset to be applied to the source address, the destination address, or both. The NBYTES field is reduced when either offset is enabled.
#define DMA_CR_ECX                               ((uint32_t)1 << 16)    // Error Cancel Transfer
#define   DMA_CR_ECX_0                           (uint32_t)0x0          // Normal operation
#define   DMA_CR_ECX_1                           (uint32_t)0x1          // Cancel the remaining data transfer in the same fashion as the CX bit. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The ECX bit clears itself after the cancel is honored. In addition to cancelling the transfer, ECX treats the cancel as an error condition, thus updating the Error Status register (DMAx_ES) and generating an optional error interrupt.
#define DMA_CR_CX                                ((uint32_t)1 << 17)    // Cancel Transfer
#define   DMA_CR_CX_0                            (uint32_t)0x0          // Normal operation
#define   DMA_CR_CX_1                            (uint32_t)0x1          // Cancel the remaining data transfer. Stop the executing channel and force the minor loop to finish. The cancel takes effect after the last write of the current read/write sequence. The CX bit clears itself after the cancel has been honored. This cancel retires the channel normally as if the minor loop was completed.
#define DMA_CR_ACTIVE                            ((uint32_t)1 << 31)    // DMA Active Status
#define   DMA_CR_ACTIVE_0                        (uint32_t)0x0          // eDMA is idle.
#define   DMA_CR_ACTIVE_1                        (uint32_t)0x1          // eDMA is executing a channel.

    const uint32_t       ES;                                            // Error Status Register
#define DMA_ES_DBE                               ((uint32_t)1 << 0)     // Destination Bus Error
#define   DMA_ES_DBE_0                           (uint32_t)0x0          // No destination bus error
#define   DMA_ES_DBE_1                           (uint32_t)0x1          // The last recorded error was a bus error on a destination write
#define DMA_ES_SBE                               ((uint32_t)1 << 1)     // Source Bus Error
#define   DMA_ES_SBE_0                           (uint32_t)0x0          // No source bus error
#define   DMA_ES_SBE_1                           (uint32_t)0x1          // The last recorded error was a bus error on a source read
#define DMA_ES_SGE                               ((uint32_t)1 << 2)     // Scatter/Gather Configuration Error
#define   DMA_ES_SGE_0                           (uint32_t)0x0          // No scatter/gather configuration error
#define   DMA_ES_SGE_1                           (uint32_t)0x1          // The last recorded error was a configuration error detected in the TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather operation after major loop completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is not on a 32 byte boundary.
#define DMA_ES_NCE                               ((uint32_t)1 << 3)     // NBYTES/CITER Configuration Error
#define   DMA_ES_NCE_0                           (uint32_t)0x0          // No NBYTES/CITER configuration error
#define DMA_ES_DOE                               ((uint32_t)1 << 4)     // Destination Offset Error
#define   DMA_ES_DOE_0                           (uint32_t)0x0          // No destination offset configuration error
#define   DMA_ES_DOE_1                           (uint32_t)0x1          // The last recorded error was a configuration error detected in the TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
#define DMA_ES_DAE                               ((uint32_t)1 << 5)     // Destination Address Error
#define   DMA_ES_DAE_0                           (uint32_t)0x0          // No destination address configuration error
#define   DMA_ES_DAE_1                           (uint32_t)0x1          // The last recorded error was a configuration error detected in the TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
#define DMA_ES_SOE                               ((uint32_t)1 << 6)     // Source Offset Error
#define   DMA_ES_SOE_0                           (uint32_t)0x0          // No source offset configuration error
#define   DMA_ES_SOE_1                           (uint32_t)0x1          // The last recorded error was a configuration error detected in the TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
#define DMA_ES_SAE                               ((uint32_t)1 << 7)     // Source Address Error
#define   DMA_ES_SAE_0                           (uint32_t)0x0          // No source address configuration error.
#define   DMA_ES_SAE_1                           (uint32_t)0x1          // The last recorded error was a configuration error detected in the TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
                                                                        // Error Channel Number or Canceled Channel Number
#define DMA_ES_ERRCHN_EXTRACT(_v)                    (((_v) >> 8) & 0xf)
#define DMA_ES_CPE                               ((uint32_t)1 << 14)    // Channel Priority Error
#define   DMA_ES_CPE_0                           (uint32_t)0x0          // No channel priority error
#define DMA_ES_ECX                               ((uint32_t)1 << 16)    // Transfer Canceled
#define   DMA_ES_ECX_0                           (uint32_t)0x0          // No canceled transfers
#define   DMA_ES_ECX_1                           (uint32_t)0x1          // The last recorded entry was a canceled transfer by the error cancel transfer input
#define DMA_ES_VLD                               ((uint32_t)1 << 31)    // VLD
#define   DMA_ES_VLD_0                           (uint32_t)0x0          // No ERR bits are set.
#define   DMA_ES_VLD_1                           (uint32_t)0x1          // At least one ERR bit is set indicating a valid error exists that has not been cleared.

    uint8_t _res0[4];
    uint32_t             ERQ;                                           // Enable Request Register
#define DMA_ERQ_ERQ0                             ((uint32_t)1 << 0)     // Enable DMA Request 0
#define   DMA_ERQ_ERQ0_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ0_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ1                             ((uint32_t)1 << 1)     // Enable DMA Request 1
#define   DMA_ERQ_ERQ1_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ1_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ2                             ((uint32_t)1 << 2)     // Enable DMA Request 2
#define   DMA_ERQ_ERQ2_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ2_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ3                             ((uint32_t)1 << 3)     // Enable DMA Request 3
#define   DMA_ERQ_ERQ3_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ3_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ4                             ((uint32_t)1 << 4)     // Enable DMA Request 4
#define   DMA_ERQ_ERQ4_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ4_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ5                             ((uint32_t)1 << 5)     // Enable DMA Request 5
#define   DMA_ERQ_ERQ5_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ5_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ6                             ((uint32_t)1 << 6)     // Enable DMA Request 6
#define   DMA_ERQ_ERQ6_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ6_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ7                             ((uint32_t)1 << 7)     // Enable DMA Request 7
#define   DMA_ERQ_ERQ7_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ7_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ8                             ((uint32_t)1 << 8)     // Enable DMA Request 8
#define   DMA_ERQ_ERQ8_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ8_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ9                             ((uint32_t)1 << 9)     // Enable DMA Request 9
#define   DMA_ERQ_ERQ9_0                         (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ9_1                         (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ10                            ((uint32_t)1 << 10)    // Enable DMA Request 10
#define   DMA_ERQ_ERQ10_0                        (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ10_1                        (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ11                            ((uint32_t)1 << 11)    // Enable DMA Request 11
#define   DMA_ERQ_ERQ11_0                        (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ11_1                        (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ12                            ((uint32_t)1 << 12)    // Enable DMA Request 12
#define   DMA_ERQ_ERQ12_0                        (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ12_1                        (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ13                            ((uint32_t)1 << 13)    // Enable DMA Request 13
#define   DMA_ERQ_ERQ13_0                        (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ13_1                        (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ14                            ((uint32_t)1 << 14)    // Enable DMA Request 14
#define   DMA_ERQ_ERQ14_0                        (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ14_1                        (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled
#define DMA_ERQ_ERQ15                            ((uint32_t)1 << 15)    // Enable DMA Request 15
#define   DMA_ERQ_ERQ15_0                        (uint32_t)0x0          // The DMA request signal for the corresponding channel is disabled
#define   DMA_ERQ_ERQ15_1                        (uint32_t)0x1          // The DMA request signal for the corresponding channel is enabled

    uint8_t _res1[4];
    uint32_t             EEI;                                           // Enable Error Interrupt Register
#define DMA_EEI_EEI0                             ((uint32_t)1 << 0)     // Enable Error Interrupt 0
#define   DMA_EEI_EEI0_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI0_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI1                             ((uint32_t)1 << 1)     // Enable Error Interrupt 1
#define   DMA_EEI_EEI1_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI1_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI2                             ((uint32_t)1 << 2)     // Enable Error Interrupt 2
#define   DMA_EEI_EEI2_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI2_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI3                             ((uint32_t)1 << 3)     // Enable Error Interrupt 3
#define   DMA_EEI_EEI3_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI3_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI4                             ((uint32_t)1 << 4)     // Enable Error Interrupt 4
#define   DMA_EEI_EEI4_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI4_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI5                             ((uint32_t)1 << 5)     // Enable Error Interrupt 5
#define   DMA_EEI_EEI5_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI5_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI6                             ((uint32_t)1 << 6)     // Enable Error Interrupt 6
#define   DMA_EEI_EEI6_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI6_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI7                             ((uint32_t)1 << 7)     // Enable Error Interrupt 7
#define   DMA_EEI_EEI7_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI7_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI8                             ((uint32_t)1 << 8)     // Enable Error Interrupt 8
#define   DMA_EEI_EEI8_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI8_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI9                             ((uint32_t)1 << 9)     // Enable Error Interrupt 9
#define   DMA_EEI_EEI9_0                         (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI9_1                         (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI10                            ((uint32_t)1 << 10)    // Enable Error Interrupt 10
#define   DMA_EEI_EEI10_0                        (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI10_1                        (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI11                            ((uint32_t)1 << 11)    // Enable Error Interrupt 11
#define   DMA_EEI_EEI11_0                        (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI11_1                        (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI12                            ((uint32_t)1 << 12)    // Enable Error Interrupt 12
#define   DMA_EEI_EEI12_0                        (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI12_1                        (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI13                            ((uint32_t)1 << 13)    // Enable Error Interrupt 13
#define   DMA_EEI_EEI13_0                        (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI13_1                        (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI14                            ((uint32_t)1 << 14)    // Enable Error Interrupt 14
#define   DMA_EEI_EEI14_0                        (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI14_1                        (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request
#define DMA_EEI_EEI15                            ((uint32_t)1 << 15)    // Enable Error Interrupt 15
#define   DMA_EEI_EEI15_0                        (uint32_t)0x0          // The error signal for corresponding channel does not generate an error interrupt
#define   DMA_EEI_EEI15_1                        (uint32_t)0x1          // The assertion of the error signal for corresponding channel generates an error interrupt request

    uint8_t              CEEI;                                          // Clear Enable Error Interrupt Register
                                                                        // Clear Enable Error Interrupt
#define DMA_CEEI_CEEI(_n)                        (((uint8_t)(_n) & 0xf) << 0)
#define DMA_CEEI_CEEI_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_CEEI_CAEE                            ((uint8_t)1 << 6)      // Clear All Enable Error Interrupts
#define DMA_CEEI_NOP                             ((uint8_t)1 << 7)      // No Op enable
#define   DMA_CEEI_NOP_0                         (uint8_t)0x0           // Normal operation
#define   DMA_CEEI_NOP_1                         (uint8_t)0x1           // No operation, ignore the other bits in this register

    uint8_t              SEEI;                                          // Set Enable Error Interrupt Register
                                                                        // Set Enable Error Interrupt
#define DMA_SEEI_SEEI(_n)                        (((uint8_t)(_n) & 0xf) << 0)
#define DMA_SEEI_SEEI_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_SEEI_SAEE                            ((uint8_t)1 << 6)      // Sets All Enable Error Interrupts
#define DMA_SEEI_NOP                             ((uint8_t)1 << 7)      // No Op enable
#define   DMA_SEEI_NOP_0                         (uint8_t)0x0           // Normal operation
#define   DMA_SEEI_NOP_1                         (uint8_t)0x1           // No operation, ignore the other bits in this register

    uint8_t              CERQ;                                          // Clear Enable Request Register
                                                                        // Clear Enable Request
#define DMA_CERQ_CERQ(_n)                        (((uint8_t)(_n) & 0xf) << 0)
#define DMA_CERQ_CERQ_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_CERQ_CAER                            ((uint8_t)1 << 6)      // Clear All Enable Requests
#define DMA_CERQ_NOP                             ((uint8_t)1 << 7)      // No Op enable
#define   DMA_CERQ_NOP_0                         (uint8_t)0x0           // Normal operation
#define   DMA_CERQ_NOP_1                         (uint8_t)0x1           // No operation, ignore the other bits in this register

    uint8_t              SERQ;                                          // Set Enable Request Register
                                                                        // Set Enable Request
#define DMA_SERQ_SERQ(_n)                        (((uint8_t)(_n) & 0xf) << 0)
#define DMA_SERQ_SERQ_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_SERQ_SAER                            ((uint8_t)1 << 6)      // Set All Enable Requests
#define DMA_SERQ_NOP                             ((uint8_t)1 << 7)      // No Op enable
#define   DMA_SERQ_NOP_0                         (uint8_t)0x0           // Normal operation
#define   DMA_SERQ_NOP_1                         (uint8_t)0x1           // No operation, ignore the other bits in this register

    uint8_t              CDNE;                                          // Clear DONE Status Bit Register
                                                                        // Clear DONE Bit
#define DMA_CDNE_CDNE(_n)                        (((uint8_t)(_n) & 0xf) << 0)
#define DMA_CDNE_CDNE_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_CDNE_CADN                            ((uint8_t)1 << 6)      // Clears All DONE Bits
#define   DMA_CDNE_CADN_0                        (uint8_t)0x0           // Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
#define   DMA_CDNE_CADN_1                        (uint8_t)0x1           // Clears all bits in TCDn_CSR[DONE]
#define DMA_CDNE_NOP                             ((uint8_t)1 << 7)      // No Op enable
#define   DMA_CDNE_NOP_0                         (uint8_t)0x0           // Normal operation
#define   DMA_CDNE_NOP_1                         (uint8_t)0x1           // No operation, ignore the other bits in this register

    uint8_t              SSRT;                                          // Set START Bit Register
                                                                        // Set START Bit
#define DMA_SSRT_SSRT(_n)                        (((uint8_t)(_n) & 0xf) << 0)
#define DMA_SSRT_SSRT_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_SSRT_SAST                            ((uint8_t)1 << 6)      // Set All START Bits (activates all channels)
#define   DMA_SSRT_SAST_0                        (uint8_t)0x0           // Set only the TCDn_CSR[START] bit specified in the SSRT field
#define   DMA_SSRT_SAST_1                        (uint8_t)0x1           // Set all bits in TCDn_CSR[START]
#define DMA_SSRT_NOP                             ((uint8_t)1 << 7)      // No Op enable
#define   DMA_SSRT_NOP_0                         (uint8_t)0x0           // Normal operation
#define   DMA_SSRT_NOP_1                         (uint8_t)0x1           // No operation, ignore the other bits in this register

    uint8_t              CERR;                                          // Clear Error Register
                                                                        // Clear Error Indicator
#define DMA_CERR_CERR(_n)                        (((uint8_t)(_n) & 0xf) << 0)
#define DMA_CERR_CERR_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_CERR_CAEI                            ((uint8_t)1 << 6)      // Clear All Error Indicators
#define DMA_CERR_NOP                             ((uint8_t)1 << 7)      // No Op enable
#define   DMA_CERR_NOP_0                         (uint8_t)0x0           // Normal operation
#define   DMA_CERR_NOP_1                         (uint8_t)0x1           // No operation, ignore the other bits in this register

    uint8_t              CINT;                                          // Clear Interrupt Request Register
                                                                        // Clear Interrupt Request
#define DMA_CINT_CINT(_n)                        (((uint8_t)(_n) & 0xf) << 0)
#define DMA_CINT_CINT_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_CINT_CAIR                            ((uint8_t)1 << 6)      // Clear All Interrupt Requests
#define DMA_CINT_NOP                             ((uint8_t)1 << 7)      // No Op enable
#define   DMA_CINT_NOP_0                         (uint8_t)0x0           // Normal operation
#define   DMA_CINT_NOP_1                         (uint8_t)0x1           // No operation, ignore the other bits in this register

    uint8_t _res2[4];
    uint32_t             INT;                                           // Interrupt Request Register
#define DMA_INT_INT0                             ((uint32_t)1 << 0)     // Interrupt Request 0
#define   DMA_INT_INT0_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT0_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT1                             ((uint32_t)1 << 1)     // Interrupt Request 1
#define   DMA_INT_INT1_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT1_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT2                             ((uint32_t)1 << 2)     // Interrupt Request 2
#define   DMA_INT_INT2_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT2_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT3                             ((uint32_t)1 << 3)     // Interrupt Request 3
#define   DMA_INT_INT3_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT3_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT4                             ((uint32_t)1 << 4)     // Interrupt Request 4
#define   DMA_INT_INT4_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT4_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT5                             ((uint32_t)1 << 5)     // Interrupt Request 5
#define   DMA_INT_INT5_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT5_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT6                             ((uint32_t)1 << 6)     // Interrupt Request 6
#define   DMA_INT_INT6_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT6_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT7                             ((uint32_t)1 << 7)     // Interrupt Request 7
#define   DMA_INT_INT7_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT7_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT8                             ((uint32_t)1 << 8)     // Interrupt Request 8
#define   DMA_INT_INT8_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT8_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT9                             ((uint32_t)1 << 9)     // Interrupt Request 9
#define   DMA_INT_INT9_0                         (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT9_1                         (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT10                            ((uint32_t)1 << 10)    // Interrupt Request 10
#define   DMA_INT_INT10_0                        (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT10_1                        (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT11                            ((uint32_t)1 << 11)    // Interrupt Request 11
#define   DMA_INT_INT11_0                        (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT11_1                        (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT12                            ((uint32_t)1 << 12)    // Interrupt Request 12
#define   DMA_INT_INT12_0                        (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT12_1                        (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT13                            ((uint32_t)1 << 13)    // Interrupt Request 13
#define   DMA_INT_INT13_0                        (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT13_1                        (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT14                            ((uint32_t)1 << 14)    // Interrupt Request 14
#define   DMA_INT_INT14_0                        (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT14_1                        (uint32_t)0x1          // The interrupt request for corresponding channel is active
#define DMA_INT_INT15                            ((uint32_t)1 << 15)    // Interrupt Request 15
#define   DMA_INT_INT15_0                        (uint32_t)0x0          // The interrupt request for corresponding channel is cleared
#define   DMA_INT_INT15_1                        (uint32_t)0x1          // The interrupt request for corresponding channel is active

    uint8_t _res3[4];
    uint32_t             ERR;                                           // Error Register
#define DMA_ERR_ERR0                             ((uint32_t)1 << 0)     // Error In Channel 0
#define   DMA_ERR_ERR0_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR0_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR1                             ((uint32_t)1 << 1)     // Error In Channel 1
#define   DMA_ERR_ERR1_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR1_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR2                             ((uint32_t)1 << 2)     // Error In Channel 2
#define   DMA_ERR_ERR2_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR2_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR3                             ((uint32_t)1 << 3)     // Error In Channel 3
#define   DMA_ERR_ERR3_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR3_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR4                             ((uint32_t)1 << 4)     // Error In Channel 4
#define   DMA_ERR_ERR4_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR4_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR5                             ((uint32_t)1 << 5)     // Error In Channel 5
#define   DMA_ERR_ERR5_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR5_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR6                             ((uint32_t)1 << 6)     // Error In Channel 6
#define   DMA_ERR_ERR6_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR6_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR7                             ((uint32_t)1 << 7)     // Error In Channel 7
#define   DMA_ERR_ERR7_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR7_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR8                             ((uint32_t)1 << 8)     // Error In Channel 8
#define   DMA_ERR_ERR8_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR8_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR9                             ((uint32_t)1 << 9)     // Error In Channel 9
#define   DMA_ERR_ERR9_0                         (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR9_1                         (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR10                            ((uint32_t)1 << 10)    // Error In Channel 10
#define   DMA_ERR_ERR10_0                        (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR10_1                        (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR11                            ((uint32_t)1 << 11)    // Error In Channel 11
#define   DMA_ERR_ERR11_0                        (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR11_1                        (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR12                            ((uint32_t)1 << 12)    // Error In Channel 12
#define   DMA_ERR_ERR12_0                        (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR12_1                        (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR13                            ((uint32_t)1 << 13)    // Error In Channel 13
#define   DMA_ERR_ERR13_0                        (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR13_1                        (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR14                            ((uint32_t)1 << 14)    // Error In Channel 14
#define   DMA_ERR_ERR14_0                        (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR14_1                        (uint32_t)0x1          // An error in this channel has occurred
#define DMA_ERR_ERR15                            ((uint32_t)1 << 15)    // Error In Channel 15
#define   DMA_ERR_ERR15_0                        (uint32_t)0x0          // An error in this channel has not occurred
#define   DMA_ERR_ERR15_1                        (uint32_t)0x1          // An error in this channel has occurred

    uint8_t _res4[4];
    const uint32_t       HRS;                                           // Hardware Request Status Register
#define DMA_HRS_HRS0                             ((uint32_t)1 << 0)     // Hardware Request Status Channel 0
#define   DMA_HRS_HRS0_0                         (uint32_t)0x0          // A hardware service request for channel 0 is not present
#define   DMA_HRS_HRS0_1                         (uint32_t)0x1          // A hardware service request for channel 0 is present
#define DMA_HRS_HRS1                             ((uint32_t)1 << 1)     // Hardware Request Status Channel 1
#define   DMA_HRS_HRS1_0                         (uint32_t)0x0          // A hardware service request for channel 1 is not present
#define   DMA_HRS_HRS1_1                         (uint32_t)0x1          // A hardware service request for channel 1 is present
#define DMA_HRS_HRS2                             ((uint32_t)1 << 2)     // Hardware Request Status Channel 2
#define   DMA_HRS_HRS2_0                         (uint32_t)0x0          // A hardware service request for channel 2 is not present
#define   DMA_HRS_HRS2_1                         (uint32_t)0x1          // A hardware service request for channel 2 is present
#define DMA_HRS_HRS3                             ((uint32_t)1 << 3)     // Hardware Request Status Channel 3
#define   DMA_HRS_HRS3_0                         (uint32_t)0x0          // A hardware service request for channel 3 is not present
#define   DMA_HRS_HRS3_1                         (uint32_t)0x1          // A hardware service request for channel 3 is present
#define DMA_HRS_HRS4                             ((uint32_t)1 << 4)     // Hardware Request Status Channel 4
#define   DMA_HRS_HRS4_0                         (uint32_t)0x0          // A hardware service request for channel 4 is not present
#define   DMA_HRS_HRS4_1                         (uint32_t)0x1          // A hardware service request for channel 4 is present
#define DMA_HRS_HRS5                             ((uint32_t)1 << 5)     // Hardware Request Status Channel 5
#define   DMA_HRS_HRS5_0                         (uint32_t)0x0          // A hardware service request for channel 5 is not present
#define   DMA_HRS_HRS5_1                         (uint32_t)0x1          // A hardware service request for channel 5 is present
#define DMA_HRS_HRS6                             ((uint32_t)1 << 6)     // Hardware Request Status Channel 6
#define   DMA_HRS_HRS6_0                         (uint32_t)0x0          // A hardware service request for channel 6 is not present
#define   DMA_HRS_HRS6_1                         (uint32_t)0x1          // A hardware service request for channel 6 is present
#define DMA_HRS_HRS7                             ((uint32_t)1 << 7)     // Hardware Request Status Channel 7
#define   DMA_HRS_HRS7_0                         (uint32_t)0x0          // A hardware service request for channel 7 is not present
#define   DMA_HRS_HRS7_1                         (uint32_t)0x1          // A hardware service request for channel 7 is present
#define DMA_HRS_HRS8                             ((uint32_t)1 << 8)     // Hardware Request Status Channel 8
#define   DMA_HRS_HRS8_0                         (uint32_t)0x0          // A hardware service request for channel 8 is not present
#define   DMA_HRS_HRS8_1                         (uint32_t)0x1          // A hardware service request for channel 8 is present
#define DMA_HRS_HRS9                             ((uint32_t)1 << 9)     // Hardware Request Status Channel 9
#define   DMA_HRS_HRS9_0                         (uint32_t)0x0          // A hardware service request for channel 9 is not present
#define   DMA_HRS_HRS9_1                         (uint32_t)0x1          // A hardware service request for channel 9 is present
#define DMA_HRS_HRS10                            ((uint32_t)1 << 10)    // Hardware Request Status Channel 10
#define   DMA_HRS_HRS10_0                        (uint32_t)0x0          // A hardware service request for channel 10 is not present
#define   DMA_HRS_HRS10_1                        (uint32_t)0x1          // A hardware service request for channel 10 is present
#define DMA_HRS_HRS11                            ((uint32_t)1 << 11)    // Hardware Request Status Channel 11
#define   DMA_HRS_HRS11_0                        (uint32_t)0x0          // A hardware service request for channel 11 is not present
#define   DMA_HRS_HRS11_1                        (uint32_t)0x1          // A hardware service request for channel 11 is present
#define DMA_HRS_HRS12                            ((uint32_t)1 << 12)    // Hardware Request Status Channel 12
#define   DMA_HRS_HRS12_0                        (uint32_t)0x0          // A hardware service request for channel 12 is not present
#define   DMA_HRS_HRS12_1                        (uint32_t)0x1          // A hardware service request for channel 12 is present
#define DMA_HRS_HRS13                            ((uint32_t)1 << 13)    // Hardware Request Status Channel 13
#define   DMA_HRS_HRS13_0                        (uint32_t)0x0          // A hardware service request for channel 13 is not present
#define   DMA_HRS_HRS13_1                        (uint32_t)0x1          // A hardware service request for channel 13 is present
#define DMA_HRS_HRS14                            ((uint32_t)1 << 14)    // Hardware Request Status Channel 14
#define   DMA_HRS_HRS14_0                        (uint32_t)0x0          // A hardware service request for channel 14 is not present
#define   DMA_HRS_HRS14_1                        (uint32_t)0x1          // A hardware service request for channel 14 is present
#define DMA_HRS_HRS15                            ((uint32_t)1 << 15)    // Hardware Request Status Channel 15
#define   DMA_HRS_HRS15_0                        (uint32_t)0x0          // A hardware service request for channel 15 is not present
#define   DMA_HRS_HRS15_1                        (uint32_t)0x1          // A hardware service request for channel 15 is present

    uint8_t _res5[12];
    uint32_t             EARS;                                          // Enable Asynchronous Request in Stop Register
#define DMA_EARS_EDREQ_0                         ((uint32_t)1 << 0)     // Enable asynchronous DMA request in stop mode for channel 0.
#define   DMA_EARS_EDREQ_0_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 0.
#define   DMA_EARS_EDREQ_0_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 0.
#define DMA_EARS_EDREQ_1                         ((uint32_t)1 << 1)     // Enable asynchronous DMA request in stop mode for channel 1.
#define   DMA_EARS_EDREQ_1_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 1
#define   DMA_EARS_EDREQ_1_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 1.
#define DMA_EARS_EDREQ_2                         ((uint32_t)1 << 2)     // Enable asynchronous DMA request in stop mode for channel 2.
#define   DMA_EARS_EDREQ_2_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 2.
#define   DMA_EARS_EDREQ_2_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 2.
#define DMA_EARS_EDREQ_3                         ((uint32_t)1 << 3)     // Enable asynchronous DMA request in stop mode for channel 3.
#define   DMA_EARS_EDREQ_3_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 3.
#define   DMA_EARS_EDREQ_3_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 3.
#define DMA_EARS_EDREQ_4                         ((uint32_t)1 << 4)     // Enable asynchronous DMA request in stop mode for channel 4
#define   DMA_EARS_EDREQ_4_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 4.
#define   DMA_EARS_EDREQ_4_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 4.
#define DMA_EARS_EDREQ_5                         ((uint32_t)1 << 5)     // Enable asynchronous DMA request in stop mode for channel 5
#define   DMA_EARS_EDREQ_5_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 5.
#define   DMA_EARS_EDREQ_5_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 5.
#define DMA_EARS_EDREQ_6                         ((uint32_t)1 << 6)     // Enable asynchronous DMA request in stop mode for channel 6
#define   DMA_EARS_EDREQ_6_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 6.
#define   DMA_EARS_EDREQ_6_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 6.
#define DMA_EARS_EDREQ_7                         ((uint32_t)1 << 7)     // Enable asynchronous DMA request in stop mode for channel 7
#define   DMA_EARS_EDREQ_7_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 7.
#define   DMA_EARS_EDREQ_7_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 7.
#define DMA_EARS_EDREQ_8                         ((uint32_t)1 << 8)     // Enable asynchronous DMA request in stop mode for channel 8
#define   DMA_EARS_EDREQ_8_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 8.
#define   DMA_EARS_EDREQ_8_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 8.
#define DMA_EARS_EDREQ_9                         ((uint32_t)1 << 9)     // Enable asynchronous DMA request in stop mode for channel 9
#define   DMA_EARS_EDREQ_9_0                     (uint32_t)0x0          // Disable asynchronous DMA request for channel 9.
#define   DMA_EARS_EDREQ_9_1                     (uint32_t)0x1          // Enable asynchronous DMA request for channel 9.
#define DMA_EARS_EDREQ_10                        ((uint32_t)1 << 10)    // Enable asynchronous DMA request in stop mode for channel 10
#define   DMA_EARS_EDREQ_10_0                    (uint32_t)0x0          // Disable asynchronous DMA request for channel 10.
#define   DMA_EARS_EDREQ_10_1                    (uint32_t)0x1          // Enable asynchronous DMA request for channel 10.
#define DMA_EARS_EDREQ_11                        ((uint32_t)1 << 11)    // Enable asynchronous DMA request in stop mode for channel 11
#define   DMA_EARS_EDREQ_11_0                    (uint32_t)0x0          // Disable asynchronous DMA request for channel 11.
#define   DMA_EARS_EDREQ_11_1                    (uint32_t)0x1          // Enable asynchronous DMA request for channel 11.
#define DMA_EARS_EDREQ_12                        ((uint32_t)1 << 12)    // Enable asynchronous DMA request in stop mode for channel 12
#define   DMA_EARS_EDREQ_12_0                    (uint32_t)0x0          // Disable asynchronous DMA request for channel 12.
#define   DMA_EARS_EDREQ_12_1                    (uint32_t)0x1          // Enable asynchronous DMA request for channel 12.
#define DMA_EARS_EDREQ_13                        ((uint32_t)1 << 13)    // Enable asynchronous DMA request in stop mode for channel 13
#define   DMA_EARS_EDREQ_13_0                    (uint32_t)0x0          // Disable asynchronous DMA request for channel 13.
#define   DMA_EARS_EDREQ_13_1                    (uint32_t)0x1          // Enable asynchronous DMA request for channel 13.
#define DMA_EARS_EDREQ_14                        ((uint32_t)1 << 14)    // Enable asynchronous DMA request in stop mode for channel 14
#define   DMA_EARS_EDREQ_14_0                    (uint32_t)0x0          // Disable asynchronous DMA request for channel 14.
#define   DMA_EARS_EDREQ_14_1                    (uint32_t)0x1          // Enable asynchronous DMA request for channel 14.
#define DMA_EARS_EDREQ_15                        ((uint32_t)1 << 15)    // Enable asynchronous DMA request in stop mode for channel 15
#define   DMA_EARS_EDREQ_15_0                    (uint32_t)0x0          // Disable asynchronous DMA request for channel 15.
#define   DMA_EARS_EDREQ_15_1                    (uint32_t)0x1          // Enable asynchronous DMA request for channel 15.

    uint8_t _res6[184];
    uint8_t              DCHPRI3;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI3_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI3_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI3_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI3_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI3_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI3_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI3_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI3_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI3_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI2;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI2_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI2_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI2_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI2_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI2_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI2_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI2_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI2_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI2_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI1;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI1_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI1_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI1_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI1_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI1_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI1_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI1_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI1_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI1_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI0;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI0_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI0_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI0_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI0_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI0_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI0_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI0_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI0_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI0_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI7;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI7_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI7_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI7_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI7_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI7_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI7_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI7_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI7_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI7_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI6;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI6_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI6_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI6_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI6_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI6_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI6_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI6_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI6_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI6_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI5;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI5_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI5_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI5_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI5_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI5_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI5_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI5_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI5_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI5_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI4;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI4_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI4_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI4_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI4_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI4_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI4_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI4_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI4_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI4_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI11;                                      // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI11_CHPRI(_n)                   (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI11_CHPRI_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI11_CHPRI_EXTRACT(_v)               (((_v) >> 0) & 0xf)
#define DMA_DCHPRI11_DPA                         ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI11_DPA_0                     (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI11_DPA_1                     (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI11_ECP                         ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI11_ECP_0                     (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI11_ECP_1                     (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI10;                                      // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI10_CHPRI(_n)                   (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI10_CHPRI_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI10_CHPRI_EXTRACT(_v)               (((_v) >> 0) & 0xf)
#define DMA_DCHPRI10_DPA                         ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI10_DPA_0                     (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI10_DPA_1                     (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI10_ECP                         ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI10_ECP_0                     (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI10_ECP_1                     (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI9;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI9_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI9_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI9_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI9_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI9_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI9_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI9_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI9_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI9_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI8;                                       // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI8_CHPRI(_n)                    (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI8_CHPRI_INSERT(_v, _n)             (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI8_CHPRI_EXTRACT(_v)                (((_v) >> 0) & 0xf)
#define DMA_DCHPRI8_DPA                          ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI8_DPA_0                      (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI8_DPA_1                      (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI8_ECP                          ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI8_ECP_0                      (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI8_ECP_1                      (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI15;                                      // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI15_CHPRI(_n)                   (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI15_CHPRI_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI15_CHPRI_EXTRACT(_v)               (((_v) >> 0) & 0xf)
#define DMA_DCHPRI15_DPA                         ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI15_DPA_0                     (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI15_DPA_1                     (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI15_ECP                         ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI15_ECP_0                     (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI15_ECP_1                     (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI14;                                      // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI14_CHPRI(_n)                   (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI14_CHPRI_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI14_CHPRI_EXTRACT(_v)               (((_v) >> 0) & 0xf)
#define DMA_DCHPRI14_DPA                         ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI14_DPA_0                     (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI14_DPA_1                     (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI14_ECP                         ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI14_ECP_0                     (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI14_ECP_1                     (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI13;                                      // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI13_CHPRI(_n)                   (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI13_CHPRI_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI13_CHPRI_EXTRACT(_v)               (((_v) >> 0) & 0xf)
#define DMA_DCHPRI13_DPA                         ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI13_DPA_0                     (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI13_DPA_1                     (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI13_ECP                         ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI13_ECP_0                     (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI13_ECP_1                     (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t              DCHPRI12;                                      // Channel n Priority Register
                                                                        // Channel n Arbitration Priority
#define DMA_DCHPRI12_CHPRI(_n)                   (((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI12_CHPRI_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint8_t)(_n) & 0xf) << 0)
#define DMA_DCHPRI12_CHPRI_EXTRACT(_v)               (((_v) >> 0) & 0xf)
#define DMA_DCHPRI12_DPA                         ((uint8_t)1 << 6)      // Disable Preempt Ability. This field resets to 0.
#define   DMA_DCHPRI12_DPA_0                     (uint8_t)0x0           // Channel n can suspend a lower priority channel.
#define   DMA_DCHPRI12_DPA_1                     (uint8_t)0x1           // Channel n cannot suspend any channel, regardless of channel priority.
#define DMA_DCHPRI12_ECP                         ((uint8_t)1 << 7)      // Enable Channel Preemption. This field resets to 0.
#define   DMA_DCHPRI12_ECP_0                     (uint8_t)0x0           // Channel n cannot be suspended by a higher priority channel's service request.
#define   DMA_DCHPRI12_ECP_1                     (uint8_t)0x1           // Channel n can be temporarily suspended by the service request of a higher priority channel.

    uint8_t _res7[3824];
    uint32_t             TCD0_SADDR;                                    // TCD Source Address
    uint16_t             TCD0_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD0_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD0_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD0_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD0_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD0_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD0_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD0_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD0_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD0_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD0_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD0_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD0_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD0_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD0_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD0_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD0_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD0_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD0_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD0_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD0_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD0_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD0_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD0_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD0_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD0_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD0_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD0_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD0_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD0_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD0_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD0_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD0_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD0_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD0_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD0_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD0_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD0_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD0_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD0_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD0_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD0_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD0_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD0_DADDR;                                    // TCD Destination Address
    uint16_t             TCD0_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD0_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD0_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD0_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD0_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD0_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD0_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD0_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD0_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD0_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD0_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD0_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD0_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD0_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD0_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD0_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD0_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD0_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD0_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD0_CSR;                                      // TCD Control and Status
#define DMA_TCD0_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD0_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD0_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD0_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD0_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD0_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD0_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD0_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD0_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD0_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD0_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD0_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD0_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD0_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD0_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD0_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD0_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD0_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD0_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD0_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD0_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD0_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD0_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD0_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD0_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD0_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD0_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD0_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD0_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD0_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD0_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD0_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD0_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD0_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD0_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD0_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD0_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD0_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD0_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD0_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD0_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD0_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD0_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD0_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD1_SADDR;                                    // TCD Source Address
    uint16_t             TCD1_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD1_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD1_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD1_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD1_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD1_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD1_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD1_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD1_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD1_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD1_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD1_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD1_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD1_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD1_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD1_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD1_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD1_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD1_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD1_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD1_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD1_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD1_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD1_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD1_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD1_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD1_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD1_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD1_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD1_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD1_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD1_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD1_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD1_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD1_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD1_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD1_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD1_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD1_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD1_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD1_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD1_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD1_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD1_DADDR;                                    // TCD Destination Address
    uint16_t             TCD1_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD1_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD1_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD1_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD1_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD1_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD1_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD1_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD1_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD1_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD1_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD1_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD1_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD1_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD1_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD1_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD1_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD1_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD1_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD1_CSR;                                      // TCD Control and Status
#define DMA_TCD1_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD1_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD1_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD1_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD1_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD1_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD1_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD1_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD1_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD1_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD1_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD1_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD1_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD1_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD1_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD1_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD1_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD1_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD1_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD1_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD1_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD1_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD1_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD1_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD1_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD1_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD1_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD1_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD1_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD1_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD1_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD1_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD1_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD1_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD1_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD1_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD1_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD1_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD1_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD1_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD1_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD1_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD1_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD1_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD2_SADDR;                                    // TCD Source Address
    uint16_t             TCD2_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD2_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD2_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD2_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD2_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD2_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD2_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD2_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD2_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD2_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD2_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD2_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD2_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD2_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD2_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD2_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD2_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD2_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD2_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD2_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD2_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD2_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD2_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD2_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD2_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD2_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD2_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD2_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD2_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD2_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD2_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD2_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD2_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD2_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD2_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD2_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD2_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD2_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD2_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD2_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD2_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD2_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD2_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD2_DADDR;                                    // TCD Destination Address
    uint16_t             TCD2_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD2_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD2_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD2_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD2_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD2_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD2_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD2_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD2_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD2_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD2_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD2_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD2_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD2_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD2_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD2_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD2_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD2_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD2_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD2_CSR;                                      // TCD Control and Status
#define DMA_TCD2_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD2_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD2_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD2_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD2_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD2_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD2_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD2_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD2_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD2_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD2_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD2_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD2_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD2_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD2_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD2_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD2_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD2_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD2_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD2_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD2_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD2_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD2_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD2_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD2_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD2_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD2_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD2_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD2_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD2_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD2_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD2_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD2_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD2_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD2_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD2_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD2_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD2_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD2_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD2_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD2_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD2_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD2_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD2_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD3_SADDR;                                    // TCD Source Address
    uint16_t             TCD3_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD3_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD3_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD3_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD3_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD3_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD3_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD3_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD3_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD3_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD3_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD3_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD3_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD3_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD3_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD3_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD3_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD3_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD3_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD3_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD3_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD3_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD3_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD3_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD3_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD3_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD3_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD3_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD3_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD3_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD3_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD3_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD3_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD3_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD3_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD3_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD3_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD3_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD3_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD3_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD3_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD3_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD3_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD3_DADDR;                                    // TCD Destination Address
    uint16_t             TCD3_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD3_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD3_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD3_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD3_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD3_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD3_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD3_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD3_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD3_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD3_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD3_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD3_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD3_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD3_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD3_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD3_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD3_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD3_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD3_CSR;                                      // TCD Control and Status
#define DMA_TCD3_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD3_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD3_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD3_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD3_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD3_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD3_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD3_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD3_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD3_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD3_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD3_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD3_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD3_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD3_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD3_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD3_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD3_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD3_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD3_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD3_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD3_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD3_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD3_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD3_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD3_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD3_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD3_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD3_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD3_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD3_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD3_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD3_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD3_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD3_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD3_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD3_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD3_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD3_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD3_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD3_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD3_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD3_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD3_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD4_SADDR;                                    // TCD Source Address
    uint16_t             TCD4_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD4_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD4_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD4_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD4_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD4_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD4_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD4_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD4_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD4_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD4_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD4_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD4_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD4_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD4_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD4_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD4_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD4_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD4_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD4_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD4_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD4_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD4_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD4_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD4_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD4_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD4_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD4_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD4_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD4_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD4_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD4_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD4_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD4_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD4_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD4_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD4_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD4_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD4_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD4_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD4_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD4_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD4_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD4_DADDR;                                    // TCD Destination Address
    uint16_t             TCD4_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD4_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD4_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD4_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD4_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD4_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD4_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD4_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD4_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD4_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD4_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD4_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD4_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD4_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD4_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD4_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD4_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD4_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD4_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD4_CSR;                                      // TCD Control and Status
#define DMA_TCD4_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD4_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD4_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD4_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD4_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD4_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD4_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD4_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD4_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD4_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD4_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD4_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD4_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD4_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD4_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD4_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD4_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD4_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD4_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD4_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD4_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD4_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD4_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD4_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD4_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD4_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD4_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD4_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD4_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD4_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD4_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD4_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD4_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD4_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD4_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD4_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD4_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD4_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD4_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD4_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD4_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD4_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD4_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD4_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD5_SADDR;                                    // TCD Source Address
    uint16_t             TCD5_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD5_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD5_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD5_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD5_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD5_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD5_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD5_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD5_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD5_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD5_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD5_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD5_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD5_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD5_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD5_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD5_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD5_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD5_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD5_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD5_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD5_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD5_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD5_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD5_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD5_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD5_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD5_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD5_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD5_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD5_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD5_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD5_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD5_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD5_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD5_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD5_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD5_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD5_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD5_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD5_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD5_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD5_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD5_DADDR;                                    // TCD Destination Address
    uint16_t             TCD5_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD5_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD5_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD5_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD5_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD5_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD5_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD5_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD5_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD5_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD5_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD5_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD5_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD5_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD5_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD5_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD5_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD5_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD5_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD5_CSR;                                      // TCD Control and Status
#define DMA_TCD5_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD5_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD5_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD5_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD5_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD5_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD5_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD5_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD5_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD5_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD5_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD5_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD5_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD5_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD5_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD5_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD5_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD5_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD5_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD5_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD5_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD5_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD5_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD5_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD5_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD5_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD5_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD5_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD5_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD5_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD5_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD5_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD5_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD5_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD5_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD5_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD5_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD5_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD5_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD5_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD5_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD5_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD5_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD5_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD6_SADDR;                                    // TCD Source Address
    uint16_t             TCD6_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD6_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD6_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD6_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD6_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD6_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD6_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD6_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD6_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD6_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD6_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD6_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD6_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD6_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD6_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD6_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD6_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD6_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD6_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD6_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD6_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD6_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD6_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD6_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD6_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD6_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD6_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD6_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD6_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD6_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD6_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD6_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD6_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD6_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD6_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD6_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD6_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD6_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD6_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD6_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD6_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD6_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD6_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD6_DADDR;                                    // TCD Destination Address
    uint16_t             TCD6_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD6_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD6_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD6_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD6_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD6_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD6_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD6_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD6_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD6_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD6_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD6_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD6_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD6_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD6_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD6_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD6_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD6_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD6_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD6_CSR;                                      // TCD Control and Status
#define DMA_TCD6_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD6_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD6_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD6_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD6_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD6_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD6_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD6_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD6_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD6_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD6_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD6_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD6_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD6_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD6_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD6_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD6_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD6_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD6_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD6_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD6_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD6_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD6_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD6_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD6_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD6_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD6_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD6_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD6_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD6_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD6_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD6_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD6_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD6_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD6_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD6_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD6_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD6_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD6_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD6_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD6_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD6_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD6_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD6_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD7_SADDR;                                    // TCD Source Address
    uint16_t             TCD7_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD7_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD7_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD7_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD7_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD7_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD7_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD7_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD7_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD7_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD7_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD7_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD7_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD7_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD7_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD7_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD7_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD7_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD7_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD7_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD7_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD7_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD7_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD7_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD7_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD7_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD7_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD7_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD7_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD7_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD7_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD7_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD7_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD7_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD7_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD7_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD7_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD7_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD7_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD7_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD7_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD7_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD7_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD7_DADDR;                                    // TCD Destination Address
    uint16_t             TCD7_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD7_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD7_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD7_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD7_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD7_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD7_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD7_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD7_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD7_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD7_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD7_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD7_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD7_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD7_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD7_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD7_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD7_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD7_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD7_CSR;                                      // TCD Control and Status
#define DMA_TCD7_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD7_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD7_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD7_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD7_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD7_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD7_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD7_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD7_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD7_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD7_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD7_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD7_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD7_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD7_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD7_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD7_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD7_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD7_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD7_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD7_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD7_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD7_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD7_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD7_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD7_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD7_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD7_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD7_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD7_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD7_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD7_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD7_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD7_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD7_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD7_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD7_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD7_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD7_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD7_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD7_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD7_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD7_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD7_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD8_SADDR;                                    // TCD Source Address
    uint16_t             TCD8_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD8_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD8_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD8_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD8_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD8_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD8_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD8_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD8_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD8_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD8_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD8_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD8_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD8_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD8_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD8_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD8_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD8_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD8_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD8_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD8_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD8_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD8_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD8_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD8_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD8_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD8_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD8_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD8_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD8_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD8_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD8_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD8_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD8_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD8_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD8_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD8_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD8_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD8_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD8_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD8_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD8_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD8_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD8_DADDR;                                    // TCD Destination Address
    uint16_t             TCD8_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD8_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD8_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD8_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD8_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD8_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD8_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD8_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD8_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD8_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD8_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD8_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD8_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD8_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD8_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD8_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD8_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD8_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD8_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD8_CSR;                                      // TCD Control and Status
#define DMA_TCD8_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD8_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD8_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD8_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD8_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD8_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD8_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD8_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD8_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD8_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD8_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD8_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD8_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD8_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD8_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD8_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD8_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD8_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD8_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD8_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD8_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD8_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD8_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD8_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD8_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD8_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD8_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD8_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD8_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD8_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD8_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD8_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD8_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD8_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD8_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD8_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD8_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD8_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD8_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD8_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD8_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD8_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD8_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD8_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD9_SADDR;                                    // TCD Source Address
    uint16_t             TCD9_SOFF;                                     // TCD Signed Source Address Offset
    uint16_t             TCD9_ATTR;                                     // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD9_ATTR_DSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD9_ATTR_DSIZE_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD9_ATTR_DSIZE_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD9_ATTR_DMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD9_ATTR_DMOD_INSERT(_v, _n)            (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD9_ATTR_DMOD_EXTRACT(_v)               (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD9_ATTR_SSIZE(_n)                  (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD9_ATTR_SSIZE_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD9_ATTR_SSIZE_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   DMA_TCD9_ATTR_SSIZE_0                  (uint16_t)0x0          // 8-bit
#define   DMA_TCD9_ATTR_SSIZE_1                  (uint16_t)0x1          // 16-bit
#define   DMA_TCD9_ATTR_SSIZE_10                 (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD9_ATTR_SMOD(_n)                   (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD9_ATTR_SMOD_INSERT(_v, _n)            (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD9_ATTR_SMOD_EXTRACT(_v)               (((_v) >> 11) & 0x1f)
#define   DMA_TCD9_ATTR_SMOD_0                   (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD9_NBYTES_MLNO;                              // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD9_NBYTES_MLOFFNO;                           // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD9_NBYTES_MLOFFNO_NBYTES(_n)       (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD9_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD9_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)   (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD9_NBYTES_MLOFFNO_DMLOE            ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD9_NBYTES_MLOFFNO_DMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD9_NBYTES_MLOFFNO_DMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD9_NBYTES_MLOFFNO_SMLOE            ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD9_NBYTES_MLOFFNO_SMLOE_0        (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD9_NBYTES_MLOFFNO_SMLOE_1        (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD9_NBYTES_MLOFFYES;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD9_NBYTES_MLOFFYES_NBYTES(_n)      (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD9_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD9_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD9_NBYTES_MLOFFYES_MLOFF(_n)       (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD9_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD9_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)   (((_v) >> 10) & 0xfffff)
#define DMA_TCD9_NBYTES_MLOFFYES_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD9_NBYTES_MLOFFYES_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD9_NBYTES_MLOFFYES_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD9_NBYTES_MLOFFYES_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD9_NBYTES_MLOFFYES_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD9_NBYTES_MLOFFYES_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD9_SLAST;                                    // TCD Last Source Address Adjustment
    uint32_t             TCD9_DADDR;                                    // TCD Destination Address
    uint16_t             TCD9_DOFF;                                     // TCD Signed Destination Address Offset
    uint16_t             TCD9_CITER_ELINKNO;                            // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD9_CITER_ELINKNO_CITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD9_CITER_ELINKNO_CITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD9_CITER_ELINKNO_CITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD9_CITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD9_CITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD9_CITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD9_CITER_ELINKYES;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD9_CITER_ELINKYES_CITER_LE(_n)     (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD9_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD9_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD9_CITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD9_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD9_CITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD9_CITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD9_CITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD9_CITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD9_DLASTSGA;                                 // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD9_CSR;                                      // TCD Control and Status
#define DMA_TCD9_CSR_START                       ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD9_CSR_START_0                   (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD9_CSR_START_1                   (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD9_CSR_INTMAJOR                    ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD9_CSR_INTMAJOR_0                (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD9_CSR_INTMAJOR_1                (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD9_CSR_INTHALF                     ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD9_CSR_INTHALF_0                 (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD9_CSR_INTHALF_1                 (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD9_CSR_DREQ                        ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD9_CSR_ESG                         ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD9_CSR_ESG_0                     (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD9_CSR_ESG_1                     (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD9_CSR_MAJORELINK                  ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD9_CSR_MAJORELINK_0              (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD9_CSR_MAJORELINK_1              (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD9_CSR_ACTIVE                      ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD9_CSR_DONE                        ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD9_CSR_MAJORLINKCH(_n)             (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD9_CSR_MAJORLINKCH_INSERT(_v, _n)      (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD9_CSR_MAJORLINKCH_EXTRACT(_v)         (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD9_CSR_BWC(_n)                     (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD9_CSR_BWC_INSERT(_v, _n)              (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD9_CSR_BWC_EXTRACT(_v)                 (((_v) >> 14) & 0x3)
#define   DMA_TCD9_CSR_BWC_0                     (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD9_CSR_BWC_10                    (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD9_CSR_BWC_11                    (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD9_BITER_ELINKNO;                            // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD9_BITER_ELINKNO_BITER(_n)         (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD9_BITER_ELINKNO_BITER_INSERT(_v, _n)  (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD9_BITER_ELINKNO_BITER_EXTRACT(_v)     (((_v) >> 0) & 0x7fff)
#define DMA_TCD9_BITER_ELINKNO_ELINK             ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD9_BITER_ELINKNO_ELINK_0         (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD9_BITER_ELINKNO_ELINK_1         (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD9_BITER_ELINKYES;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD9_BITER_ELINKYES_BITER(_n)        (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD9_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD9_BITER_ELINKYES_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD9_BITER_ELINKYES_LINKCH(_n)       (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD9_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD9_BITER_ELINKYES_LINKCH_EXTRACT(_v)   (((_v) >> 9) & 0xf)
#define DMA_TCD9_BITER_ELINKYES_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD9_BITER_ELINKYES_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD9_BITER_ELINKYES_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD10_SADDR;                                   // TCD Source Address
    uint16_t             TCD10_SOFF;                                    // TCD Signed Source Address Offset
    uint16_t             TCD10_ATTR;                                    // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD10_ATTR_DSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD10_ATTR_DSIZE_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD10_ATTR_DSIZE_EXTRACT(_v)             (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD10_ATTR_DMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD10_ATTR_DMOD_INSERT(_v, _n)           (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD10_ATTR_DMOD_EXTRACT(_v)              (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD10_ATTR_SSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD10_ATTR_SSIZE_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD10_ATTR_SSIZE_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   DMA_TCD10_ATTR_SSIZE_0                 (uint16_t)0x0          // 8-bit
#define   DMA_TCD10_ATTR_SSIZE_1                 (uint16_t)0x1          // 16-bit
#define   DMA_TCD10_ATTR_SSIZE_10                (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD10_ATTR_SMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD10_ATTR_SMOD_INSERT(_v, _n)           (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD10_ATTR_SMOD_EXTRACT(_v)              (((_v) >> 11) & 0x1f)
#define   DMA_TCD10_ATTR_SMOD_0                  (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD10_NBYTES_MLNO;                             // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD10_NBYTES_MLOFFNO;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD10_NBYTES_MLOFFNO_NBYTES(_n)      (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD10_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD10_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD10_NBYTES_MLOFFNO_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD10_NBYTES_MLOFFNO_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD10_NBYTES_MLOFFNO_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD10_NBYTES_MLOFFNO_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD10_NBYTES_MLOFFNO_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD10_NBYTES_MLOFFNO_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD10_NBYTES_MLOFFYES;                         // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD10_NBYTES_MLOFFYES_NBYTES(_n)     (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD10_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD10_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v) (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD10_NBYTES_MLOFFYES_MLOFF(_n)      (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD10_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD10_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)  (((_v) >> 10) & 0xfffff)
#define DMA_TCD10_NBYTES_MLOFFYES_DMLOE          ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD10_NBYTES_MLOFFYES_DMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD10_NBYTES_MLOFFYES_DMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD10_NBYTES_MLOFFYES_SMLOE          ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD10_NBYTES_MLOFFYES_SMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD10_NBYTES_MLOFFYES_SMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD10_SLAST;                                   // TCD Last Source Address Adjustment
    uint32_t             TCD10_DADDR;                                   // TCD Destination Address
    uint16_t             TCD10_DOFF;                                    // TCD Signed Destination Address Offset
    uint16_t             TCD10_CITER_ELINKNO;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD10_CITER_ELINKNO_CITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD10_CITER_ELINKNO_CITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD10_CITER_ELINKNO_CITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD10_CITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD10_CITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD10_CITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD10_CITER_ELINKYES;                          // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD10_CITER_ELINKYES_CITER_LE(_n)    (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD10_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD10_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD10_CITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD10_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD10_CITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD10_CITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD10_CITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD10_CITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD10_DLASTSGA;                                // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD10_CSR;                                     // TCD Control and Status
#define DMA_TCD10_CSR_START                      ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD10_CSR_START_0                  (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD10_CSR_START_1                  (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD10_CSR_INTMAJOR                   ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD10_CSR_INTMAJOR_0               (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD10_CSR_INTMAJOR_1               (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD10_CSR_INTHALF                    ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD10_CSR_INTHALF_0                (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD10_CSR_INTHALF_1                (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD10_CSR_DREQ                       ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD10_CSR_ESG                        ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD10_CSR_ESG_0                    (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD10_CSR_ESG_1                    (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD10_CSR_MAJORELINK                 ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD10_CSR_MAJORELINK_0             (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD10_CSR_MAJORELINK_1             (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD10_CSR_ACTIVE                     ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD10_CSR_DONE                       ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD10_CSR_MAJORLINKCH(_n)            (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD10_CSR_MAJORLINKCH_INSERT(_v, _n)     (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD10_CSR_MAJORLINKCH_EXTRACT(_v)        (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD10_CSR_BWC(_n)                    (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD10_CSR_BWC_INSERT(_v, _n)             (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD10_CSR_BWC_EXTRACT(_v)                (((_v) >> 14) & 0x3)
#define   DMA_TCD10_CSR_BWC_0                    (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD10_CSR_BWC_10                   (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD10_CSR_BWC_11                   (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD10_BITER_ELINKNO;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD10_BITER_ELINKNO_BITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD10_BITER_ELINKNO_BITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD10_BITER_ELINKNO_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD10_BITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD10_BITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD10_BITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD10_BITER_ELINKYES;                          // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD10_BITER_ELINKYES_BITER(_n)       (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD10_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD10_BITER_ELINKYES_BITER_EXTRACT(_v)   (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD10_BITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD10_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD10_BITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD10_BITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD10_BITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD10_BITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD11_SADDR;                                   // TCD Source Address
    uint16_t             TCD11_SOFF;                                    // TCD Signed Source Address Offset
    uint16_t             TCD11_ATTR;                                    // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD11_ATTR_DSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD11_ATTR_DSIZE_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD11_ATTR_DSIZE_EXTRACT(_v)             (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD11_ATTR_DMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD11_ATTR_DMOD_INSERT(_v, _n)           (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD11_ATTR_DMOD_EXTRACT(_v)              (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD11_ATTR_SSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD11_ATTR_SSIZE_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD11_ATTR_SSIZE_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   DMA_TCD11_ATTR_SSIZE_0                 (uint16_t)0x0          // 8-bit
#define   DMA_TCD11_ATTR_SSIZE_1                 (uint16_t)0x1          // 16-bit
#define   DMA_TCD11_ATTR_SSIZE_10                (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD11_ATTR_SMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD11_ATTR_SMOD_INSERT(_v, _n)           (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD11_ATTR_SMOD_EXTRACT(_v)              (((_v) >> 11) & 0x1f)
#define   DMA_TCD11_ATTR_SMOD_0                  (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD11_NBYTES_MLNO;                             // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD11_NBYTES_MLOFFNO;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD11_NBYTES_MLOFFNO_NBYTES(_n)      (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD11_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD11_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD11_NBYTES_MLOFFNO_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD11_NBYTES_MLOFFNO_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD11_NBYTES_MLOFFNO_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD11_NBYTES_MLOFFNO_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD11_NBYTES_MLOFFNO_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD11_NBYTES_MLOFFNO_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD11_NBYTES_MLOFFYES;                         // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD11_NBYTES_MLOFFYES_NBYTES(_n)     (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD11_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD11_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v) (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD11_NBYTES_MLOFFYES_MLOFF(_n)      (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD11_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD11_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)  (((_v) >> 10) & 0xfffff)
#define DMA_TCD11_NBYTES_MLOFFYES_DMLOE          ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD11_NBYTES_MLOFFYES_DMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD11_NBYTES_MLOFFYES_DMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD11_NBYTES_MLOFFYES_SMLOE          ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD11_NBYTES_MLOFFYES_SMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD11_NBYTES_MLOFFYES_SMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD11_SLAST;                                   // TCD Last Source Address Adjustment
    uint32_t             TCD11_DADDR;                                   // TCD Destination Address
    uint16_t             TCD11_DOFF;                                    // TCD Signed Destination Address Offset
    uint16_t             TCD11_CITER_ELINKNO;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD11_CITER_ELINKNO_CITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD11_CITER_ELINKNO_CITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD11_CITER_ELINKNO_CITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD11_CITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD11_CITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD11_CITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD11_CITER_ELINKYES;                          // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD11_CITER_ELINKYES_CITER_LE(_n)    (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD11_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD11_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD11_CITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD11_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD11_CITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD11_CITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD11_CITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD11_CITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD11_DLASTSGA;                                // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD11_CSR;                                     // TCD Control and Status
#define DMA_TCD11_CSR_START                      ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD11_CSR_START_0                  (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD11_CSR_START_1                  (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD11_CSR_INTMAJOR                   ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD11_CSR_INTMAJOR_0               (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD11_CSR_INTMAJOR_1               (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD11_CSR_INTHALF                    ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD11_CSR_INTHALF_0                (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD11_CSR_INTHALF_1                (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD11_CSR_DREQ                       ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD11_CSR_ESG                        ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD11_CSR_ESG_0                    (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD11_CSR_ESG_1                    (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD11_CSR_MAJORELINK                 ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD11_CSR_MAJORELINK_0             (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD11_CSR_MAJORELINK_1             (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD11_CSR_ACTIVE                     ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD11_CSR_DONE                       ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD11_CSR_MAJORLINKCH(_n)            (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD11_CSR_MAJORLINKCH_INSERT(_v, _n)     (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD11_CSR_MAJORLINKCH_EXTRACT(_v)        (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD11_CSR_BWC(_n)                    (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD11_CSR_BWC_INSERT(_v, _n)             (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD11_CSR_BWC_EXTRACT(_v)                (((_v) >> 14) & 0x3)
#define   DMA_TCD11_CSR_BWC_0                    (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD11_CSR_BWC_10                   (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD11_CSR_BWC_11                   (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD11_BITER_ELINKNO;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD11_BITER_ELINKNO_BITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD11_BITER_ELINKNO_BITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD11_BITER_ELINKNO_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD11_BITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD11_BITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD11_BITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD11_BITER_ELINKYES;                          // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD11_BITER_ELINKYES_BITER(_n)       (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD11_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD11_BITER_ELINKYES_BITER_EXTRACT(_v)   (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD11_BITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD11_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD11_BITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD11_BITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD11_BITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD11_BITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD12_SADDR;                                   // TCD Source Address
    uint16_t             TCD12_SOFF;                                    // TCD Signed Source Address Offset
    uint16_t             TCD12_ATTR;                                    // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD12_ATTR_DSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD12_ATTR_DSIZE_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD12_ATTR_DSIZE_EXTRACT(_v)             (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD12_ATTR_DMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD12_ATTR_DMOD_INSERT(_v, _n)           (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD12_ATTR_DMOD_EXTRACT(_v)              (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD12_ATTR_SSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD12_ATTR_SSIZE_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD12_ATTR_SSIZE_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   DMA_TCD12_ATTR_SSIZE_0                 (uint16_t)0x0          // 8-bit
#define   DMA_TCD12_ATTR_SSIZE_1                 (uint16_t)0x1          // 16-bit
#define   DMA_TCD12_ATTR_SSIZE_10                (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD12_ATTR_SMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD12_ATTR_SMOD_INSERT(_v, _n)           (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD12_ATTR_SMOD_EXTRACT(_v)              (((_v) >> 11) & 0x1f)
#define   DMA_TCD12_ATTR_SMOD_0                  (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD12_NBYTES_MLNO;                             // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD12_NBYTES_MLOFFNO;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD12_NBYTES_MLOFFNO_NBYTES(_n)      (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD12_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD12_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD12_NBYTES_MLOFFNO_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD12_NBYTES_MLOFFNO_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD12_NBYTES_MLOFFNO_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD12_NBYTES_MLOFFNO_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD12_NBYTES_MLOFFNO_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD12_NBYTES_MLOFFNO_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD12_NBYTES_MLOFFYES;                         // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD12_NBYTES_MLOFFYES_NBYTES(_n)     (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD12_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD12_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v) (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD12_NBYTES_MLOFFYES_MLOFF(_n)      (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD12_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD12_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)  (((_v) >> 10) & 0xfffff)
#define DMA_TCD12_NBYTES_MLOFFYES_DMLOE          ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD12_NBYTES_MLOFFYES_DMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD12_NBYTES_MLOFFYES_DMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD12_NBYTES_MLOFFYES_SMLOE          ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD12_NBYTES_MLOFFYES_SMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD12_NBYTES_MLOFFYES_SMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD12_SLAST;                                   // TCD Last Source Address Adjustment
    uint32_t             TCD12_DADDR;                                   // TCD Destination Address
    uint16_t             TCD12_DOFF;                                    // TCD Signed Destination Address Offset
    uint16_t             TCD12_CITER_ELINKNO;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD12_CITER_ELINKNO_CITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD12_CITER_ELINKNO_CITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD12_CITER_ELINKNO_CITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD12_CITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD12_CITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD12_CITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD12_CITER_ELINKYES;                          // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD12_CITER_ELINKYES_CITER_LE(_n)    (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD12_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD12_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD12_CITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD12_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD12_CITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD12_CITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD12_CITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD12_CITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD12_DLASTSGA;                                // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD12_CSR;                                     // TCD Control and Status
#define DMA_TCD12_CSR_START                      ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD12_CSR_START_0                  (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD12_CSR_START_1                  (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD12_CSR_INTMAJOR                   ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD12_CSR_INTMAJOR_0               (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD12_CSR_INTMAJOR_1               (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD12_CSR_INTHALF                    ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD12_CSR_INTHALF_0                (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD12_CSR_INTHALF_1                (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD12_CSR_DREQ                       ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD12_CSR_ESG                        ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD12_CSR_ESG_0                    (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD12_CSR_ESG_1                    (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD12_CSR_MAJORELINK                 ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD12_CSR_MAJORELINK_0             (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD12_CSR_MAJORELINK_1             (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD12_CSR_ACTIVE                     ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD12_CSR_DONE                       ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD12_CSR_MAJORLINKCH(_n)            (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD12_CSR_MAJORLINKCH_INSERT(_v, _n)     (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD12_CSR_MAJORLINKCH_EXTRACT(_v)        (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD12_CSR_BWC(_n)                    (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD12_CSR_BWC_INSERT(_v, _n)             (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD12_CSR_BWC_EXTRACT(_v)                (((_v) >> 14) & 0x3)
#define   DMA_TCD12_CSR_BWC_0                    (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD12_CSR_BWC_10                   (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD12_CSR_BWC_11                   (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD12_BITER_ELINKNO;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD12_BITER_ELINKNO_BITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD12_BITER_ELINKNO_BITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD12_BITER_ELINKNO_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD12_BITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD12_BITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD12_BITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD12_BITER_ELINKYES;                          // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD12_BITER_ELINKYES_BITER(_n)       (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD12_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD12_BITER_ELINKYES_BITER_EXTRACT(_v)   (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD12_BITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD12_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD12_BITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD12_BITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD12_BITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD12_BITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD13_SADDR;                                   // TCD Source Address
    uint16_t             TCD13_SOFF;                                    // TCD Signed Source Address Offset
    uint16_t             TCD13_ATTR;                                    // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD13_ATTR_DSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD13_ATTR_DSIZE_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD13_ATTR_DSIZE_EXTRACT(_v)             (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD13_ATTR_DMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD13_ATTR_DMOD_INSERT(_v, _n)           (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD13_ATTR_DMOD_EXTRACT(_v)              (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD13_ATTR_SSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD13_ATTR_SSIZE_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD13_ATTR_SSIZE_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   DMA_TCD13_ATTR_SSIZE_0                 (uint16_t)0x0          // 8-bit
#define   DMA_TCD13_ATTR_SSIZE_1                 (uint16_t)0x1          // 16-bit
#define   DMA_TCD13_ATTR_SSIZE_10                (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD13_ATTR_SMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD13_ATTR_SMOD_INSERT(_v, _n)           (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD13_ATTR_SMOD_EXTRACT(_v)              (((_v) >> 11) & 0x1f)
#define   DMA_TCD13_ATTR_SMOD_0                  (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD13_NBYTES_MLNO;                             // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD13_NBYTES_MLOFFNO;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD13_NBYTES_MLOFFNO_NBYTES(_n)      (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD13_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD13_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD13_NBYTES_MLOFFNO_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD13_NBYTES_MLOFFNO_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD13_NBYTES_MLOFFNO_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD13_NBYTES_MLOFFNO_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD13_NBYTES_MLOFFNO_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD13_NBYTES_MLOFFNO_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD13_NBYTES_MLOFFYES;                         // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD13_NBYTES_MLOFFYES_NBYTES(_n)     (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD13_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD13_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v) (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD13_NBYTES_MLOFFYES_MLOFF(_n)      (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD13_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD13_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)  (((_v) >> 10) & 0xfffff)
#define DMA_TCD13_NBYTES_MLOFFYES_DMLOE          ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD13_NBYTES_MLOFFYES_DMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD13_NBYTES_MLOFFYES_DMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD13_NBYTES_MLOFFYES_SMLOE          ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD13_NBYTES_MLOFFYES_SMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD13_NBYTES_MLOFFYES_SMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD13_SLAST;                                   // TCD Last Source Address Adjustment
    uint32_t             TCD13_DADDR;                                   // TCD Destination Address
    uint16_t             TCD13_DOFF;                                    // TCD Signed Destination Address Offset
    uint16_t             TCD13_CITER_ELINKNO;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD13_CITER_ELINKNO_CITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD13_CITER_ELINKNO_CITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD13_CITER_ELINKNO_CITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD13_CITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD13_CITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD13_CITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD13_CITER_ELINKYES;                          // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD13_CITER_ELINKYES_CITER_LE(_n)    (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD13_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD13_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD13_CITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD13_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD13_CITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD13_CITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD13_CITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD13_CITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD13_DLASTSGA;                                // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD13_CSR;                                     // TCD Control and Status
#define DMA_TCD13_CSR_START                      ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD13_CSR_START_0                  (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD13_CSR_START_1                  (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD13_CSR_INTMAJOR                   ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD13_CSR_INTMAJOR_0               (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD13_CSR_INTMAJOR_1               (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD13_CSR_INTHALF                    ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD13_CSR_INTHALF_0                (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD13_CSR_INTHALF_1                (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD13_CSR_DREQ                       ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD13_CSR_ESG                        ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD13_CSR_ESG_0                    (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD13_CSR_ESG_1                    (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD13_CSR_MAJORELINK                 ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD13_CSR_MAJORELINK_0             (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD13_CSR_MAJORELINK_1             (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD13_CSR_ACTIVE                     ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD13_CSR_DONE                       ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD13_CSR_MAJORLINKCH(_n)            (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD13_CSR_MAJORLINKCH_INSERT(_v, _n)     (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD13_CSR_MAJORLINKCH_EXTRACT(_v)        (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD13_CSR_BWC(_n)                    (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD13_CSR_BWC_INSERT(_v, _n)             (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD13_CSR_BWC_EXTRACT(_v)                (((_v) >> 14) & 0x3)
#define   DMA_TCD13_CSR_BWC_0                    (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD13_CSR_BWC_10                   (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD13_CSR_BWC_11                   (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD13_BITER_ELINKNO;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD13_BITER_ELINKNO_BITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD13_BITER_ELINKNO_BITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD13_BITER_ELINKNO_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD13_BITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD13_BITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD13_BITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD13_BITER_ELINKYES;                          // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD13_BITER_ELINKYES_BITER(_n)       (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD13_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD13_BITER_ELINKYES_BITER_EXTRACT(_v)   (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD13_BITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD13_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD13_BITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD13_BITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD13_BITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD13_BITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD14_SADDR;                                   // TCD Source Address
    uint16_t             TCD14_SOFF;                                    // TCD Signed Source Address Offset
    uint16_t             TCD14_ATTR;                                    // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD14_ATTR_DSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD14_ATTR_DSIZE_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD14_ATTR_DSIZE_EXTRACT(_v)             (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD14_ATTR_DMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD14_ATTR_DMOD_INSERT(_v, _n)           (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD14_ATTR_DMOD_EXTRACT(_v)              (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD14_ATTR_SSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD14_ATTR_SSIZE_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD14_ATTR_SSIZE_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   DMA_TCD14_ATTR_SSIZE_0                 (uint16_t)0x0          // 8-bit
#define   DMA_TCD14_ATTR_SSIZE_1                 (uint16_t)0x1          // 16-bit
#define   DMA_TCD14_ATTR_SSIZE_10                (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD14_ATTR_SMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD14_ATTR_SMOD_INSERT(_v, _n)           (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD14_ATTR_SMOD_EXTRACT(_v)              (((_v) >> 11) & 0x1f)
#define   DMA_TCD14_ATTR_SMOD_0                  (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD14_NBYTES_MLNO;                             // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD14_NBYTES_MLOFFNO;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD14_NBYTES_MLOFFNO_NBYTES(_n)      (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD14_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD14_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD14_NBYTES_MLOFFNO_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD14_NBYTES_MLOFFNO_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD14_NBYTES_MLOFFNO_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD14_NBYTES_MLOFFNO_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD14_NBYTES_MLOFFNO_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD14_NBYTES_MLOFFNO_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD14_NBYTES_MLOFFYES;                         // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD14_NBYTES_MLOFFYES_NBYTES(_n)     (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD14_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD14_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v) (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD14_NBYTES_MLOFFYES_MLOFF(_n)      (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD14_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD14_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)  (((_v) >> 10) & 0xfffff)
#define DMA_TCD14_NBYTES_MLOFFYES_DMLOE          ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD14_NBYTES_MLOFFYES_DMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD14_NBYTES_MLOFFYES_DMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD14_NBYTES_MLOFFYES_SMLOE          ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD14_NBYTES_MLOFFYES_SMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD14_NBYTES_MLOFFYES_SMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD14_SLAST;                                   // TCD Last Source Address Adjustment
    uint32_t             TCD14_DADDR;                                   // TCD Destination Address
    uint16_t             TCD14_DOFF;                                    // TCD Signed Destination Address Offset
    uint16_t             TCD14_CITER_ELINKNO;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD14_CITER_ELINKNO_CITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD14_CITER_ELINKNO_CITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD14_CITER_ELINKNO_CITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD14_CITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD14_CITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD14_CITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD14_CITER_ELINKYES;                          // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD14_CITER_ELINKYES_CITER_LE(_n)    (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD14_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD14_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD14_CITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD14_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD14_CITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD14_CITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD14_CITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD14_CITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD14_DLASTSGA;                                // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD14_CSR;                                     // TCD Control and Status
#define DMA_TCD14_CSR_START                      ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD14_CSR_START_0                  (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD14_CSR_START_1                  (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD14_CSR_INTMAJOR                   ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD14_CSR_INTMAJOR_0               (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD14_CSR_INTMAJOR_1               (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD14_CSR_INTHALF                    ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD14_CSR_INTHALF_0                (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD14_CSR_INTHALF_1                (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD14_CSR_DREQ                       ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD14_CSR_ESG                        ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD14_CSR_ESG_0                    (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD14_CSR_ESG_1                    (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD14_CSR_MAJORELINK                 ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD14_CSR_MAJORELINK_0             (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD14_CSR_MAJORELINK_1             (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD14_CSR_ACTIVE                     ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD14_CSR_DONE                       ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD14_CSR_MAJORLINKCH(_n)            (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD14_CSR_MAJORLINKCH_INSERT(_v, _n)     (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD14_CSR_MAJORLINKCH_EXTRACT(_v)        (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD14_CSR_BWC(_n)                    (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD14_CSR_BWC_INSERT(_v, _n)             (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD14_CSR_BWC_EXTRACT(_v)                (((_v) >> 14) & 0x3)
#define   DMA_TCD14_CSR_BWC_0                    (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD14_CSR_BWC_10                   (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD14_CSR_BWC_11                   (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD14_BITER_ELINKNO;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD14_BITER_ELINKNO_BITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD14_BITER_ELINKNO_BITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD14_BITER_ELINKNO_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD14_BITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD14_BITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD14_BITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD14_BITER_ELINKYES;                          // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD14_BITER_ELINKYES_BITER(_n)       (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD14_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD14_BITER_ELINKYES_BITER_EXTRACT(_v)   (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD14_BITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD14_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD14_BITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD14_BITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD14_BITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD14_BITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD15_SADDR;                                   // TCD Source Address
    uint16_t             TCD15_SOFF;                                    // TCD Signed Source Address Offset
    uint16_t             TCD15_ATTR;                                    // TCD Transfer Attributes
                                                                        // Destination data transfer size
#define DMA_TCD15_ATTR_DSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD15_ATTR_DSIZE_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint16_t)(_n) & 0x7) << 0)
#define DMA_TCD15_ATTR_DSIZE_EXTRACT(_v)             (((_v) >> 0) & 0x7)
                                                                        // Destination Address Modulo
#define DMA_TCD15_ATTR_DMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD15_ATTR_DMOD_INSERT(_v, _n)           (((_v) & ~0xf8) | ((uint16_t)(_n) & 0x1f) << 3)
#define DMA_TCD15_ATTR_DMOD_EXTRACT(_v)              (((_v) >> 3) & 0x1f)
                                                                        // Source data transfer size
#define DMA_TCD15_ATTR_SSIZE(_n)                 (((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD15_ATTR_SSIZE_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint16_t)(_n) & 0x7) << 8)
#define DMA_TCD15_ATTR_SSIZE_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   DMA_TCD15_ATTR_SSIZE_0                 (uint16_t)0x0          // 8-bit
#define   DMA_TCD15_ATTR_SSIZE_1                 (uint16_t)0x1          // 16-bit
#define   DMA_TCD15_ATTR_SSIZE_10                (uint16_t)0x2          // 32-bit
                                                                        // Source Address Modulo
#define DMA_TCD15_ATTR_SMOD(_n)                  (((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD15_ATTR_SMOD_INSERT(_v, _n)           (((_v) & ~0xf800) | ((uint16_t)(_n) & 0x1f) << 11)
#define DMA_TCD15_ATTR_SMOD_EXTRACT(_v)              (((_v) >> 11) & 0x1f)
#define   DMA_TCD15_ATTR_SMOD_0                  (uint16_t)0x0          // Source address modulo feature is disabled

    uint32_t             TCD15_NBYTES_MLNO;                             // TCD Minor Byte Count (Minor Loop Mapping Disabled)
    uint32_t             TCD15_NBYTES_MLOFFNO;                          // TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD15_NBYTES_MLOFFNO_NBYTES(_n)      (((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD15_NBYTES_MLOFFNO_NBYTES_INSERT(_v, _n) (((_v) & ~0x3fffffff) | ((uint32_t)(_n) & 0x3fffffff) << 0)
#define DMA_TCD15_NBYTES_MLOFFNO_NBYTES_EXTRACT(_v)  (((_v) >> 0) & 0x3fffffff)
#define DMA_TCD15_NBYTES_MLOFFNO_DMLOE           ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD15_NBYTES_MLOFFNO_DMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD15_NBYTES_MLOFFNO_DMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD15_NBYTES_MLOFFNO_SMLOE           ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD15_NBYTES_MLOFFNO_SMLOE_0       (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD15_NBYTES_MLOFFNO_SMLOE_1       (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD15_NBYTES_MLOFFYES;                         // TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
                                                                        // Minor Byte Transfer Count
#define DMA_TCD15_NBYTES_MLOFFYES_NBYTES(_n)     (((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD15_NBYTES_MLOFFYES_NBYTES_INSERT(_v, _n) (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define DMA_TCD15_NBYTES_MLOFFYES_NBYTES_EXTRACT(_v) (((_v) >> 0) & 0x3ff)
                                                                        // If SMLOE or DMLOE is set, this field represents a sign-extended offset applied to the source or destination address to form the next-state value after the minor loop completes.
#define DMA_TCD15_NBYTES_MLOFFYES_MLOFF(_n)      (((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD15_NBYTES_MLOFFYES_MLOFF_INSERT(_v, _n) (((_v) & ~0x3ffffc00) | ((uint32_t)(_n) & 0xfffff) << 10)
#define DMA_TCD15_NBYTES_MLOFFYES_MLOFF_EXTRACT(_v)  (((_v) >> 10) & 0xfffff)
#define DMA_TCD15_NBYTES_MLOFFYES_DMLOE          ((uint32_t)1 << 30)    // Destination Minor Loop Offset enable
#define   DMA_TCD15_NBYTES_MLOFFYES_DMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the DADDR
#define   DMA_TCD15_NBYTES_MLOFFYES_DMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the DADDR
#define DMA_TCD15_NBYTES_MLOFFYES_SMLOE          ((uint32_t)1 << 31)    // Source Minor Loop Offset Enable
#define   DMA_TCD15_NBYTES_MLOFFYES_SMLOE_0      (uint32_t)0x0          // The minor loop offset is not applied to the SADDR
#define   DMA_TCD15_NBYTES_MLOFFYES_SMLOE_1      (uint32_t)0x1          // The minor loop offset is applied to the SADDR

    uint32_t             TCD15_SLAST;                                   // TCD Last Source Address Adjustment
    uint32_t             TCD15_DADDR;                                   // TCD Destination Address
    uint16_t             TCD15_DOFF;                                    // TCD Signed Destination Address Offset
    uint16_t             TCD15_CITER_ELINKNO;                           // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD15_CITER_ELINKNO_CITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD15_CITER_ELINKNO_CITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD15_CITER_ELINKNO_CITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD15_CITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD15_CITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD15_CITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD15_CITER_ELINKYES;                          // TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Current Major Iteration Count
#define DMA_TCD15_CITER_ELINKYES_CITER_LE(_n)    (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD15_CITER_ELINKYES_CITER_LE_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD15_CITER_ELINKYES_CITER_LE_EXTRACT(_v) (((_v) >> 0) & 0x1ff)
                                                                        // Minor Loop Link Channel Number
#define DMA_TCD15_CITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD15_CITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD15_CITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD15_CITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enable channel-to-channel linking on minor-loop complete
#define   DMA_TCD15_CITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD15_CITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint32_t             TCD15_DLASTSGA;                                // TCD Last Destination Address Adjustment/Scatter Gather Address
    uint16_t             TCD15_CSR;                                     // TCD Control and Status
#define DMA_TCD15_CSR_START                      ((uint16_t)1 << 0)     // Channel Start
#define   DMA_TCD15_CSR_START_0                  (uint16_t)0x0          // The channel is not explicitly started.
#define   DMA_TCD15_CSR_START_1                  (uint16_t)0x1          // The channel is explicitly started via a software initiated service request.
#define DMA_TCD15_CSR_INTMAJOR                   ((uint16_t)1 << 1)     // Enable an interrupt when major iteration count completes.
#define   DMA_TCD15_CSR_INTMAJOR_0               (uint16_t)0x0          // The end-of-major loop interrupt is disabled.
#define   DMA_TCD15_CSR_INTMAJOR_1               (uint16_t)0x1          // The end-of-major loop interrupt is enabled.
#define DMA_TCD15_CSR_INTHALF                    ((uint16_t)1 << 2)     // Enable an interrupt when major counter is half complete.
#define   DMA_TCD15_CSR_INTHALF_0                (uint16_t)0x0          // The half-point interrupt is disabled.
#define   DMA_TCD15_CSR_INTHALF_1                (uint16_t)0x1          // The half-point interrupt is enabled.
#define DMA_TCD15_CSR_DREQ                       ((uint16_t)1 << 3)     // Disable Request
#define DMA_TCD15_CSR_ESG                        ((uint16_t)1 << 4)     // Enable Scatter/Gather Processing
#define   DMA_TCD15_CSR_ESG_0                    (uint16_t)0x0          // The current channel's TCD is normal format.
#define   DMA_TCD15_CSR_ESG_1                    (uint16_t)0x1          // The current channel's TCD specifies a scatter gather format. The DLASTSGA field provides a memory pointer to the next TCD to be loaded into this channel after the major loop completes its execution.
#define DMA_TCD15_CSR_MAJORELINK                 ((uint16_t)1 << 5)     // Enable channel-to-channel linking on major loop complete
#define   DMA_TCD15_CSR_MAJORELINK_0             (uint16_t)0x0          // The channel-to-channel linking is disabled.
#define   DMA_TCD15_CSR_MAJORELINK_1             (uint16_t)0x1          // The channel-to-channel linking is enabled.
#define DMA_TCD15_CSR_ACTIVE                     ((uint16_t)1 << 6)     // Channel Active
#define DMA_TCD15_CSR_DONE                       ((uint16_t)1 << 7)     // Channel Done
                                                                        // Major Loop Link Channel Number
#define DMA_TCD15_CSR_MAJORLINKCH(_n)            (((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD15_CSR_MAJORLINKCH_INSERT(_v, _n)     (((_v) & ~0xf00) | ((uint16_t)(_n) & 0xf) << 8)
#define DMA_TCD15_CSR_MAJORLINKCH_EXTRACT(_v)        (((_v) >> 8) & 0xf)
                                                                        // Bandwidth Control
#define DMA_TCD15_CSR_BWC(_n)                    (((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD15_CSR_BWC_INSERT(_v, _n)             (((_v) & ~0xc000) | ((uint16_t)(_n) & 0x3) << 14)
#define DMA_TCD15_CSR_BWC_EXTRACT(_v)                (((_v) >> 14) & 0x3)
#define   DMA_TCD15_CSR_BWC_0                    (uint16_t)0x0          // No eDMA engine stalls.
#define   DMA_TCD15_CSR_BWC_10                   (uint16_t)0x2          // eDMA engine stalls for 4 cycles after each R/W.
#define   DMA_TCD15_CSR_BWC_11                   (uint16_t)0x3          // eDMA engine stalls for 8 cycles after each R/W.

    uint16_t             TCD15_BITER_ELINKNO;                           // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
                                                                        // Starting Major Iteration Count
#define DMA_TCD15_BITER_ELINKNO_BITER(_n)        (((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD15_BITER_ELINKNO_BITER_INSERT(_v, _n) (((_v) & ~0x7fff) | ((uint16_t)(_n) & 0x7fff) << 0)
#define DMA_TCD15_BITER_ELINKNO_BITER_EXTRACT(_v)    (((_v) >> 0) & 0x7fff)
#define DMA_TCD15_BITER_ELINKNO_ELINK            ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD15_BITER_ELINKNO_ELINK_0        (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD15_BITER_ELINKNO_ELINK_1        (uint16_t)0x1          // The channel-to-channel linking is enabled

    uint16_t             TCD15_BITER_ELINKYES;                          // TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
                                                                        // Starting major iteration count
#define DMA_TCD15_BITER_ELINKYES_BITER(_n)       (((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD15_BITER_ELINKYES_BITER_INSERT(_v, _n) (((_v) & ~0x1ff) | ((uint16_t)(_n) & 0x1ff) << 0)
#define DMA_TCD15_BITER_ELINKYES_BITER_EXTRACT(_v)   (((_v) >> 0) & 0x1ff)
                                                                        // Link Channel Number
#define DMA_TCD15_BITER_ELINKYES_LINKCH(_n)      (((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD15_BITER_ELINKYES_LINKCH_INSERT(_v, _n) (((_v) & ~0x1e00) | ((uint16_t)(_n) & 0xf) << 9)
#define DMA_TCD15_BITER_ELINKYES_LINKCH_EXTRACT(_v)  (((_v) >> 9) & 0xf)
#define DMA_TCD15_BITER_ELINKYES_ELINK           ((uint16_t)1 << 15)    // Enables channel-to-channel linking on minor loop complete
#define   DMA_TCD15_BITER_ELINKYES_ELINK_0       (uint16_t)0x0          // The channel-to-channel linking is disabled
#define   DMA_TCD15_BITER_ELINKYES_ELINK_1       (uint16_t)0x1          // The channel-to-channel linking is enabled

} DMA_regs_t;
                                                                        // --------------------
                                                                        // Memory protection unit
typedef struct                                                          // --------------------
{
    uint32_t             CESR;                                          // Control/Error Status Register
#define MPU_CESR_VLD                             ((uint32_t)1 << 0)     // Valid
#define   MPU_CESR_VLD_0                         (uint32_t)0x0          // MPU is disabled. All accesses from all bus masters are allowed.
#define   MPU_CESR_VLD_1                         (uint32_t)0x1          // MPU is enabled
                                                                        // Number Of Region Descriptors
#define MPU_CESR_NRGD(_n)                        (((uint32_t)(_n) & 0xf) << 8)
#define MPU_CESR_NRGD_INSERT(_v, _n)                 (((_v) & ~0xf00) | ((uint32_t)(_n) & 0xf) << 8)
#define MPU_CESR_NRGD_EXTRACT(_v)                    (((_v) >> 8) & 0xf)
#define   MPU_CESR_NRGD_0000                     (uint32_t)0x0          // 8 region descriptors
#define   MPU_CESR_NRGD_0001                     (uint32_t)0x1          // 12 region descriptors
#define   MPU_CESR_NRGD_0010                     (uint32_t)0x2          // 16 region descriptors
                                                                        // Number Of Slave Ports
#define MPU_CESR_NSP(_n)                         (((uint32_t)(_n) & 0xf) << 12)
#define MPU_CESR_NSP_INSERT(_v, _n)                  (((_v) & ~0xf000) | ((uint32_t)(_n) & 0xf) << 12)
#define MPU_CESR_NSP_EXTRACT(_v)                     (((_v) >> 12) & 0xf)
                                                                        // Hardware Revision Level
#define MPU_CESR_HRL(_n)                         (((uint32_t)(_n) & 0xf) << 16)
#define MPU_CESR_HRL_INSERT(_v, _n)                  (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define MPU_CESR_HRL_EXTRACT(_v)                     (((_v) >> 16) & 0xf)
#define MPU_CESR_SPERR3                          ((uint32_t)1 << 28)    // Slave Port 3 Error
#define   MPU_CESR_SPERR3_0                      (uint32_t)0x0          // No error has occurred for slave port 3.
#define   MPU_CESR_SPERR3_1                      (uint32_t)0x1          // An error has occurred for slave port 3.
#define MPU_CESR_SPERR2                          ((uint32_t)1 << 29)    // Slave Port 2 Error
#define   MPU_CESR_SPERR2_0                      (uint32_t)0x0          // No error has occurred for slave port 2.
#define   MPU_CESR_SPERR2_1                      (uint32_t)0x1          // An error has occurred for slave port 2.
#define MPU_CESR_SPERR1                          ((uint32_t)1 << 30)    // Slave Port 1 Error
#define   MPU_CESR_SPERR1_0                      (uint32_t)0x0          // No error has occurred for slave port 1.
#define   MPU_CESR_SPERR1_1                      (uint32_t)0x1          // An error has occurred for slave port 1.
#define MPU_CESR_SPERR0                          ((uint32_t)1 << 31)    // Slave Port 0 Error
#define   MPU_CESR_SPERR0_0                      (uint32_t)0x0          // No error has occurred for slave port 0.
#define   MPU_CESR_SPERR0_1                      (uint32_t)0x1          // An error has occurred for slave port 0.

    uint8_t _res0[12];
    const uint32_t       EAR0;                                          // Error Address Register, slave port 0
    const uint32_t       EDR0;                                          // Error Detail Register, slave port 0
#define MPU_EDR0_ERW                             ((uint32_t)1 << 0)     // Error Read/Write
#define   MPU_EDR0_ERW_0                         (uint32_t)0x0          // Read
#define   MPU_EDR0_ERW_1                         (uint32_t)0x1          // Write
                                                                        // Error Attributes
#define MPU_EDR0_EATTR_EXTRACT(_v)                   (((_v) >> 1) & 0x7)
#define   MPU_EDR0_EATTR_000                     (uint32_t)0x0          // User mode, instruction access
#define   MPU_EDR0_EATTR_001                     (uint32_t)0x1          // User mode, data access
#define   MPU_EDR0_EATTR_010                     (uint32_t)0x2          // Supervisor mode, instruction access
#define   MPU_EDR0_EATTR_011                     (uint32_t)0x3          // Supervisor mode, data access
                                                                        // Error Master Number
#define MPU_EDR0_EMN_EXTRACT(_v)                     (((_v) >> 4) & 0xf)
                                                                        // Error Process Identification
#define MPU_EDR0_EPID_EXTRACT(_v)                    (((_v) >> 8) & 0xff)
                                                                        // Error Access Control Detail
#define MPU_EDR0_EACD_EXTRACT(_v)                    (((_v) >> 16) & 0xffff)

    const uint32_t       EAR1;                                          // Error Address Register, slave port 1
    const uint32_t       EDR1;                                          // Error Detail Register, slave port 1
#define MPU_EDR1_ERW                             ((uint32_t)1 << 0)     // Error Read/Write
#define   MPU_EDR1_ERW_0                         (uint32_t)0x0          // Read
#define   MPU_EDR1_ERW_1                         (uint32_t)0x1          // Write
                                                                        // Error Attributes
#define MPU_EDR1_EATTR_EXTRACT(_v)                   (((_v) >> 1) & 0x7)
#define   MPU_EDR1_EATTR_000                     (uint32_t)0x0          // User mode, instruction access
#define   MPU_EDR1_EATTR_001                     (uint32_t)0x1          // User mode, data access
#define   MPU_EDR1_EATTR_010                     (uint32_t)0x2          // Supervisor mode, instruction access
#define   MPU_EDR1_EATTR_011                     (uint32_t)0x3          // Supervisor mode, data access
                                                                        // Error Master Number
#define MPU_EDR1_EMN_EXTRACT(_v)                     (((_v) >> 4) & 0xf)
                                                                        // Error Process Identification
#define MPU_EDR1_EPID_EXTRACT(_v)                    (((_v) >> 8) & 0xff)
                                                                        // Error Access Control Detail
#define MPU_EDR1_EACD_EXTRACT(_v)                    (((_v) >> 16) & 0xffff)

    const uint32_t       EAR2;                                          // Error Address Register, slave port 2
    const uint32_t       EDR2;                                          // Error Detail Register, slave port 2
#define MPU_EDR2_ERW                             ((uint32_t)1 << 0)     // Error Read/Write
#define   MPU_EDR2_ERW_0                         (uint32_t)0x0          // Read
#define   MPU_EDR2_ERW_1                         (uint32_t)0x1          // Write
                                                                        // Error Attributes
#define MPU_EDR2_EATTR_EXTRACT(_v)                   (((_v) >> 1) & 0x7)
#define   MPU_EDR2_EATTR_000                     (uint32_t)0x0          // User mode, instruction access
#define   MPU_EDR2_EATTR_001                     (uint32_t)0x1          // User mode, data access
#define   MPU_EDR2_EATTR_010                     (uint32_t)0x2          // Supervisor mode, instruction access
#define   MPU_EDR2_EATTR_011                     (uint32_t)0x3          // Supervisor mode, data access
                                                                        // Error Master Number
#define MPU_EDR2_EMN_EXTRACT(_v)                     (((_v) >> 4) & 0xf)
                                                                        // Error Process Identification
#define MPU_EDR2_EPID_EXTRACT(_v)                    (((_v) >> 8) & 0xff)
                                                                        // Error Access Control Detail
#define MPU_EDR2_EACD_EXTRACT(_v)                    (((_v) >> 16) & 0xffff)

    const uint32_t       EAR3;                                          // Error Address Register, slave port 3
    const uint32_t       EDR3;                                          // Error Detail Register, slave port 3
#define MPU_EDR3_ERW                             ((uint32_t)1 << 0)     // Error Read/Write
#define   MPU_EDR3_ERW_0                         (uint32_t)0x0          // Read
#define   MPU_EDR3_ERW_1                         (uint32_t)0x1          // Write
                                                                        // Error Attributes
#define MPU_EDR3_EATTR_EXTRACT(_v)                   (((_v) >> 1) & 0x7)
#define   MPU_EDR3_EATTR_000                     (uint32_t)0x0          // User mode, instruction access
#define   MPU_EDR3_EATTR_001                     (uint32_t)0x1          // User mode, data access
#define   MPU_EDR3_EATTR_010                     (uint32_t)0x2          // Supervisor mode, instruction access
#define   MPU_EDR3_EATTR_011                     (uint32_t)0x3          // Supervisor mode, data access
                                                                        // Error Master Number
#define MPU_EDR3_EMN_EXTRACT(_v)                     (((_v) >> 4) & 0xf)
                                                                        // Error Process Identification
#define MPU_EDR3_EPID_EXTRACT(_v)                    (((_v) >> 8) & 0xff)
                                                                        // Error Access Control Detail
#define MPU_EDR3_EACD_EXTRACT(_v)                    (((_v) >> 16) & 0xffff)

    uint8_t _res1[976];
    uint32_t             RGD0_WORD0;                                    // Region Descriptor 0, Word 0
                                                                        // Start Address
#define MPU_RGD0_WORD0_SRTADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD0_WORD0_SRTADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD0_WORD0_SRTADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD0_WORD1;                                    // Region Descriptor 0, Word 1
                                                                        // End Address
#define MPU_RGD0_WORD1_ENDADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD0_WORD1_ENDADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD0_WORD1_ENDADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD0_WORD2;                                    // Region Descriptor 0, Word 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGD0_WORD2_M0UM(_n)                  (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD0_WORD2_M0UM_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD0_WORD2_M0UM_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGD0_WORD2_M0SM(_n)                  (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD0_WORD2_M0SM_INSERT(_v, _n)           (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD0_WORD2_M0SM_EXTRACT(_v)              (((_v) >> 3) & 0x3)
#define   MPU_RGD0_WORD2_M0SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD0_WORD2_M0SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD0_WORD2_M0SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD0_WORD2_M0SM_11                 (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGD0_WORD2_M0PE                      ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier enable
#define   MPU_RGD0_WORD2_M0PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD0_WORD2_M0PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGD0_WORD2_M1UM(_n)                  (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD0_WORD2_M1UM_INSERT(_v, _n)           (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD0_WORD2_M1UM_EXTRACT(_v)              (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGD0_WORD2_M1SM(_n)                  (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD0_WORD2_M1SM_INSERT(_v, _n)           (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD0_WORD2_M1SM_EXTRACT(_v)              (((_v) >> 9) & 0x3)
#define   MPU_RGD0_WORD2_M1SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD0_WORD2_M1SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD0_WORD2_M1SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD0_WORD2_M1SM_11                 (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGD0_WORD2_M1PE                      ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier enable
#define   MPU_RGD0_WORD2_M1PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD0_WORD2_M1PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access control
#define MPU_RGD0_WORD2_M2UM(_n)                  (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD0_WORD2_M2UM_INSERT(_v, _n)           (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD0_WORD2_M2UM_EXTRACT(_v)              (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGD0_WORD2_M2SM(_n)                  (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD0_WORD2_M2SM_INSERT(_v, _n)           (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD0_WORD2_M2SM_EXTRACT(_v)              (((_v) >> 15) & 0x3)
#define   MPU_RGD0_WORD2_M2SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD0_WORD2_M2SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD0_WORD2_M2SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD0_WORD2_M2SM_11                 (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGD0_WORD2_M3UM(_n)                  (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD0_WORD2_M3UM_INSERT(_v, _n)           (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD0_WORD2_M3UM_EXTRACT(_v)              (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGD0_WORD2_M3SM(_n)                  (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD0_WORD2_M3SM_INSERT(_v, _n)           (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD0_WORD2_M3SM_EXTRACT(_v)              (((_v) >> 21) & 0x3)
#define   MPU_RGD0_WORD2_M3SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD0_WORD2_M3SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD0_WORD2_M3SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD0_WORD2_M3SM_11                 (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGD0_WORD2_M4WE                      ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGD0_WORD2_M4WE_0                  (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGD0_WORD2_M4WE_1                  (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGD0_WORD2_M4RE                      ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGD0_WORD2_M4RE_0                  (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGD0_WORD2_M4RE_1                  (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGD0_WORD2_M5WE                      ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGD0_WORD2_M5WE_0                  (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGD0_WORD2_M5WE_1                  (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGD0_WORD2_M5RE                      ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGD0_WORD2_M5RE_0                  (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGD0_WORD2_M5RE_1                  (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGD0_WORD2_M6WE                      ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGD0_WORD2_M6WE_0                  (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGD0_WORD2_M6WE_1                  (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGD0_WORD2_M6RE                      ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGD0_WORD2_M6RE_0                  (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGD0_WORD2_M6RE_1                  (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGD0_WORD2_M7WE                      ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGD0_WORD2_M7WE_0                  (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGD0_WORD2_M7WE_1                  (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGD0_WORD2_M7RE                      ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGD0_WORD2_M7RE_0                  (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGD0_WORD2_M7RE_1                  (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGD0_WORD3;                                    // Region Descriptor 0, Word 3
#define MPU_RGD0_WORD3_VLD                       ((uint32_t)1 << 0)     // Valid
#define   MPU_RGD0_WORD3_VLD_0                   (uint32_t)0x0          // Region descriptor is invalid
#define   MPU_RGD0_WORD3_VLD_1                   (uint32_t)0x1          // Region descriptor is valid
                                                                        // Process Identifier Mask
#define MPU_RGD0_WORD3_PIDMASK(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD0_WORD3_PIDMASK_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD0_WORD3_PIDMASK_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Process Identifier
#define MPU_RGD0_WORD3_PID(_n)                   (((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD0_WORD3_PID_INSERT(_v, _n)            (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD0_WORD3_PID_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    uint32_t             RGD1_WORD0;                                    // Region Descriptor 1, Word 0
                                                                        // Start Address
#define MPU_RGD1_WORD0_SRTADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD1_WORD0_SRTADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD1_WORD0_SRTADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD1_WORD1;                                    // Region Descriptor 1, Word 1
                                                                        // End Address
#define MPU_RGD1_WORD1_ENDADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD1_WORD1_ENDADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD1_WORD1_ENDADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD1_WORD2;                                    // Region Descriptor 1, Word 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGD1_WORD2_M0UM(_n)                  (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD1_WORD2_M0UM_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD1_WORD2_M0UM_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGD1_WORD2_M0SM(_n)                  (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD1_WORD2_M0SM_INSERT(_v, _n)           (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD1_WORD2_M0SM_EXTRACT(_v)              (((_v) >> 3) & 0x3)
#define   MPU_RGD1_WORD2_M0SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD1_WORD2_M0SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD1_WORD2_M0SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD1_WORD2_M0SM_11                 (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGD1_WORD2_M0PE                      ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier enable
#define   MPU_RGD1_WORD2_M0PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD1_WORD2_M0PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGD1_WORD2_M1UM(_n)                  (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD1_WORD2_M1UM_INSERT(_v, _n)           (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD1_WORD2_M1UM_EXTRACT(_v)              (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGD1_WORD2_M1SM(_n)                  (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD1_WORD2_M1SM_INSERT(_v, _n)           (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD1_WORD2_M1SM_EXTRACT(_v)              (((_v) >> 9) & 0x3)
#define   MPU_RGD1_WORD2_M1SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD1_WORD2_M1SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD1_WORD2_M1SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD1_WORD2_M1SM_11                 (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGD1_WORD2_M1PE                      ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier enable
#define   MPU_RGD1_WORD2_M1PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD1_WORD2_M1PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access control
#define MPU_RGD1_WORD2_M2UM(_n)                  (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD1_WORD2_M2UM_INSERT(_v, _n)           (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD1_WORD2_M2UM_EXTRACT(_v)              (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGD1_WORD2_M2SM(_n)                  (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD1_WORD2_M2SM_INSERT(_v, _n)           (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD1_WORD2_M2SM_EXTRACT(_v)              (((_v) >> 15) & 0x3)
#define   MPU_RGD1_WORD2_M2SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD1_WORD2_M2SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD1_WORD2_M2SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD1_WORD2_M2SM_11                 (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGD1_WORD2_M3UM(_n)                  (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD1_WORD2_M3UM_INSERT(_v, _n)           (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD1_WORD2_M3UM_EXTRACT(_v)              (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGD1_WORD2_M3SM(_n)                  (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD1_WORD2_M3SM_INSERT(_v, _n)           (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD1_WORD2_M3SM_EXTRACT(_v)              (((_v) >> 21) & 0x3)
#define   MPU_RGD1_WORD2_M3SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD1_WORD2_M3SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD1_WORD2_M3SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD1_WORD2_M3SM_11                 (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGD1_WORD2_M4WE                      ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGD1_WORD2_M4WE_0                  (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGD1_WORD2_M4WE_1                  (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGD1_WORD2_M4RE                      ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGD1_WORD2_M4RE_0                  (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGD1_WORD2_M4RE_1                  (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGD1_WORD2_M5WE                      ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGD1_WORD2_M5WE_0                  (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGD1_WORD2_M5WE_1                  (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGD1_WORD2_M5RE                      ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGD1_WORD2_M5RE_0                  (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGD1_WORD2_M5RE_1                  (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGD1_WORD2_M6WE                      ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGD1_WORD2_M6WE_0                  (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGD1_WORD2_M6WE_1                  (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGD1_WORD2_M6RE                      ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGD1_WORD2_M6RE_0                  (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGD1_WORD2_M6RE_1                  (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGD1_WORD2_M7WE                      ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGD1_WORD2_M7WE_0                  (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGD1_WORD2_M7WE_1                  (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGD1_WORD2_M7RE                      ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGD1_WORD2_M7RE_0                  (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGD1_WORD2_M7RE_1                  (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGD1_WORD3;                                    // Region Descriptor 1, Word 3
#define MPU_RGD1_WORD3_VLD                       ((uint32_t)1 << 0)     // Valid
#define   MPU_RGD1_WORD3_VLD_0                   (uint32_t)0x0          // Region descriptor is invalid
#define   MPU_RGD1_WORD3_VLD_1                   (uint32_t)0x1          // Region descriptor is valid
                                                                        // Process Identifier Mask
#define MPU_RGD1_WORD3_PIDMASK(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD1_WORD3_PIDMASK_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD1_WORD3_PIDMASK_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Process Identifier
#define MPU_RGD1_WORD3_PID(_n)                   (((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD1_WORD3_PID_INSERT(_v, _n)            (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD1_WORD3_PID_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    uint32_t             RGD2_WORD0;                                    // Region Descriptor 2, Word 0
                                                                        // Start Address
#define MPU_RGD2_WORD0_SRTADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD2_WORD0_SRTADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD2_WORD0_SRTADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD2_WORD1;                                    // Region Descriptor 2, Word 1
                                                                        // End Address
#define MPU_RGD2_WORD1_ENDADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD2_WORD1_ENDADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD2_WORD1_ENDADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD2_WORD2;                                    // Region Descriptor 2, Word 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGD2_WORD2_M0UM(_n)                  (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD2_WORD2_M0UM_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD2_WORD2_M0UM_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGD2_WORD2_M0SM(_n)                  (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD2_WORD2_M0SM_INSERT(_v, _n)           (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD2_WORD2_M0SM_EXTRACT(_v)              (((_v) >> 3) & 0x3)
#define   MPU_RGD2_WORD2_M0SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD2_WORD2_M0SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD2_WORD2_M0SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD2_WORD2_M0SM_11                 (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGD2_WORD2_M0PE                      ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier enable
#define   MPU_RGD2_WORD2_M0PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD2_WORD2_M0PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGD2_WORD2_M1UM(_n)                  (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD2_WORD2_M1UM_INSERT(_v, _n)           (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD2_WORD2_M1UM_EXTRACT(_v)              (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGD2_WORD2_M1SM(_n)                  (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD2_WORD2_M1SM_INSERT(_v, _n)           (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD2_WORD2_M1SM_EXTRACT(_v)              (((_v) >> 9) & 0x3)
#define   MPU_RGD2_WORD2_M1SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD2_WORD2_M1SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD2_WORD2_M1SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD2_WORD2_M1SM_11                 (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGD2_WORD2_M1PE                      ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier enable
#define   MPU_RGD2_WORD2_M1PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD2_WORD2_M1PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access control
#define MPU_RGD2_WORD2_M2UM(_n)                  (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD2_WORD2_M2UM_INSERT(_v, _n)           (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD2_WORD2_M2UM_EXTRACT(_v)              (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGD2_WORD2_M2SM(_n)                  (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD2_WORD2_M2SM_INSERT(_v, _n)           (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD2_WORD2_M2SM_EXTRACT(_v)              (((_v) >> 15) & 0x3)
#define   MPU_RGD2_WORD2_M2SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD2_WORD2_M2SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD2_WORD2_M2SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD2_WORD2_M2SM_11                 (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGD2_WORD2_M3UM(_n)                  (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD2_WORD2_M3UM_INSERT(_v, _n)           (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD2_WORD2_M3UM_EXTRACT(_v)              (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGD2_WORD2_M3SM(_n)                  (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD2_WORD2_M3SM_INSERT(_v, _n)           (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD2_WORD2_M3SM_EXTRACT(_v)              (((_v) >> 21) & 0x3)
#define   MPU_RGD2_WORD2_M3SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD2_WORD2_M3SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD2_WORD2_M3SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD2_WORD2_M3SM_11                 (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGD2_WORD2_M4WE                      ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGD2_WORD2_M4WE_0                  (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGD2_WORD2_M4WE_1                  (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGD2_WORD2_M4RE                      ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGD2_WORD2_M4RE_0                  (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGD2_WORD2_M4RE_1                  (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGD2_WORD2_M5WE                      ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGD2_WORD2_M5WE_0                  (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGD2_WORD2_M5WE_1                  (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGD2_WORD2_M5RE                      ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGD2_WORD2_M5RE_0                  (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGD2_WORD2_M5RE_1                  (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGD2_WORD2_M6WE                      ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGD2_WORD2_M6WE_0                  (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGD2_WORD2_M6WE_1                  (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGD2_WORD2_M6RE                      ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGD2_WORD2_M6RE_0                  (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGD2_WORD2_M6RE_1                  (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGD2_WORD2_M7WE                      ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGD2_WORD2_M7WE_0                  (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGD2_WORD2_M7WE_1                  (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGD2_WORD2_M7RE                      ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGD2_WORD2_M7RE_0                  (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGD2_WORD2_M7RE_1                  (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGD2_WORD3;                                    // Region Descriptor 2, Word 3
#define MPU_RGD2_WORD3_VLD                       ((uint32_t)1 << 0)     // Valid
#define   MPU_RGD2_WORD3_VLD_0                   (uint32_t)0x0          // Region descriptor is invalid
#define   MPU_RGD2_WORD3_VLD_1                   (uint32_t)0x1          // Region descriptor is valid
                                                                        // Process Identifier Mask
#define MPU_RGD2_WORD3_PIDMASK(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD2_WORD3_PIDMASK_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD2_WORD3_PIDMASK_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Process Identifier
#define MPU_RGD2_WORD3_PID(_n)                   (((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD2_WORD3_PID_INSERT(_v, _n)            (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD2_WORD3_PID_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    uint32_t             RGD3_WORD0;                                    // Region Descriptor 3, Word 0
                                                                        // Start Address
#define MPU_RGD3_WORD0_SRTADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD3_WORD0_SRTADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD3_WORD0_SRTADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD3_WORD1;                                    // Region Descriptor 3, Word 1
                                                                        // End Address
#define MPU_RGD3_WORD1_ENDADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD3_WORD1_ENDADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD3_WORD1_ENDADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD3_WORD2;                                    // Region Descriptor 3, Word 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGD3_WORD2_M0UM(_n)                  (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD3_WORD2_M0UM_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD3_WORD2_M0UM_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGD3_WORD2_M0SM(_n)                  (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD3_WORD2_M0SM_INSERT(_v, _n)           (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD3_WORD2_M0SM_EXTRACT(_v)              (((_v) >> 3) & 0x3)
#define   MPU_RGD3_WORD2_M0SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD3_WORD2_M0SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD3_WORD2_M0SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD3_WORD2_M0SM_11                 (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGD3_WORD2_M0PE                      ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier enable
#define   MPU_RGD3_WORD2_M0PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD3_WORD2_M0PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGD3_WORD2_M1UM(_n)                  (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD3_WORD2_M1UM_INSERT(_v, _n)           (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD3_WORD2_M1UM_EXTRACT(_v)              (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGD3_WORD2_M1SM(_n)                  (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD3_WORD2_M1SM_INSERT(_v, _n)           (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD3_WORD2_M1SM_EXTRACT(_v)              (((_v) >> 9) & 0x3)
#define   MPU_RGD3_WORD2_M1SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD3_WORD2_M1SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD3_WORD2_M1SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD3_WORD2_M1SM_11                 (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGD3_WORD2_M1PE                      ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier enable
#define   MPU_RGD3_WORD2_M1PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD3_WORD2_M1PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access control
#define MPU_RGD3_WORD2_M2UM(_n)                  (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD3_WORD2_M2UM_INSERT(_v, _n)           (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD3_WORD2_M2UM_EXTRACT(_v)              (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGD3_WORD2_M2SM(_n)                  (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD3_WORD2_M2SM_INSERT(_v, _n)           (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD3_WORD2_M2SM_EXTRACT(_v)              (((_v) >> 15) & 0x3)
#define   MPU_RGD3_WORD2_M2SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD3_WORD2_M2SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD3_WORD2_M2SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD3_WORD2_M2SM_11                 (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGD3_WORD2_M3UM(_n)                  (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD3_WORD2_M3UM_INSERT(_v, _n)           (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD3_WORD2_M3UM_EXTRACT(_v)              (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGD3_WORD2_M3SM(_n)                  (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD3_WORD2_M3SM_INSERT(_v, _n)           (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD3_WORD2_M3SM_EXTRACT(_v)              (((_v) >> 21) & 0x3)
#define   MPU_RGD3_WORD2_M3SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD3_WORD2_M3SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD3_WORD2_M3SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD3_WORD2_M3SM_11                 (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGD3_WORD2_M4WE                      ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGD3_WORD2_M4WE_0                  (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGD3_WORD2_M4WE_1                  (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGD3_WORD2_M4RE                      ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGD3_WORD2_M4RE_0                  (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGD3_WORD2_M4RE_1                  (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGD3_WORD2_M5WE                      ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGD3_WORD2_M5WE_0                  (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGD3_WORD2_M5WE_1                  (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGD3_WORD2_M5RE                      ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGD3_WORD2_M5RE_0                  (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGD3_WORD2_M5RE_1                  (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGD3_WORD2_M6WE                      ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGD3_WORD2_M6WE_0                  (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGD3_WORD2_M6WE_1                  (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGD3_WORD2_M6RE                      ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGD3_WORD2_M6RE_0                  (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGD3_WORD2_M6RE_1                  (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGD3_WORD2_M7WE                      ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGD3_WORD2_M7WE_0                  (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGD3_WORD2_M7WE_1                  (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGD3_WORD2_M7RE                      ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGD3_WORD2_M7RE_0                  (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGD3_WORD2_M7RE_1                  (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGD3_WORD3;                                    // Region Descriptor 3, Word 3
#define MPU_RGD3_WORD3_VLD                       ((uint32_t)1 << 0)     // Valid
#define   MPU_RGD3_WORD3_VLD_0                   (uint32_t)0x0          // Region descriptor is invalid
#define   MPU_RGD3_WORD3_VLD_1                   (uint32_t)0x1          // Region descriptor is valid
                                                                        // Process Identifier Mask
#define MPU_RGD3_WORD3_PIDMASK(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD3_WORD3_PIDMASK_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD3_WORD3_PIDMASK_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Process Identifier
#define MPU_RGD3_WORD3_PID(_n)                   (((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD3_WORD3_PID_INSERT(_v, _n)            (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD3_WORD3_PID_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    uint32_t             RGD4_WORD0;                                    // Region Descriptor 4, Word 0
                                                                        // Start Address
#define MPU_RGD4_WORD0_SRTADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD4_WORD0_SRTADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD4_WORD0_SRTADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD4_WORD1;                                    // Region Descriptor 4, Word 1
                                                                        // End Address
#define MPU_RGD4_WORD1_ENDADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD4_WORD1_ENDADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD4_WORD1_ENDADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD4_WORD2;                                    // Region Descriptor 4, Word 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGD4_WORD2_M0UM(_n)                  (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD4_WORD2_M0UM_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD4_WORD2_M0UM_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGD4_WORD2_M0SM(_n)                  (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD4_WORD2_M0SM_INSERT(_v, _n)           (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD4_WORD2_M0SM_EXTRACT(_v)              (((_v) >> 3) & 0x3)
#define   MPU_RGD4_WORD2_M0SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD4_WORD2_M0SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD4_WORD2_M0SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD4_WORD2_M0SM_11                 (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGD4_WORD2_M0PE                      ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier enable
#define   MPU_RGD4_WORD2_M0PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD4_WORD2_M0PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGD4_WORD2_M1UM(_n)                  (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD4_WORD2_M1UM_INSERT(_v, _n)           (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD4_WORD2_M1UM_EXTRACT(_v)              (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGD4_WORD2_M1SM(_n)                  (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD4_WORD2_M1SM_INSERT(_v, _n)           (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD4_WORD2_M1SM_EXTRACT(_v)              (((_v) >> 9) & 0x3)
#define   MPU_RGD4_WORD2_M1SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD4_WORD2_M1SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD4_WORD2_M1SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD4_WORD2_M1SM_11                 (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGD4_WORD2_M1PE                      ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier enable
#define   MPU_RGD4_WORD2_M1PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD4_WORD2_M1PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access control
#define MPU_RGD4_WORD2_M2UM(_n)                  (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD4_WORD2_M2UM_INSERT(_v, _n)           (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD4_WORD2_M2UM_EXTRACT(_v)              (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGD4_WORD2_M2SM(_n)                  (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD4_WORD2_M2SM_INSERT(_v, _n)           (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD4_WORD2_M2SM_EXTRACT(_v)              (((_v) >> 15) & 0x3)
#define   MPU_RGD4_WORD2_M2SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD4_WORD2_M2SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD4_WORD2_M2SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD4_WORD2_M2SM_11                 (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGD4_WORD2_M3UM(_n)                  (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD4_WORD2_M3UM_INSERT(_v, _n)           (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD4_WORD2_M3UM_EXTRACT(_v)              (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGD4_WORD2_M3SM(_n)                  (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD4_WORD2_M3SM_INSERT(_v, _n)           (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD4_WORD2_M3SM_EXTRACT(_v)              (((_v) >> 21) & 0x3)
#define   MPU_RGD4_WORD2_M3SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD4_WORD2_M3SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD4_WORD2_M3SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD4_WORD2_M3SM_11                 (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGD4_WORD2_M4WE                      ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGD4_WORD2_M4WE_0                  (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGD4_WORD2_M4WE_1                  (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGD4_WORD2_M4RE                      ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGD4_WORD2_M4RE_0                  (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGD4_WORD2_M4RE_1                  (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGD4_WORD2_M5WE                      ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGD4_WORD2_M5WE_0                  (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGD4_WORD2_M5WE_1                  (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGD4_WORD2_M5RE                      ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGD4_WORD2_M5RE_0                  (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGD4_WORD2_M5RE_1                  (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGD4_WORD2_M6WE                      ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGD4_WORD2_M6WE_0                  (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGD4_WORD2_M6WE_1                  (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGD4_WORD2_M6RE                      ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGD4_WORD2_M6RE_0                  (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGD4_WORD2_M6RE_1                  (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGD4_WORD2_M7WE                      ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGD4_WORD2_M7WE_0                  (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGD4_WORD2_M7WE_1                  (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGD4_WORD2_M7RE                      ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGD4_WORD2_M7RE_0                  (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGD4_WORD2_M7RE_1                  (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGD4_WORD3;                                    // Region Descriptor 4, Word 3
#define MPU_RGD4_WORD3_VLD                       ((uint32_t)1 << 0)     // Valid
#define   MPU_RGD4_WORD3_VLD_0                   (uint32_t)0x0          // Region descriptor is invalid
#define   MPU_RGD4_WORD3_VLD_1                   (uint32_t)0x1          // Region descriptor is valid
                                                                        // Process Identifier Mask
#define MPU_RGD4_WORD3_PIDMASK(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD4_WORD3_PIDMASK_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD4_WORD3_PIDMASK_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Process Identifier
#define MPU_RGD4_WORD3_PID(_n)                   (((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD4_WORD3_PID_INSERT(_v, _n)            (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD4_WORD3_PID_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    uint32_t             RGD5_WORD0;                                    // Region Descriptor 5, Word 0
                                                                        // Start Address
#define MPU_RGD5_WORD0_SRTADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD5_WORD0_SRTADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD5_WORD0_SRTADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD5_WORD1;                                    // Region Descriptor 5, Word 1
                                                                        // End Address
#define MPU_RGD5_WORD1_ENDADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD5_WORD1_ENDADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD5_WORD1_ENDADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD5_WORD2;                                    // Region Descriptor 5, Word 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGD5_WORD2_M0UM(_n)                  (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD5_WORD2_M0UM_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD5_WORD2_M0UM_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGD5_WORD2_M0SM(_n)                  (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD5_WORD2_M0SM_INSERT(_v, _n)           (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD5_WORD2_M0SM_EXTRACT(_v)              (((_v) >> 3) & 0x3)
#define   MPU_RGD5_WORD2_M0SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD5_WORD2_M0SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD5_WORD2_M0SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD5_WORD2_M0SM_11                 (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGD5_WORD2_M0PE                      ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier enable
#define   MPU_RGD5_WORD2_M0PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD5_WORD2_M0PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGD5_WORD2_M1UM(_n)                  (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD5_WORD2_M1UM_INSERT(_v, _n)           (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD5_WORD2_M1UM_EXTRACT(_v)              (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGD5_WORD2_M1SM(_n)                  (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD5_WORD2_M1SM_INSERT(_v, _n)           (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD5_WORD2_M1SM_EXTRACT(_v)              (((_v) >> 9) & 0x3)
#define   MPU_RGD5_WORD2_M1SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD5_WORD2_M1SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD5_WORD2_M1SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD5_WORD2_M1SM_11                 (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGD5_WORD2_M1PE                      ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier enable
#define   MPU_RGD5_WORD2_M1PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD5_WORD2_M1PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access control
#define MPU_RGD5_WORD2_M2UM(_n)                  (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD5_WORD2_M2UM_INSERT(_v, _n)           (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD5_WORD2_M2UM_EXTRACT(_v)              (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGD5_WORD2_M2SM(_n)                  (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD5_WORD2_M2SM_INSERT(_v, _n)           (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD5_WORD2_M2SM_EXTRACT(_v)              (((_v) >> 15) & 0x3)
#define   MPU_RGD5_WORD2_M2SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD5_WORD2_M2SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD5_WORD2_M2SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD5_WORD2_M2SM_11                 (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGD5_WORD2_M3UM(_n)                  (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD5_WORD2_M3UM_INSERT(_v, _n)           (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD5_WORD2_M3UM_EXTRACT(_v)              (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGD5_WORD2_M3SM(_n)                  (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD5_WORD2_M3SM_INSERT(_v, _n)           (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD5_WORD2_M3SM_EXTRACT(_v)              (((_v) >> 21) & 0x3)
#define   MPU_RGD5_WORD2_M3SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD5_WORD2_M3SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD5_WORD2_M3SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD5_WORD2_M3SM_11                 (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGD5_WORD2_M4WE                      ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGD5_WORD2_M4WE_0                  (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGD5_WORD2_M4WE_1                  (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGD5_WORD2_M4RE                      ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGD5_WORD2_M4RE_0                  (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGD5_WORD2_M4RE_1                  (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGD5_WORD2_M5WE                      ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGD5_WORD2_M5WE_0                  (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGD5_WORD2_M5WE_1                  (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGD5_WORD2_M5RE                      ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGD5_WORD2_M5RE_0                  (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGD5_WORD2_M5RE_1                  (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGD5_WORD2_M6WE                      ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGD5_WORD2_M6WE_0                  (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGD5_WORD2_M6WE_1                  (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGD5_WORD2_M6RE                      ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGD5_WORD2_M6RE_0                  (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGD5_WORD2_M6RE_1                  (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGD5_WORD2_M7WE                      ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGD5_WORD2_M7WE_0                  (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGD5_WORD2_M7WE_1                  (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGD5_WORD2_M7RE                      ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGD5_WORD2_M7RE_0                  (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGD5_WORD2_M7RE_1                  (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGD5_WORD3;                                    // Region Descriptor 5, Word 3
#define MPU_RGD5_WORD3_VLD                       ((uint32_t)1 << 0)     // Valid
#define   MPU_RGD5_WORD3_VLD_0                   (uint32_t)0x0          // Region descriptor is invalid
#define   MPU_RGD5_WORD3_VLD_1                   (uint32_t)0x1          // Region descriptor is valid
                                                                        // Process Identifier Mask
#define MPU_RGD5_WORD3_PIDMASK(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD5_WORD3_PIDMASK_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD5_WORD3_PIDMASK_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Process Identifier
#define MPU_RGD5_WORD3_PID(_n)                   (((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD5_WORD3_PID_INSERT(_v, _n)            (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD5_WORD3_PID_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    uint32_t             RGD6_WORD0;                                    // Region Descriptor 6, Word 0
                                                                        // Start Address
#define MPU_RGD6_WORD0_SRTADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD6_WORD0_SRTADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD6_WORD0_SRTADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD6_WORD1;                                    // Region Descriptor 6, Word 1
                                                                        // End Address
#define MPU_RGD6_WORD1_ENDADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD6_WORD1_ENDADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD6_WORD1_ENDADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD6_WORD2;                                    // Region Descriptor 6, Word 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGD6_WORD2_M0UM(_n)                  (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD6_WORD2_M0UM_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD6_WORD2_M0UM_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGD6_WORD2_M0SM(_n)                  (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD6_WORD2_M0SM_INSERT(_v, _n)           (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD6_WORD2_M0SM_EXTRACT(_v)              (((_v) >> 3) & 0x3)
#define   MPU_RGD6_WORD2_M0SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD6_WORD2_M0SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD6_WORD2_M0SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD6_WORD2_M0SM_11                 (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGD6_WORD2_M0PE                      ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier enable
#define   MPU_RGD6_WORD2_M0PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD6_WORD2_M0PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGD6_WORD2_M1UM(_n)                  (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD6_WORD2_M1UM_INSERT(_v, _n)           (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD6_WORD2_M1UM_EXTRACT(_v)              (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGD6_WORD2_M1SM(_n)                  (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD6_WORD2_M1SM_INSERT(_v, _n)           (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD6_WORD2_M1SM_EXTRACT(_v)              (((_v) >> 9) & 0x3)
#define   MPU_RGD6_WORD2_M1SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD6_WORD2_M1SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD6_WORD2_M1SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD6_WORD2_M1SM_11                 (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGD6_WORD2_M1PE                      ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier enable
#define   MPU_RGD6_WORD2_M1PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD6_WORD2_M1PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access control
#define MPU_RGD6_WORD2_M2UM(_n)                  (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD6_WORD2_M2UM_INSERT(_v, _n)           (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD6_WORD2_M2UM_EXTRACT(_v)              (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGD6_WORD2_M2SM(_n)                  (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD6_WORD2_M2SM_INSERT(_v, _n)           (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD6_WORD2_M2SM_EXTRACT(_v)              (((_v) >> 15) & 0x3)
#define   MPU_RGD6_WORD2_M2SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD6_WORD2_M2SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD6_WORD2_M2SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD6_WORD2_M2SM_11                 (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGD6_WORD2_M3UM(_n)                  (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD6_WORD2_M3UM_INSERT(_v, _n)           (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD6_WORD2_M3UM_EXTRACT(_v)              (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGD6_WORD2_M3SM(_n)                  (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD6_WORD2_M3SM_INSERT(_v, _n)           (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD6_WORD2_M3SM_EXTRACT(_v)              (((_v) >> 21) & 0x3)
#define   MPU_RGD6_WORD2_M3SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD6_WORD2_M3SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD6_WORD2_M3SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD6_WORD2_M3SM_11                 (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGD6_WORD2_M4WE                      ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGD6_WORD2_M4WE_0                  (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGD6_WORD2_M4WE_1                  (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGD6_WORD2_M4RE                      ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGD6_WORD2_M4RE_0                  (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGD6_WORD2_M4RE_1                  (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGD6_WORD2_M5WE                      ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGD6_WORD2_M5WE_0                  (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGD6_WORD2_M5WE_1                  (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGD6_WORD2_M5RE                      ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGD6_WORD2_M5RE_0                  (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGD6_WORD2_M5RE_1                  (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGD6_WORD2_M6WE                      ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGD6_WORD2_M6WE_0                  (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGD6_WORD2_M6WE_1                  (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGD6_WORD2_M6RE                      ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGD6_WORD2_M6RE_0                  (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGD6_WORD2_M6RE_1                  (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGD6_WORD2_M7WE                      ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGD6_WORD2_M7WE_0                  (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGD6_WORD2_M7WE_1                  (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGD6_WORD2_M7RE                      ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGD6_WORD2_M7RE_0                  (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGD6_WORD2_M7RE_1                  (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGD6_WORD3;                                    // Region Descriptor 6, Word 3
#define MPU_RGD6_WORD3_VLD                       ((uint32_t)1 << 0)     // Valid
#define   MPU_RGD6_WORD3_VLD_0                   (uint32_t)0x0          // Region descriptor is invalid
#define   MPU_RGD6_WORD3_VLD_1                   (uint32_t)0x1          // Region descriptor is valid
                                                                        // Process Identifier Mask
#define MPU_RGD6_WORD3_PIDMASK(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD6_WORD3_PIDMASK_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD6_WORD3_PIDMASK_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Process Identifier
#define MPU_RGD6_WORD3_PID(_n)                   (((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD6_WORD3_PID_INSERT(_v, _n)            (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD6_WORD3_PID_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    uint32_t             RGD7_WORD0;                                    // Region Descriptor 7, Word 0
                                                                        // Start Address
#define MPU_RGD7_WORD0_SRTADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD7_WORD0_SRTADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD7_WORD0_SRTADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD7_WORD1;                                    // Region Descriptor 7, Word 1
                                                                        // End Address
#define MPU_RGD7_WORD1_ENDADDR(_n)               (((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD7_WORD1_ENDADDR_INSERT(_v, _n)        (((_v) & ~0xffffffe0) | ((uint32_t)(_n) & 0x7ffffff) << 5)
#define MPU_RGD7_WORD1_ENDADDR_EXTRACT(_v)           (((_v) >> 5) & 0x7ffffff)

    uint32_t             RGD7_WORD2;                                    // Region Descriptor 7, Word 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGD7_WORD2_M0UM(_n)                  (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD7_WORD2_M0UM_INSERT(_v, _n)           (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGD7_WORD2_M0UM_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGD7_WORD2_M0SM(_n)                  (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD7_WORD2_M0SM_INSERT(_v, _n)           (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGD7_WORD2_M0SM_EXTRACT(_v)              (((_v) >> 3) & 0x3)
#define   MPU_RGD7_WORD2_M0SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD7_WORD2_M0SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD7_WORD2_M0SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD7_WORD2_M0SM_11                 (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGD7_WORD2_M0PE                      ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier enable
#define   MPU_RGD7_WORD2_M0PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD7_WORD2_M0PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGD7_WORD2_M1UM(_n)                  (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD7_WORD2_M1UM_INSERT(_v, _n)           (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGD7_WORD2_M1UM_EXTRACT(_v)              (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGD7_WORD2_M1SM(_n)                  (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD7_WORD2_M1SM_INSERT(_v, _n)           (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGD7_WORD2_M1SM_EXTRACT(_v)              (((_v) >> 9) & 0x3)
#define   MPU_RGD7_WORD2_M1SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD7_WORD2_M1SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD7_WORD2_M1SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD7_WORD2_M1SM_11                 (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGD7_WORD2_M1PE                      ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier enable
#define   MPU_RGD7_WORD2_M1PE_0                  (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGD7_WORD2_M1PE_1                  (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access control
#define MPU_RGD7_WORD2_M2UM(_n)                  (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD7_WORD2_M2UM_INSERT(_v, _n)           (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGD7_WORD2_M2UM_EXTRACT(_v)              (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGD7_WORD2_M2SM(_n)                  (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD7_WORD2_M2SM_INSERT(_v, _n)           (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGD7_WORD2_M2SM_EXTRACT(_v)              (((_v) >> 15) & 0x3)
#define   MPU_RGD7_WORD2_M2SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD7_WORD2_M2SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD7_WORD2_M2SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD7_WORD2_M2SM_11                 (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGD7_WORD2_M3UM(_n)                  (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD7_WORD2_M3UM_INSERT(_v, _n)           (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGD7_WORD2_M3UM_EXTRACT(_v)              (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGD7_WORD2_M3SM(_n)                  (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD7_WORD2_M3SM_INSERT(_v, _n)           (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGD7_WORD2_M3SM_EXTRACT(_v)              (((_v) >> 21) & 0x3)
#define   MPU_RGD7_WORD2_M3SM_0                  (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGD7_WORD2_M3SM_1                  (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGD7_WORD2_M3SM_10                 (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGD7_WORD2_M3SM_11                 (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGD7_WORD2_M4WE                      ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGD7_WORD2_M4WE_0                  (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGD7_WORD2_M4WE_1                  (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGD7_WORD2_M4RE                      ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGD7_WORD2_M4RE_0                  (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGD7_WORD2_M4RE_1                  (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGD7_WORD2_M5WE                      ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGD7_WORD2_M5WE_0                  (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGD7_WORD2_M5WE_1                  (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGD7_WORD2_M5RE                      ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGD7_WORD2_M5RE_0                  (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGD7_WORD2_M5RE_1                  (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGD7_WORD2_M6WE                      ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGD7_WORD2_M6WE_0                  (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGD7_WORD2_M6WE_1                  (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGD7_WORD2_M6RE                      ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGD7_WORD2_M6RE_0                  (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGD7_WORD2_M6RE_1                  (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGD7_WORD2_M7WE                      ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGD7_WORD2_M7WE_0                  (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGD7_WORD2_M7WE_1                  (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGD7_WORD2_M7RE                      ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGD7_WORD2_M7RE_0                  (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGD7_WORD2_M7RE_1                  (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGD7_WORD3;                                    // Region Descriptor 7, Word 3
#define MPU_RGD7_WORD3_VLD                       ((uint32_t)1 << 0)     // Valid
#define   MPU_RGD7_WORD3_VLD_0                   (uint32_t)0x0          // Region descriptor is invalid
#define   MPU_RGD7_WORD3_VLD_1                   (uint32_t)0x1          // Region descriptor is valid
                                                                        // Process Identifier Mask
#define MPU_RGD7_WORD3_PIDMASK(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD7_WORD3_PIDMASK_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MPU_RGD7_WORD3_PIDMASK_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Process Identifier
#define MPU_RGD7_WORD3_PID(_n)                   (((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD7_WORD3_PID_INSERT(_v, _n)            (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define MPU_RGD7_WORD3_PID_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    uint8_t _res2[896];
    uint32_t             RGDAAC0;                                       // Region Descriptor Alternate Access Control 0
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGDAAC0_M0UM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC0_M0UM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC0_M0UM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGDAAC0_M0SM(_n)                     (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC0_M0SM_INSERT(_v, _n)              (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC0_M0SM_EXTRACT(_v)                 (((_v) >> 3) & 0x3)
#define   MPU_RGDAAC0_M0SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC0_M0SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC0_M0SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC0_M0SM_11                    (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGDAAC0_M0PE                         ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier Enable
#define   MPU_RGDAAC0_M0PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC0_M0PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGDAAC0_M1UM(_n)                     (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC0_M1UM_INSERT(_v, _n)              (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC0_M1UM_EXTRACT(_v)                 (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGDAAC0_M1SM(_n)                     (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC0_M1SM_INSERT(_v, _n)              (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC0_M1SM_EXTRACT(_v)                 (((_v) >> 9) & 0x3)
#define   MPU_RGDAAC0_M1SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC0_M1SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC0_M1SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC0_M1SM_11                    (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGDAAC0_M1PE                         ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier Enable
#define   MPU_RGDAAC0_M1PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC0_M1PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access Control
#define MPU_RGDAAC0_M2UM(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC0_M2UM_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC0_M2UM_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGDAAC0_M2SM(_n)                     (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC0_M2SM_INSERT(_v, _n)              (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC0_M2SM_EXTRACT(_v)                 (((_v) >> 15) & 0x3)
#define   MPU_RGDAAC0_M2SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC0_M2SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC0_M2SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC0_M2SM_11                    (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGDAAC0_M3UM(_n)                     (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC0_M3UM_INSERT(_v, _n)              (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC0_M3UM_EXTRACT(_v)                 (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGDAAC0_M3SM(_n)                     (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC0_M3SM_INSERT(_v, _n)              (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC0_M3SM_EXTRACT(_v)                 (((_v) >> 21) & 0x3)
#define   MPU_RGDAAC0_M3SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC0_M3SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC0_M3SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC0_M3SM_11                    (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGDAAC0_M4WE                         ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGDAAC0_M4WE_0                     (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC0_M4WE_1                     (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGDAAC0_M4RE                         ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGDAAC0_M4RE_0                     (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC0_M4RE_1                     (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGDAAC0_M5WE                         ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGDAAC0_M5WE_0                     (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC0_M5WE_1                     (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGDAAC0_M5RE                         ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGDAAC0_M5RE_0                     (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC0_M5RE_1                     (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGDAAC0_M6WE                         ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGDAAC0_M6WE_0                     (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC0_M6WE_1                     (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGDAAC0_M6RE                         ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGDAAC0_M6RE_0                     (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC0_M6RE_1                     (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGDAAC0_M7WE                         ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGDAAC0_M7WE_0                     (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC0_M7WE_1                     (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGDAAC0_M7RE                         ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGDAAC0_M7RE_0                     (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC0_M7RE_1                     (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGDAAC1;                                       // Region Descriptor Alternate Access Control 1
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGDAAC1_M0UM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC1_M0UM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC1_M0UM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGDAAC1_M0SM(_n)                     (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC1_M0SM_INSERT(_v, _n)              (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC1_M0SM_EXTRACT(_v)                 (((_v) >> 3) & 0x3)
#define   MPU_RGDAAC1_M0SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC1_M0SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC1_M0SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC1_M0SM_11                    (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGDAAC1_M0PE                         ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier Enable
#define   MPU_RGDAAC1_M0PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC1_M0PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGDAAC1_M1UM(_n)                     (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC1_M1UM_INSERT(_v, _n)              (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC1_M1UM_EXTRACT(_v)                 (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGDAAC1_M1SM(_n)                     (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC1_M1SM_INSERT(_v, _n)              (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC1_M1SM_EXTRACT(_v)                 (((_v) >> 9) & 0x3)
#define   MPU_RGDAAC1_M1SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC1_M1SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC1_M1SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC1_M1SM_11                    (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGDAAC1_M1PE                         ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier Enable
#define   MPU_RGDAAC1_M1PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC1_M1PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access Control
#define MPU_RGDAAC1_M2UM(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC1_M2UM_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC1_M2UM_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGDAAC1_M2SM(_n)                     (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC1_M2SM_INSERT(_v, _n)              (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC1_M2SM_EXTRACT(_v)                 (((_v) >> 15) & 0x3)
#define   MPU_RGDAAC1_M2SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC1_M2SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC1_M2SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC1_M2SM_11                    (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGDAAC1_M3UM(_n)                     (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC1_M3UM_INSERT(_v, _n)              (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC1_M3UM_EXTRACT(_v)                 (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGDAAC1_M3SM(_n)                     (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC1_M3SM_INSERT(_v, _n)              (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC1_M3SM_EXTRACT(_v)                 (((_v) >> 21) & 0x3)
#define   MPU_RGDAAC1_M3SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC1_M3SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC1_M3SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC1_M3SM_11                    (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGDAAC1_M4WE                         ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGDAAC1_M4WE_0                     (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC1_M4WE_1                     (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGDAAC1_M4RE                         ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGDAAC1_M4RE_0                     (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC1_M4RE_1                     (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGDAAC1_M5WE                         ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGDAAC1_M5WE_0                     (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC1_M5WE_1                     (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGDAAC1_M5RE                         ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGDAAC1_M5RE_0                     (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC1_M5RE_1                     (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGDAAC1_M6WE                         ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGDAAC1_M6WE_0                     (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC1_M6WE_1                     (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGDAAC1_M6RE                         ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGDAAC1_M6RE_0                     (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC1_M6RE_1                     (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGDAAC1_M7WE                         ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGDAAC1_M7WE_0                     (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC1_M7WE_1                     (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGDAAC1_M7RE                         ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGDAAC1_M7RE_0                     (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC1_M7RE_1                     (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGDAAC2;                                       // Region Descriptor Alternate Access Control 2
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGDAAC2_M0UM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC2_M0UM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC2_M0UM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGDAAC2_M0SM(_n)                     (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC2_M0SM_INSERT(_v, _n)              (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC2_M0SM_EXTRACT(_v)                 (((_v) >> 3) & 0x3)
#define   MPU_RGDAAC2_M0SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC2_M0SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC2_M0SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC2_M0SM_11                    (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGDAAC2_M0PE                         ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier Enable
#define   MPU_RGDAAC2_M0PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC2_M0PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGDAAC2_M1UM(_n)                     (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC2_M1UM_INSERT(_v, _n)              (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC2_M1UM_EXTRACT(_v)                 (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGDAAC2_M1SM(_n)                     (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC2_M1SM_INSERT(_v, _n)              (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC2_M1SM_EXTRACT(_v)                 (((_v) >> 9) & 0x3)
#define   MPU_RGDAAC2_M1SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC2_M1SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC2_M1SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC2_M1SM_11                    (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGDAAC2_M1PE                         ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier Enable
#define   MPU_RGDAAC2_M1PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC2_M1PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access Control
#define MPU_RGDAAC2_M2UM(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC2_M2UM_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC2_M2UM_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGDAAC2_M2SM(_n)                     (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC2_M2SM_INSERT(_v, _n)              (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC2_M2SM_EXTRACT(_v)                 (((_v) >> 15) & 0x3)
#define   MPU_RGDAAC2_M2SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC2_M2SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC2_M2SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC2_M2SM_11                    (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGDAAC2_M3UM(_n)                     (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC2_M3UM_INSERT(_v, _n)              (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC2_M3UM_EXTRACT(_v)                 (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGDAAC2_M3SM(_n)                     (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC2_M3SM_INSERT(_v, _n)              (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC2_M3SM_EXTRACT(_v)                 (((_v) >> 21) & 0x3)
#define   MPU_RGDAAC2_M3SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC2_M3SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC2_M3SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC2_M3SM_11                    (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGDAAC2_M4WE                         ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGDAAC2_M4WE_0                     (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC2_M4WE_1                     (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGDAAC2_M4RE                         ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGDAAC2_M4RE_0                     (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC2_M4RE_1                     (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGDAAC2_M5WE                         ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGDAAC2_M5WE_0                     (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC2_M5WE_1                     (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGDAAC2_M5RE                         ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGDAAC2_M5RE_0                     (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC2_M5RE_1                     (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGDAAC2_M6WE                         ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGDAAC2_M6WE_0                     (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC2_M6WE_1                     (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGDAAC2_M6RE                         ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGDAAC2_M6RE_0                     (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC2_M6RE_1                     (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGDAAC2_M7WE                         ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGDAAC2_M7WE_0                     (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC2_M7WE_1                     (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGDAAC2_M7RE                         ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGDAAC2_M7RE_0                     (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC2_M7RE_1                     (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGDAAC3;                                       // Region Descriptor Alternate Access Control 3
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGDAAC3_M0UM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC3_M0UM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC3_M0UM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGDAAC3_M0SM(_n)                     (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC3_M0SM_INSERT(_v, _n)              (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC3_M0SM_EXTRACT(_v)                 (((_v) >> 3) & 0x3)
#define   MPU_RGDAAC3_M0SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC3_M0SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC3_M0SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC3_M0SM_11                    (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGDAAC3_M0PE                         ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier Enable
#define   MPU_RGDAAC3_M0PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC3_M0PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGDAAC3_M1UM(_n)                     (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC3_M1UM_INSERT(_v, _n)              (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC3_M1UM_EXTRACT(_v)                 (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGDAAC3_M1SM(_n)                     (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC3_M1SM_INSERT(_v, _n)              (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC3_M1SM_EXTRACT(_v)                 (((_v) >> 9) & 0x3)
#define   MPU_RGDAAC3_M1SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC3_M1SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC3_M1SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC3_M1SM_11                    (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGDAAC3_M1PE                         ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier Enable
#define   MPU_RGDAAC3_M1PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC3_M1PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access Control
#define MPU_RGDAAC3_M2UM(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC3_M2UM_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC3_M2UM_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGDAAC3_M2SM(_n)                     (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC3_M2SM_INSERT(_v, _n)              (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC3_M2SM_EXTRACT(_v)                 (((_v) >> 15) & 0x3)
#define   MPU_RGDAAC3_M2SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC3_M2SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC3_M2SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC3_M2SM_11                    (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGDAAC3_M3UM(_n)                     (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC3_M3UM_INSERT(_v, _n)              (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC3_M3UM_EXTRACT(_v)                 (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGDAAC3_M3SM(_n)                     (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC3_M3SM_INSERT(_v, _n)              (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC3_M3SM_EXTRACT(_v)                 (((_v) >> 21) & 0x3)
#define   MPU_RGDAAC3_M3SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC3_M3SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC3_M3SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC3_M3SM_11                    (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGDAAC3_M4WE                         ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGDAAC3_M4WE_0                     (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC3_M4WE_1                     (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGDAAC3_M4RE                         ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGDAAC3_M4RE_0                     (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC3_M4RE_1                     (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGDAAC3_M5WE                         ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGDAAC3_M5WE_0                     (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC3_M5WE_1                     (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGDAAC3_M5RE                         ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGDAAC3_M5RE_0                     (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC3_M5RE_1                     (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGDAAC3_M6WE                         ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGDAAC3_M6WE_0                     (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC3_M6WE_1                     (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGDAAC3_M6RE                         ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGDAAC3_M6RE_0                     (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC3_M6RE_1                     (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGDAAC3_M7WE                         ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGDAAC3_M7WE_0                     (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC3_M7WE_1                     (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGDAAC3_M7RE                         ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGDAAC3_M7RE_0                     (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC3_M7RE_1                     (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGDAAC4;                                       // Region Descriptor Alternate Access Control 4
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGDAAC4_M0UM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC4_M0UM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC4_M0UM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGDAAC4_M0SM(_n)                     (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC4_M0SM_INSERT(_v, _n)              (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC4_M0SM_EXTRACT(_v)                 (((_v) >> 3) & 0x3)
#define   MPU_RGDAAC4_M0SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC4_M0SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC4_M0SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC4_M0SM_11                    (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGDAAC4_M0PE                         ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier Enable
#define   MPU_RGDAAC4_M0PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC4_M0PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGDAAC4_M1UM(_n)                     (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC4_M1UM_INSERT(_v, _n)              (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC4_M1UM_EXTRACT(_v)                 (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGDAAC4_M1SM(_n)                     (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC4_M1SM_INSERT(_v, _n)              (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC4_M1SM_EXTRACT(_v)                 (((_v) >> 9) & 0x3)
#define   MPU_RGDAAC4_M1SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC4_M1SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC4_M1SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC4_M1SM_11                    (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGDAAC4_M1PE                         ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier Enable
#define   MPU_RGDAAC4_M1PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC4_M1PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access Control
#define MPU_RGDAAC4_M2UM(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC4_M2UM_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC4_M2UM_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGDAAC4_M2SM(_n)                     (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC4_M2SM_INSERT(_v, _n)              (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC4_M2SM_EXTRACT(_v)                 (((_v) >> 15) & 0x3)
#define   MPU_RGDAAC4_M2SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC4_M2SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC4_M2SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC4_M2SM_11                    (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGDAAC4_M3UM(_n)                     (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC4_M3UM_INSERT(_v, _n)              (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC4_M3UM_EXTRACT(_v)                 (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGDAAC4_M3SM(_n)                     (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC4_M3SM_INSERT(_v, _n)              (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC4_M3SM_EXTRACT(_v)                 (((_v) >> 21) & 0x3)
#define   MPU_RGDAAC4_M3SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC4_M3SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC4_M3SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC4_M3SM_11                    (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGDAAC4_M4WE                         ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGDAAC4_M4WE_0                     (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC4_M4WE_1                     (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGDAAC4_M4RE                         ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGDAAC4_M4RE_0                     (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC4_M4RE_1                     (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGDAAC4_M5WE                         ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGDAAC4_M5WE_0                     (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC4_M5WE_1                     (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGDAAC4_M5RE                         ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGDAAC4_M5RE_0                     (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC4_M5RE_1                     (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGDAAC4_M6WE                         ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGDAAC4_M6WE_0                     (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC4_M6WE_1                     (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGDAAC4_M6RE                         ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGDAAC4_M6RE_0                     (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC4_M6RE_1                     (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGDAAC4_M7WE                         ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGDAAC4_M7WE_0                     (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC4_M7WE_1                     (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGDAAC4_M7RE                         ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGDAAC4_M7RE_0                     (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC4_M7RE_1                     (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGDAAC5;                                       // Region Descriptor Alternate Access Control 5
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGDAAC5_M0UM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC5_M0UM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC5_M0UM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGDAAC5_M0SM(_n)                     (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC5_M0SM_INSERT(_v, _n)              (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC5_M0SM_EXTRACT(_v)                 (((_v) >> 3) & 0x3)
#define   MPU_RGDAAC5_M0SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC5_M0SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC5_M0SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC5_M0SM_11                    (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGDAAC5_M0PE                         ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier Enable
#define   MPU_RGDAAC5_M0PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC5_M0PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGDAAC5_M1UM(_n)                     (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC5_M1UM_INSERT(_v, _n)              (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC5_M1UM_EXTRACT(_v)                 (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGDAAC5_M1SM(_n)                     (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC5_M1SM_INSERT(_v, _n)              (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC5_M1SM_EXTRACT(_v)                 (((_v) >> 9) & 0x3)
#define   MPU_RGDAAC5_M1SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC5_M1SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC5_M1SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC5_M1SM_11                    (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGDAAC5_M1PE                         ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier Enable
#define   MPU_RGDAAC5_M1PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC5_M1PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access Control
#define MPU_RGDAAC5_M2UM(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC5_M2UM_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC5_M2UM_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGDAAC5_M2SM(_n)                     (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC5_M2SM_INSERT(_v, _n)              (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC5_M2SM_EXTRACT(_v)                 (((_v) >> 15) & 0x3)
#define   MPU_RGDAAC5_M2SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC5_M2SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC5_M2SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC5_M2SM_11                    (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGDAAC5_M3UM(_n)                     (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC5_M3UM_INSERT(_v, _n)              (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC5_M3UM_EXTRACT(_v)                 (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGDAAC5_M3SM(_n)                     (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC5_M3SM_INSERT(_v, _n)              (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC5_M3SM_EXTRACT(_v)                 (((_v) >> 21) & 0x3)
#define   MPU_RGDAAC5_M3SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC5_M3SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC5_M3SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC5_M3SM_11                    (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGDAAC5_M4WE                         ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGDAAC5_M4WE_0                     (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC5_M4WE_1                     (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGDAAC5_M4RE                         ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGDAAC5_M4RE_0                     (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC5_M4RE_1                     (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGDAAC5_M5WE                         ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGDAAC5_M5WE_0                     (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC5_M5WE_1                     (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGDAAC5_M5RE                         ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGDAAC5_M5RE_0                     (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC5_M5RE_1                     (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGDAAC5_M6WE                         ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGDAAC5_M6WE_0                     (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC5_M6WE_1                     (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGDAAC5_M6RE                         ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGDAAC5_M6RE_0                     (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC5_M6RE_1                     (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGDAAC5_M7WE                         ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGDAAC5_M7WE_0                     (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC5_M7WE_1                     (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGDAAC5_M7RE                         ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGDAAC5_M7RE_0                     (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC5_M7RE_1                     (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGDAAC6;                                       // Region Descriptor Alternate Access Control 6
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGDAAC6_M0UM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC6_M0UM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC6_M0UM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGDAAC6_M0SM(_n)                     (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC6_M0SM_INSERT(_v, _n)              (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC6_M0SM_EXTRACT(_v)                 (((_v) >> 3) & 0x3)
#define   MPU_RGDAAC6_M0SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC6_M0SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC6_M0SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC6_M0SM_11                    (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGDAAC6_M0PE                         ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier Enable
#define   MPU_RGDAAC6_M0PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC6_M0PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGDAAC6_M1UM(_n)                     (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC6_M1UM_INSERT(_v, _n)              (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC6_M1UM_EXTRACT(_v)                 (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGDAAC6_M1SM(_n)                     (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC6_M1SM_INSERT(_v, _n)              (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC6_M1SM_EXTRACT(_v)                 (((_v) >> 9) & 0x3)
#define   MPU_RGDAAC6_M1SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC6_M1SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC6_M1SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC6_M1SM_11                    (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGDAAC6_M1PE                         ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier Enable
#define   MPU_RGDAAC6_M1PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC6_M1PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access Control
#define MPU_RGDAAC6_M2UM(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC6_M2UM_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC6_M2UM_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGDAAC6_M2SM(_n)                     (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC6_M2SM_INSERT(_v, _n)              (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC6_M2SM_EXTRACT(_v)                 (((_v) >> 15) & 0x3)
#define   MPU_RGDAAC6_M2SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC6_M2SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC6_M2SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC6_M2SM_11                    (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGDAAC6_M3UM(_n)                     (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC6_M3UM_INSERT(_v, _n)              (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC6_M3UM_EXTRACT(_v)                 (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGDAAC6_M3SM(_n)                     (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC6_M3SM_INSERT(_v, _n)              (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC6_M3SM_EXTRACT(_v)                 (((_v) >> 21) & 0x3)
#define   MPU_RGDAAC6_M3SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC6_M3SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC6_M3SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC6_M3SM_11                    (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGDAAC6_M4WE                         ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGDAAC6_M4WE_0                     (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC6_M4WE_1                     (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGDAAC6_M4RE                         ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGDAAC6_M4RE_0                     (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC6_M4RE_1                     (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGDAAC6_M5WE                         ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGDAAC6_M5WE_0                     (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC6_M5WE_1                     (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGDAAC6_M5RE                         ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGDAAC6_M5RE_0                     (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC6_M5RE_1                     (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGDAAC6_M6WE                         ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGDAAC6_M6WE_0                     (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC6_M6WE_1                     (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGDAAC6_M6RE                         ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGDAAC6_M6RE_0                     (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC6_M6RE_1                     (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGDAAC6_M7WE                         ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGDAAC6_M7WE_0                     (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC6_M7WE_1                     (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGDAAC6_M7RE                         ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGDAAC6_M7RE_0                     (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC6_M7RE_1                     (uint32_t)0x1          // Bus master 7 reads allowed

    uint32_t             RGDAAC7;                                       // Region Descriptor Alternate Access Control 7
                                                                        // Bus Master 0 User Mode Access Control
#define MPU_RGDAAC7_M0UM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC7_M0UM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define MPU_RGDAAC7_M0UM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Bus Master 0 Supervisor Mode Access Control
#define MPU_RGDAAC7_M0SM(_n)                     (((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC7_M0SM_INSERT(_v, _n)              (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define MPU_RGDAAC7_M0SM_EXTRACT(_v)                 (((_v) >> 3) & 0x3)
#define   MPU_RGDAAC7_M0SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC7_M0SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC7_M0SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC7_M0SM_11                    (uint32_t)0x3          // Same as User mode defined in M0UM
#define MPU_RGDAAC7_M0PE                         ((uint32_t)1 << 5)     // Bus Master 0 Process Identifier Enable
#define   MPU_RGDAAC7_M0PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC7_M0PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 1 User Mode Access Control
#define MPU_RGDAAC7_M1UM(_n)                     (((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC7_M1UM_INSERT(_v, _n)              (((_v) & ~0x1c0) | ((uint32_t)(_n) & 0x7) << 6)
#define MPU_RGDAAC7_M1UM_EXTRACT(_v)                 (((_v) >> 6) & 0x7)
                                                                        // Bus Master 1 Supervisor Mode Access Control
#define MPU_RGDAAC7_M1SM(_n)                     (((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC7_M1SM_INSERT(_v, _n)              (((_v) & ~0x600) | ((uint32_t)(_n) & 0x3) << 9)
#define MPU_RGDAAC7_M1SM_EXTRACT(_v)                 (((_v) >> 9) & 0x3)
#define   MPU_RGDAAC7_M1SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC7_M1SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC7_M1SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC7_M1SM_11                    (uint32_t)0x3          // Same as User mode defined in M1UM
#define MPU_RGDAAC7_M1PE                         ((uint32_t)1 << 11)    // Bus Master 1 Process Identifier Enable
#define   MPU_RGDAAC7_M1PE_0                     (uint32_t)0x0          // Do not include the process identifier in the evaluation
#define   MPU_RGDAAC7_M1PE_1                     (uint32_t)0x1          // Include the process identifier and mask (RGDn.RGDAAC) in the region hit evaluation
                                                                        // Bus Master 2 User Mode Access Control
#define MPU_RGDAAC7_M2UM(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC7_M2UM_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define MPU_RGDAAC7_M2UM_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
                                                                        // Bus Master 2 Supervisor Mode Access Control
#define MPU_RGDAAC7_M2SM(_n)                     (((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC7_M2SM_INSERT(_v, _n)              (((_v) & ~0x18000) | ((uint32_t)(_n) & 0x3) << 15)
#define MPU_RGDAAC7_M2SM_EXTRACT(_v)                 (((_v) >> 15) & 0x3)
#define   MPU_RGDAAC7_M2SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC7_M2SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC7_M2SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC7_M2SM_11                    (uint32_t)0x3          // Same as User mode defined in M2UM
                                                                        // Bus Master 3 User Mode Access Control
#define MPU_RGDAAC7_M3UM(_n)                     (((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC7_M3UM_INSERT(_v, _n)              (((_v) & ~0x1c0000) | ((uint32_t)(_n) & 0x7) << 18)
#define MPU_RGDAAC7_M3UM_EXTRACT(_v)                 (((_v) >> 18) & 0x7)
                                                                        // Bus Master 3 Supervisor Mode Access Control
#define MPU_RGDAAC7_M3SM(_n)                     (((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC7_M3SM_INSERT(_v, _n)              (((_v) & ~0x600000) | ((uint32_t)(_n) & 0x3) << 21)
#define MPU_RGDAAC7_M3SM_EXTRACT(_v)                 (((_v) >> 21) & 0x3)
#define   MPU_RGDAAC7_M3SM_0                     (uint32_t)0x0          // r/w/x; read, write and execute allowed
#define   MPU_RGDAAC7_M3SM_1                     (uint32_t)0x1          // r/x; read and execute allowed, but no write
#define   MPU_RGDAAC7_M3SM_10                    (uint32_t)0x2          // r/w; read and write allowed, but no execute
#define   MPU_RGDAAC7_M3SM_11                    (uint32_t)0x3          // Same as User mode defined in M3UM
#define MPU_RGDAAC7_M4WE                         ((uint32_t)1 << 24)    // Bus Master 4 Write Enable
#define   MPU_RGDAAC7_M4WE_0                     (uint32_t)0x0          // Bus master 4 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC7_M4WE_1                     (uint32_t)0x1          // Bus master 4 writes allowed
#define MPU_RGDAAC7_M4RE                         ((uint32_t)1 << 25)    // Bus Master 4 Read Enable
#define   MPU_RGDAAC7_M4RE_0                     (uint32_t)0x0          // Bus master 4 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC7_M4RE_1                     (uint32_t)0x1          // Bus master 4 reads allowed
#define MPU_RGDAAC7_M5WE                         ((uint32_t)1 << 26)    // Bus Master 5 Write Enable
#define   MPU_RGDAAC7_M5WE_0                     (uint32_t)0x0          // Bus master 5 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC7_M5WE_1                     (uint32_t)0x1          // Bus master 5 writes allowed
#define MPU_RGDAAC7_M5RE                         ((uint32_t)1 << 27)    // Bus Master 5 Read Enable
#define   MPU_RGDAAC7_M5RE_0                     (uint32_t)0x0          // Bus master 5 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC7_M5RE_1                     (uint32_t)0x1          // Bus master 5 reads allowed
#define MPU_RGDAAC7_M6WE                         ((uint32_t)1 << 28)    // Bus Master 6 Write Enable
#define   MPU_RGDAAC7_M6WE_0                     (uint32_t)0x0          // Bus master 6 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC7_M6WE_1                     (uint32_t)0x1          // Bus master 6 writes allowed
#define MPU_RGDAAC7_M6RE                         ((uint32_t)1 << 29)    // Bus Master 6 Read Enable
#define   MPU_RGDAAC7_M6RE_0                     (uint32_t)0x0          // Bus master 6 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC7_M6RE_1                     (uint32_t)0x1          // Bus master 6 reads allowed
#define MPU_RGDAAC7_M7WE                         ((uint32_t)1 << 30)    // Bus Master 7 Write Enable
#define   MPU_RGDAAC7_M7WE_0                     (uint32_t)0x0          // Bus master 7 writes terminate with an access error and the write is not performed
#define   MPU_RGDAAC7_M7WE_1                     (uint32_t)0x1          // Bus master 7 writes allowed
#define MPU_RGDAAC7_M7RE                         ((uint32_t)1 << 31)    // Bus Master 7 Read Enable
#define   MPU_RGDAAC7_M7RE_0                     (uint32_t)0x0          // Bus master 7 reads terminate with an access error and the read is not performed
#define   MPU_RGDAAC7_M7RE_1                     (uint32_t)0x1          // Bus master 7 reads allowed

} MPU_regs_t;
                                                                        // --------------------
                                                                        // ERM
typedef struct                                                          // --------------------
{
    uint32_t             CR0;                                           // ERM Configuration Register 0
#define ERM_CR0_ENCIE1                           ((uint32_t)1 << 26)    // ENCIE1
#define   ERM_CR0_ENCIE1_0                       (uint32_t)0x0          // Interrupt notification of Memory 1 non-correctable error events is disabled.
#define   ERM_CR0_ENCIE1_1                       (uint32_t)0x1          // Interrupt notification of Memory 1 non-correctable error events is enabled.
#define ERM_CR0_ESCIE1                           ((uint32_t)1 << 27)    // ESCIE1
#define   ERM_CR0_ESCIE1_0                       (uint32_t)0x0          // Interrupt notification of Memory 1 single-bit correction events is disabled.
#define   ERM_CR0_ESCIE1_1                       (uint32_t)0x1          // Interrupt notification of Memory 1 single-bit correction events is enabled.
#define ERM_CR0_ENCIE0                           ((uint32_t)1 << 30)    // ENCIE0
#define   ERM_CR0_ENCIE0_0                       (uint32_t)0x0          // Interrupt notification of Memory 0 non-correctable error events is disabled.
#define   ERM_CR0_ENCIE0_1                       (uint32_t)0x1          // Interrupt notification of Memory 0 non-correctable error events is enabled.
#define ERM_CR0_ESCIE0                           ((uint32_t)1 << 31)    // ESCIE0
#define   ERM_CR0_ESCIE0_0                       (uint32_t)0x0          // Interrupt notification of Memory 0 single-bit correction events is disabled.
#define   ERM_CR0_ESCIE0_1                       (uint32_t)0x1          // Interrupt notification of Memory 0 single-bit correction events is enabled.

    uint8_t _res0[12];
    uint32_t             SR0;                                           // ERM Status Register 0
#define ERM_SR0_NCE1                             ((uint32_t)1 << 26)    // NCE1
#define   ERM_SR0_NCE1_0                         (uint32_t)0x0          // No non-correctable error event on Memory 1 detected
#define   ERM_SR0_NCE1_1                         (uint32_t)0x1          // Non-correctable error event on Memory 1 detected
#define ERM_SR0_SBC1                             ((uint32_t)1 << 27)    // SBC1
#define   ERM_SR0_SBC1_0                         (uint32_t)0x0          // No single-bit correction event on Memory 1 detected
#define   ERM_SR0_SBC1_1                         (uint32_t)0x1          // Single-bit correction event on Memory 1 detected
#define ERM_SR0_NCE0                             ((uint32_t)1 << 30)    // NCE0
#define   ERM_SR0_NCE0_0                         (uint32_t)0x0          // No non-correctable error event on Memory 0 detected
#define   ERM_SR0_NCE0_1                         (uint32_t)0x1          // Non-correctable error event on Memory 0 detected
#define ERM_SR0_SBC0                             ((uint32_t)1 << 31)    // SBC0
#define   ERM_SR0_SBC0_0                         (uint32_t)0x0          // No single-bit correction event on Memory 0 detected
#define   ERM_SR0_SBC0_1                         (uint32_t)0x1          // Single-bit correction event on Memory 0 detected

    uint8_t _res1[236];
    const uint32_t       EAR0;                                          // ERM Memory n Error Address Register
    uint8_t _res2[12];
    const uint32_t       EAR1;                                          // ERM Memory n Error Address Register
} ERM_regs_t;
                                                                        // --------------------
                                                                        // Error Injection Module
typedef struct                                                          // --------------------
{
    uint32_t             EIMCR;                                         // Error Injection Module Configuration Register
#define EIM_EIMCR_GEIEN                          ((uint32_t)1 << 0)     // Global Error Injection Enable
#define   EIM_EIMCR_GEIEN_0                      (uint32_t)0x0          // Disabled
#define   EIM_EIMCR_GEIEN_1                      (uint32_t)0x1          // Enabled

    uint32_t             EICHEN;                                        // Error Injection Channel Enable register
#define EIM_EICHEN_EICH1EN                       ((uint32_t)1 << 30)    // Error Injection Channel 1 Enable
#define   EIM_EICHEN_EICH1EN_0                   (uint32_t)0x0          // Error injection is disabled on Error Injection Channel 1
#define   EIM_EICHEN_EICH1EN_1                   (uint32_t)0x1          // Error injection is enabled on Error Injection Channel 1
#define EIM_EICHEN_EICH0EN                       ((uint32_t)1 << 31)    // Error Injection Channel 0 Enable
#define   EIM_EICHEN_EICH0EN_0                   (uint32_t)0x0          // Error injection is disabled on Error Injection Channel 0
#define   EIM_EICHEN_EICH0EN_1                   (uint32_t)0x1          // Error injection is enabled on Error Injection Channel 0

    uint8_t _res0[248];
    uint32_t             EICHD0_WORD0;                                  // Error Injection Channel Descriptor n, Word0
                                                                        // Checkbit Mask
#define EIM_EICHD0_WORD0_CHKBIT_MASK(_n)         (((uint32_t)(_n) & 0x7f) << 25)
#define EIM_EICHD0_WORD0_CHKBIT_MASK_INSERT(_v, _n)  (((_v) & ~0xfe000000) | ((uint32_t)(_n) & 0x7f) << 25)
#define EIM_EICHD0_WORD0_CHKBIT_MASK_EXTRACT(_v)     (((_v) >> 25) & 0x7f)

    uint32_t             EICHD0_WORD1;                                  // Error Injection Channel Descriptor n, Word1
    uint8_t _res1[248];
    uint32_t             EICHD1_WORD0;                                  // Error Injection Channel Descriptor n, Word0
                                                                        // Checkbit Mask
#define EIM_EICHD1_WORD0_CHKBIT_MASK(_n)         (((uint32_t)(_n) & 0x7f) << 25)
#define EIM_EICHD1_WORD0_CHKBIT_MASK_INSERT(_v, _n)  (((_v) & ~0xfe000000) | ((uint32_t)(_n) & 0x7f) << 25)
#define EIM_EICHD1_WORD0_CHKBIT_MASK_EXTRACT(_v)     (((_v) >> 25) & 0x7f)

    uint32_t             EICHD1_WORD1;                                  // Error Injection Channel Descriptor n, Word1
} EIM_regs_t;
                                                                        // --------------------
                                                                        // FTFC
typedef struct                                                          // --------------------
{
    uint8_t              FSTAT;                                         // Flash Status Register
#define FTFC_FSTAT_MGSTAT0                       ((uint8_t)1 << 0)      // Memory Controller Command Completion Status Flag
#define FTFC_FSTAT_FPVIOL                        ((uint8_t)1 << 4)      // Flash Protection Violation Flag
#define   FTFC_FSTAT_FPVIOL_0                    (uint8_t)0x0           // No protection violation detected
#define   FTFC_FSTAT_FPVIOL_1                    (uint8_t)0x1           // Protection violation detected
#define FTFC_FSTAT_ACCERR                        ((uint8_t)1 << 5)      // Flash Access Error Flag
#define   FTFC_FSTAT_ACCERR_0                    (uint8_t)0x0           // No access error detected
#define   FTFC_FSTAT_ACCERR_1                    (uint8_t)0x1           // Access error detected
#define FTFC_FSTAT_RDCOLERR                      ((uint8_t)1 << 6)      // FTFC Read Collision Error Flag
#define   FTFC_FSTAT_RDCOLERR_0                  (uint8_t)0x0           // No collision error detected
#define   FTFC_FSTAT_RDCOLERR_1                  (uint8_t)0x1           // Collision error detected
#define FTFC_FSTAT_CCIF                          ((uint8_t)1 << 7)      // Command Complete Interrupt Flag

    uint8_t              FCNFG;                                         // Flash Configuration Register
#define FTFC_FCNFG_EEERDY                        ((uint8_t)1 << 0)      // EEERDY
#define FTFC_FCNFG_RAMRDY                        ((uint8_t)1 << 1)      // RAM Ready
#define FTFC_FCNFG_ERSSUSP                       ((uint8_t)1 << 4)      // Erase Suspend
#define   FTFC_FCNFG_ERSSUSP_0                   (uint8_t)0x0           // No suspend requested
#define   FTFC_FCNFG_ERSSUSP_1                   (uint8_t)0x1           // Suspend the current Erase Flash Sector command execution
#define FTFC_FCNFG_ERSAREQ                       ((uint8_t)1 << 5)      // Erase All Request
#define   FTFC_FCNFG_ERSAREQ_0                   (uint8_t)0x0           // No request or request complete
#define FTFC_FCNFG_RDCOLLIE                      ((uint8_t)1 << 6)      // Read Collision Error Interrupt Enable
#define   FTFC_FCNFG_RDCOLLIE_0                  (uint8_t)0x0           // Read collision error interrupt disabled
#define   FTFC_FCNFG_RDCOLLIE_1                  (uint8_t)0x1           // Read collision error interrupt enabled. An interrupt request is generated whenever an FTFC read collision error is detected (see the description of FSTAT[RDCOLERR]).
#define FTFC_FCNFG_CCIE                          ((uint8_t)1 << 7)      // Command Complete Interrupt Enable
#define   FTFC_FCNFG_CCIE_0                      (uint8_t)0x0           // Command complete interrupt disabled
#define   FTFC_FCNFG_CCIE_1                      (uint8_t)0x1           // Command complete interrupt enabled. An interrupt request is generated whenever the FSTAT[CCIF] flag is set.

    const uint8_t        FSEC;                                          // Flash Security Register
                                                                        // Flash Security
#define FTFC_FSEC_SEC_EXTRACT(_v)                    (((_v) >> 0) & 0x3)
#define   FTFC_FSEC_SEC_10                       (uint8_t)0x2           // MCU security status is unsecure (The standard shipping condition of the FTFC is unsecure.)
                                                                        // Factory Failure Analysis Access Code
#define FTFC_FSEC_FSLACC_EXTRACT(_v)                 (((_v) >> 2) & 0x3)
#define   FTFC_FSEC_FSLACC_00                    (uint8_t)0x0           // Factory access granted
#define   FTFC_FSEC_FSLACC_11                    (uint8_t)0x3           // Factory access granted
                                                                        // Mass Erase Enable Bits
#define FTFC_FSEC_MEEN_EXTRACT(_v)                   (((_v) >> 4) & 0x3)
#define   FTFC_FSEC_MEEN_00                      (uint8_t)0x0           // Mass erase is enabled
#define   FTFC_FSEC_MEEN_01                      (uint8_t)0x1           // Mass erase is enabled
#define   FTFC_FSEC_MEEN_11                      (uint8_t)0x3           // Mass erase is enabled
                                                                        // Backdoor Key Security Enable
#define FTFC_FSEC_KEYEN_EXTRACT(_v)                  (((_v) >> 6) & 0x3)
#define   FTFC_FSEC_KEYEN_00                     (uint8_t)0x0           // Backdoor key access disabled
#define   FTFC_FSEC_KEYEN_01                     (uint8_t)0x1           // Backdoor key access disabled (preferred KEYEN state to disable backdoor key access)
#define   FTFC_FSEC_KEYEN_10                     (uint8_t)0x2           // Backdoor key access enabled
#define   FTFC_FSEC_KEYEN_11                     (uint8_t)0x3           // Backdoor key access disabled

    const uint8_t        FOPT;                                          // Flash Option Register
    uint8_t              FCCOB3;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB2;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB1;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB0;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB7;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB6;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB5;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB4;                                        // Flash Common Command Object Registers
    uint8_t              FCCOBB;                                        // Flash Common Command Object Registers
    uint8_t              FCCOBA;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB9;                                        // Flash Common Command Object Registers
    uint8_t              FCCOB8;                                        // Flash Common Command Object Registers
    uint8_t              FPROT3;                                        // Program Flash Protection Registers
    uint8_t              FPROT2;                                        // Program Flash Protection Registers
    uint8_t              FPROT1;                                        // Program Flash Protection Registers
    uint8_t              FPROT0;                                        // Program Flash Protection Registers
    uint8_t _res0[2];
    uint8_t              FEPROT;                                        // EEPROM Protection Register
    uint8_t              FDPROT;                                        // Data Flash Protection Register
    uint8_t _res1[20];
    const uint8_t        FCSESTAT;                                      // Flash CSEc Status Register
#define FTFC_FCSESTAT_BSY                        ((uint8_t)1 << 0)      // Busy
#define FTFC_FCSESTAT_SB                         ((uint8_t)1 << 1)      // Secure Boot
#define FTFC_FCSESTAT_BIN                        ((uint8_t)1 << 2)      // Secure Boot Initialization
#define FTFC_FCSESTAT_BFN                        ((uint8_t)1 << 3)      // Secure Boot Finished
#define FTFC_FCSESTAT_BOK                        ((uint8_t)1 << 4)      // Secure Boot OK
#define FTFC_FCSESTAT_RIN                        ((uint8_t)1 << 5)      // Random Number Generator Initialized
#define FTFC_FCSESTAT_EDB                        ((uint8_t)1 << 6)      // External Debug
#define FTFC_FCSESTAT_IDB                        ((uint8_t)1 << 7)      // Internal Debug

    uint8_t _res2[1];
    uint8_t              FERSTAT;                                       // Flash Error Status Register
#define FTFC_FERSTAT_DFDIF                       ((uint8_t)1 << 1)      // Double Bit Fault Detect Interrupt Flag
#define   FTFC_FERSTAT_DFDIF_0                   (uint8_t)0x0           // Double bit fault not detected during a valid flash read access from the platform flash controller
#define   FTFC_FERSTAT_DFDIF_1                   (uint8_t)0x1           // Double bit fault detected (or FERCNFG[FDFD] is set) during a valid flash read access from the platform flash controller

    uint8_t              FERCNFG;                                       // Flash Error Configuration Register
#define FTFC_FERCNFG_DFDIE                       ((uint8_t)1 << 1)      // Double Bit Fault Detect Interrupt Enable
#define   FTFC_FERCNFG_DFDIE_0                   (uint8_t)0x0           // Double bit fault detect interrupt disabled
#define   FTFC_FERCNFG_DFDIE_1                   (uint8_t)0x1           // Double bit fault detect interrupt enabled. An interrupt request is generated whenever the FERSTAT[DFDIF] flag is set.
#define FTFC_FERCNFG_FDFD                        ((uint8_t)1 << 5)      // Force Double Bit Fault Detect
#define   FTFC_FERCNFG_FDFD_0                    (uint8_t)0x0           // FERSTAT[DFDIF] sets only if a double bit fault is detected during read access from the platform flash controller
#define   FTFC_FERCNFG_FDFD_1                    (uint8_t)0x1           // FERSTAT[DFDIF] sets during any valid flash read access from the platform flash controller. An interrupt request is generated if the DFDIE bit is set.

} FTFC_regs_t;
                                                                        // --------------------
                                                                        // DMA channel multiplexor
typedef struct                                                          // --------------------
{
    uint8_t              CHCFG0;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG0_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG0_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG0_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG0_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG0_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG0_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG0_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG0_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG0_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG1;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG1_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG1_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG1_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG1_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG1_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG1_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG1_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG1_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG1_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG2;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG2_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG2_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG2_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG2_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG2_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG2_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG2_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG2_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG2_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG3;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG3_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG3_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG3_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG3_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG3_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG3_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG3_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG3_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG3_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG4;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG4_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG4_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG4_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG4_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG4_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG4_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG4_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG4_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG4_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG5;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG5_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG5_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG5_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG5_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG5_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG5_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG5_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG5_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG5_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG6;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG6_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG6_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG6_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG6_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG6_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG6_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG6_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG6_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG6_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG7;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG7_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG7_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG7_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG7_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG7_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG7_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG7_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG7_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG7_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG8;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG8_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG8_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG8_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG8_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG8_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG8_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG8_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG8_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG8_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG9;                                        // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG9_SOURCE(_n)                 (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG9_SOURCE_INSERT(_v, _n)          (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG9_SOURCE_EXTRACT(_v)             (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG9_TRIG                       ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG9_TRIG_0                   (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG9_TRIG_1                   (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG9_ENBL                       ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG9_ENBL_0                   (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG9_ENBL_1                   (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG10;                                       // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG10_SOURCE(_n)                (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG10_SOURCE_INSERT(_v, _n)         (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG10_SOURCE_EXTRACT(_v)            (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG10_TRIG                      ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG10_TRIG_0                  (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG10_TRIG_1                  (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG10_ENBL                      ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG10_ENBL_0                  (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG10_ENBL_1                  (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG11;                                       // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG11_SOURCE(_n)                (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG11_SOURCE_INSERT(_v, _n)         (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG11_SOURCE_EXTRACT(_v)            (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG11_TRIG                      ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG11_TRIG_0                  (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG11_TRIG_1                  (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG11_ENBL                      ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG11_ENBL_0                  (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG11_ENBL_1                  (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG12;                                       // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG12_SOURCE(_n)                (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG12_SOURCE_INSERT(_v, _n)         (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG12_SOURCE_EXTRACT(_v)            (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG12_TRIG                      ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG12_TRIG_0                  (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG12_TRIG_1                  (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG12_ENBL                      ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG12_ENBL_0                  (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG12_ENBL_1                  (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG13;                                       // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG13_SOURCE(_n)                (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG13_SOURCE_INSERT(_v, _n)         (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG13_SOURCE_EXTRACT(_v)            (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG13_TRIG                      ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG13_TRIG_0                  (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG13_TRIG_1                  (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG13_ENBL                      ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG13_ENBL_0                  (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG13_ENBL_1                  (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG14;                                       // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG14_SOURCE(_n)                (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG14_SOURCE_INSERT(_v, _n)         (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG14_SOURCE_EXTRACT(_v)            (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG14_TRIG                      ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG14_TRIG_0                  (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG14_TRIG_1                  (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG14_ENBL                      ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG14_ENBL_0                  (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG14_ENBL_1                  (uint8_t)0x1           // DMA channel is enabled

    uint8_t              CHCFG15;                                       // Channel Configuration register
                                                                        // DMA Channel Source (Slot)
#define DMAMUX_CHCFG15_SOURCE(_n)                (((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG15_SOURCE_INSERT(_v, _n)         (((_v) & ~0x3f) | ((uint8_t)(_n) & 0x3f) << 0)
#define DMAMUX_CHCFG15_SOURCE_EXTRACT(_v)            (((_v) >> 0) & 0x3f)
#define DMAMUX_CHCFG15_TRIG                      ((uint8_t)1 << 6)      // DMA Channel Trigger Enable
#define   DMAMUX_CHCFG15_TRIG_0                  (uint8_t)0x0           // Triggering is disabled. If triggering is disabled and ENBL is set, the DMA Channel will simply route the specified source to the DMA channel. (Normal mode)
#define   DMAMUX_CHCFG15_TRIG_1                  (uint8_t)0x1           // Triggering is enabled. If triggering is enabled and ENBL is set, the DMAMUX is in Periodic Trigger mode.
#define DMAMUX_CHCFG15_ENBL                      ((uint8_t)1 << 7)      // DMA Channel Enable
#define   DMAMUX_CHCFG15_ENBL_0                  (uint8_t)0x0           // DMA channel is disabled. This mode is primarily used during configuration of the DMAMux. The DMA has separate channel enables/disables, which should be used to disable or reconfigure a DMA channel.
#define   DMAMUX_CHCFG15_ENBL_1                  (uint8_t)0x1           // DMA channel is enabled

} DMAMUX_regs_t;
                                                                        // --------------------
                                                                        // Flex Controller Area Network module
typedef struct                                                          // --------------------
{
    uint32_t             MCR;                                           // Module Configuration Register
                                                                        // Number Of The Last Message Buffer
#define CAN_MCR_MAXMB(_n)                        (((uint32_t)(_n) & 0x7f) << 0)
#define CAN_MCR_MAXMB_INSERT(_v, _n)                 (((_v) & ~0x7f) | ((uint32_t)(_n) & 0x7f) << 0)
#define CAN_MCR_MAXMB_EXTRACT(_v)                    (((_v) >> 0) & 0x7f)
                                                                        // ID Acceptance Mode
#define CAN_MCR_IDAM(_n)                         (((uint32_t)(_n) & 0x3) << 8)
#define CAN_MCR_IDAM_INSERT(_v, _n)                  (((_v) & ~0x300) | ((uint32_t)(_n) & 0x3) << 8)
#define CAN_MCR_IDAM_EXTRACT(_v)                     (((_v) >> 8) & 0x3)
#define   CAN_MCR_IDAM_00                        (uint32_t)0x0          // Format A: One full ID (standard and extended) per ID Filter Table element.
#define   CAN_MCR_IDAM_01                        (uint32_t)0x1          // Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID Filter Table element.
#define   CAN_MCR_IDAM_10                        (uint32_t)0x2          // Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
#define   CAN_MCR_IDAM_11                        (uint32_t)0x3          // Format D: All frames rejected.
#define CAN_MCR_FDEN                             ((uint32_t)1 << 11)    // CAN FD operation enable
#define   CAN_MCR_FDEN_1                         (uint32_t)0x1          // CAN FD is enabled. FlexCAN is able to receive and transmit messages in both CAN FD and CAN 2.0 formats.
#define   CAN_MCR_FDEN_0                         (uint32_t)0x0          // CAN FD is disabled. FlexCAN is able to receive and transmit messages in CAN 2.0 format.
#define CAN_MCR_AEN                              ((uint32_t)1 << 12)    // Abort Enable
#define   CAN_MCR_AEN_0                          (uint32_t)0x0          // Abort disabled.
#define   CAN_MCR_AEN_1                          (uint32_t)0x1          // Abort enabled.
#define CAN_MCR_LPRIOEN                          ((uint32_t)1 << 13)    // Local Priority Enable
#define   CAN_MCR_LPRIOEN_0                      (uint32_t)0x0          // Local Priority disabled.
#define   CAN_MCR_LPRIOEN_1                      (uint32_t)0x1          // Local Priority enabled.
#define CAN_MCR_PNET_EN                          ((uint32_t)1 << 14)    // Pretended Networking Enable
#define   CAN_MCR_PNET_EN_0                      (uint32_t)0x0          // Pretended Networking mode is disabled.
#define   CAN_MCR_PNET_EN_1                      (uint32_t)0x1          // Pretended Networking mode is enabled.
#define CAN_MCR_DMA                              ((uint32_t)1 << 15)    // DMA Enable
#define   CAN_MCR_DMA_0                          (uint32_t)0x0          // DMA feature for RX FIFO disabled.
#define   CAN_MCR_DMA_1                          (uint32_t)0x1          // DMA feature for RX FIFO enabled.
#define CAN_MCR_IRMQ                             ((uint32_t)1 << 16)    // Individual Rx Masking And Queue Enable
#define   CAN_MCR_IRMQ_0                         (uint32_t)0x0          // Individual Rx masking and queue feature are disabled. For backward compatibility with legacy applications, the reading of C/S word locks the MB even if it is EMPTY.
#define   CAN_MCR_IRMQ_1                         (uint32_t)0x1          // Individual Rx masking and queue feature are enabled.
#define CAN_MCR_SRXDIS                           ((uint32_t)1 << 17)    // Self Reception Disable
#define   CAN_MCR_SRXDIS_0                       (uint32_t)0x0          // Self reception enabled.
#define   CAN_MCR_SRXDIS_1                       (uint32_t)0x1          // Self reception disabled.
#define CAN_MCR_LPMACK                           ((uint32_t)1 << 20)    // Low-Power Mode Acknowledge
#define   CAN_MCR_LPMACK_0                       (uint32_t)0x0          // FlexCAN is not in a low-power mode.
#define   CAN_MCR_LPMACK_1                       (uint32_t)0x1          // FlexCAN is in a low-power mode.
#define CAN_MCR_WRNEN                            ((uint32_t)1 << 21)    // Warning Interrupt Enable
#define   CAN_MCR_WRNEN_0                        (uint32_t)0x0          // TWRNINT and RWRNINT bits are zero, independent of the values in the error counters.
#define   CAN_MCR_WRNEN_1                        (uint32_t)0x1          // TWRNINT and RWRNINT bits are set when the respective error counter transitions from less than 96 to greater than or equal to 96.
#define CAN_MCR_SUPV                             ((uint32_t)1 << 23)    // Supervisor Mode
#define CAN_MCR_FRZACK                           ((uint32_t)1 << 24)    // Freeze Mode Acknowledge
#define   CAN_MCR_FRZACK_0                       (uint32_t)0x0          // FlexCAN not in Freeze mode, prescaler running.
#define   CAN_MCR_FRZACK_1                       (uint32_t)0x1          // FlexCAN in Freeze mode, prescaler stopped.
#define CAN_MCR_SOFTRST                          ((uint32_t)1 << 25)    // Soft Reset
#define   CAN_MCR_SOFTRST_0                      (uint32_t)0x0          // No reset request.
#define   CAN_MCR_SOFTRST_1                      (uint32_t)0x1          // Resets the registers affected by soft reset.
#define CAN_MCR_NOTRDY                           ((uint32_t)1 << 27)    // FlexCAN Not Ready
#define   CAN_MCR_NOTRDY_0                       (uint32_t)0x0          // FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back mode.
#define CAN_MCR_HALT                             ((uint32_t)1 << 28)    // Halt FlexCAN
#define   CAN_MCR_HALT_0                         (uint32_t)0x0          // No Freeze mode request.
#define   CAN_MCR_HALT_1                         (uint32_t)0x1          // Enters Freeze mode if the FRZ bit is asserted.
#define CAN_MCR_RFEN                             ((uint32_t)1 << 29)    // Rx FIFO Enable
#define   CAN_MCR_RFEN_0                         (uint32_t)0x0          // Rx FIFO not enabled.
#define   CAN_MCR_RFEN_1                         (uint32_t)0x1          // Rx FIFO enabled.
#define CAN_MCR_FRZ                              ((uint32_t)1 << 30)    // Freeze Enable
#define   CAN_MCR_FRZ_0                          (uint32_t)0x0          // Not enabled to enter Freeze mode.
#define   CAN_MCR_FRZ_1                          (uint32_t)0x1          // Enabled to enter Freeze mode.
#define CAN_MCR_MDIS                             ((uint32_t)1 << 31)    // Module Disable
#define   CAN_MCR_MDIS_0                         (uint32_t)0x0          // Enable the FlexCAN module.
#define   CAN_MCR_MDIS_1                         (uint32_t)0x1          // Disable the FlexCAN module.

    uint32_t             CTRL1;                                         // Control 1 register
                                                                        // Propagation Segment
#define CAN_CTRL1_PROPSEG(_n)                    (((uint32_t)(_n) & 0x7) << 0)
#define CAN_CTRL1_PROPSEG_INSERT(_v, _n)             (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define CAN_CTRL1_PROPSEG_EXTRACT(_v)                (((_v) >> 0) & 0x7)
#define CAN_CTRL1_LOM                            ((uint32_t)1 << 3)     // Listen-Only Mode
#define   CAN_CTRL1_LOM_0                        (uint32_t)0x0          // Listen-Only mode is deactivated.
#define   CAN_CTRL1_LOM_1                        (uint32_t)0x1          // FlexCAN module operates in Listen-Only mode.
#define CAN_CTRL1_LBUF                           ((uint32_t)1 << 4)     // Lowest Buffer Transmitted First
#define   CAN_CTRL1_LBUF_0                       (uint32_t)0x0          // Buffer with highest priority is transmitted first.
#define   CAN_CTRL1_LBUF_1                       (uint32_t)0x1          // Lowest number buffer is transmitted first.
#define CAN_CTRL1_TSYN                           ((uint32_t)1 << 5)     // Timer Sync
#define   CAN_CTRL1_TSYN_0                       (uint32_t)0x0          // Timer Sync feature disabled
#define   CAN_CTRL1_TSYN_1                       (uint32_t)0x1          // Timer Sync feature enabled
#define CAN_CTRL1_BOFFREC                        ((uint32_t)1 << 6)     // Bus Off Recovery
#define   CAN_CTRL1_BOFFREC_0                    (uint32_t)0x0          // Automatic recovering from Bus Off state enabled.
#define   CAN_CTRL1_BOFFREC_1                    (uint32_t)0x1          // Automatic recovering from Bus Off state disabled.
#define CAN_CTRL1_SMP                            ((uint32_t)1 << 7)     // CAN Bit Sampling
#define   CAN_CTRL1_SMP_0                        (uint32_t)0x0          // Just one sample is used to determine the bit value.
#define   CAN_CTRL1_SMP_1                        (uint32_t)0x1          // Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples; a majority rule is used.
#define CAN_CTRL1_RWRNMSK                        ((uint32_t)1 << 10)    // Rx Warning Interrupt Mask
#define   CAN_CTRL1_RWRNMSK_0                    (uint32_t)0x0          // Rx Warning Interrupt disabled.
#define   CAN_CTRL1_RWRNMSK_1                    (uint32_t)0x1          // Rx Warning Interrupt enabled.
#define CAN_CTRL1_TWRNMSK                        ((uint32_t)1 << 11)    // Tx Warning Interrupt Mask
#define   CAN_CTRL1_TWRNMSK_0                    (uint32_t)0x0          // Tx Warning Interrupt disabled.
#define   CAN_CTRL1_TWRNMSK_1                    (uint32_t)0x1          // Tx Warning Interrupt enabled.
#define CAN_CTRL1_LPB                            ((uint32_t)1 << 12)    // Loop Back Mode
#define   CAN_CTRL1_LPB_0                        (uint32_t)0x0          // Loop Back disabled.
#define   CAN_CTRL1_LPB_1                        (uint32_t)0x1          // Loop Back enabled.
#define CAN_CTRL1_CLKSRC                         ((uint32_t)1 << 13)    // CAN Engine Clock Source
#define   CAN_CTRL1_CLKSRC_0                     (uint32_t)0x0          // The CAN engine clock source is the oscillator clock. Under this condition, the oscillator clock frequency must be lower than the bus clock.
#define   CAN_CTRL1_CLKSRC_1                     (uint32_t)0x1          // The CAN engine clock source is the peripheral clock.
#define CAN_CTRL1_ERRMSK                         ((uint32_t)1 << 14)    // Error Interrupt Mask
#define   CAN_CTRL1_ERRMSK_0                     (uint32_t)0x0          // Error interrupt disabled.
#define   CAN_CTRL1_ERRMSK_1                     (uint32_t)0x1          // Error interrupt enabled.
#define CAN_CTRL1_BOFFMSK                        ((uint32_t)1 << 15)    // Bus Off Interrupt Mask
#define   CAN_CTRL1_BOFFMSK_0                    (uint32_t)0x0          // Bus Off interrupt disabled.
#define   CAN_CTRL1_BOFFMSK_1                    (uint32_t)0x1          // Bus Off interrupt enabled.
                                                                        // Phase Segment 2
#define CAN_CTRL1_PSEG2(_n)                      (((uint32_t)(_n) & 0x7) << 16)
#define CAN_CTRL1_PSEG2_INSERT(_v, _n)               (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define CAN_CTRL1_PSEG2_EXTRACT(_v)                  (((_v) >> 16) & 0x7)
                                                                        // Phase Segment 1
#define CAN_CTRL1_PSEG1(_n)                      (((uint32_t)(_n) & 0x7) << 19)
#define CAN_CTRL1_PSEG1_INSERT(_v, _n)               (((_v) & ~0x380000) | ((uint32_t)(_n) & 0x7) << 19)
#define CAN_CTRL1_PSEG1_EXTRACT(_v)                  (((_v) >> 19) & 0x7)
                                                                        // Resync Jump Width
#define CAN_CTRL1_RJW(_n)                        (((uint32_t)(_n) & 0x3) << 22)
#define CAN_CTRL1_RJW_INSERT(_v, _n)                 (((_v) & ~0xc00000) | ((uint32_t)(_n) & 0x3) << 22)
#define CAN_CTRL1_RJW_EXTRACT(_v)                    (((_v) >> 22) & 0x3)
                                                                        // Prescaler Division Factor
#define CAN_CTRL1_PRESDIV(_n)                    (((uint32_t)(_n) & 0xff) << 24)
#define CAN_CTRL1_PRESDIV_INSERT(_v, _n)             (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_CTRL1_PRESDIV_EXTRACT(_v)                (((_v) >> 24) & 0xff)

    uint32_t             TIMER;                                         // Free Running Timer
                                                                        // Timer Value
#define CAN_TIMER_TIMER(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define CAN_TIMER_TIMER_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define CAN_TIMER_TIMER_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint8_t _res0[4];
    uint32_t             RXMGMASK;                                      // Rx Mailboxes Global Mask Register
    uint32_t             RX14MASK;                                      // Rx 14 Mask register
    uint32_t             RX15MASK;                                      // Rx 15 Mask register
    uint32_t             ECR;                                           // Error Counter
                                                                        // Transmit Error Counter
#define CAN_ECR_TXERRCNT(_n)                     (((uint32_t)(_n) & 0xff) << 0)
#define CAN_ECR_TXERRCNT_INSERT(_v, _n)              (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_ECR_TXERRCNT_EXTRACT(_v)                 (((_v) >> 0) & 0xff)
                                                                        // Receive Error Counter
#define CAN_ECR_RXERRCNT(_n)                     (((uint32_t)(_n) & 0xff) << 8)
#define CAN_ECR_RXERRCNT_INSERT(_v, _n)              (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_ECR_RXERRCNT_EXTRACT(_v)                 (((_v) >> 8) & 0xff)
                                                                        // Transmit Error Counter for fast bits
#define CAN_ECR_TXERRCNT_FAST(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_ECR_TXERRCNT_FAST_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_ECR_TXERRCNT_FAST_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Receive Error Counter for fast bits
#define CAN_ECR_RXERRCNT_FAST(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_ECR_RXERRCNT_FAST_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_ECR_RXERRCNT_FAST_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             ESR1;                                          // Error and Status 1 register
#define CAN_ESR1_ERRINT                          ((uint32_t)1 << 1)     // Error Interrupt
#define   CAN_ESR1_ERRINT_0                      (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_ERRINT_1                      (uint32_t)0x1          // Indicates setting of any Error Bit in the Error and Status Register.
#define CAN_ESR1_BOFFINT                         ((uint32_t)1 << 2)     // Bus Off Interrupt
#define   CAN_ESR1_BOFFINT_0                     (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_BOFFINT_1                     (uint32_t)0x1          // FlexCAN module entered Bus Off state.
#define CAN_ESR1_RX                              ((uint32_t)1 << 3)     // FlexCAN In Reception
#define   CAN_ESR1_RX_0                          (uint32_t)0x0          // FlexCAN is not receiving a message.
#define   CAN_ESR1_RX_1                          (uint32_t)0x1          // FlexCAN is receiving a message.
                                                                        // Fault Confinement State
#define CAN_ESR1_FLTCONF(_n)                     (((uint32_t)(_n) & 0x3) << 4)
#define CAN_ESR1_FLTCONF_INSERT(_v, _n)              (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define CAN_ESR1_FLTCONF_EXTRACT(_v)                 (((_v) >> 4) & 0x3)
#define   CAN_ESR1_FLTCONF_00                    (uint32_t)0x0          // Error Active
#define   CAN_ESR1_FLTCONF_01                    (uint32_t)0x1          // Error Passive
#define   CAN_ESR1_FLTCONF_1x                    (uint32_t)0x2          // Bus Off
#define CAN_ESR1_TX                              ((uint32_t)1 << 6)     // FlexCAN In Transmission
#define   CAN_ESR1_TX_0                          (uint32_t)0x0          // FlexCAN is not transmitting a message.
#define   CAN_ESR1_TX_1                          (uint32_t)0x1          // FlexCAN is transmitting a message.
#define CAN_ESR1_IDLE                            ((uint32_t)1 << 7)     // IDLE
#define   CAN_ESR1_IDLE_0                        (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_IDLE_1                        (uint32_t)0x1          // CAN bus is now IDLE.
#define CAN_ESR1_RXWRN                           ((uint32_t)1 << 8)     // Rx Error Warning
#define   CAN_ESR1_RXWRN_0                       (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_RXWRN_1                       (uint32_t)0x1          // RXERRCNT is greater than or equal to 96.
#define CAN_ESR1_TXWRN                           ((uint32_t)1 << 9)     // TX Error Warning
#define   CAN_ESR1_TXWRN_0                       (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_TXWRN_1                       (uint32_t)0x1          // TXERRCNT is greater than or equal to 96.
#define CAN_ESR1_STFERR                          ((uint32_t)1 << 10)    // Stuffing Error
#define   CAN_ESR1_STFERR_0                      (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_STFERR_1                      (uint32_t)0x1          // A Stuffing Error occurred since last read of this register.
#define CAN_ESR1_FRMERR                          ((uint32_t)1 << 11)    // Form Error
#define   CAN_ESR1_FRMERR_0                      (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_FRMERR_1                      (uint32_t)0x1          // A Form Error occurred since last read of this register.
#define CAN_ESR1_CRCERR                          ((uint32_t)1 << 12)    // Cyclic Redundancy Check Error
#define   CAN_ESR1_CRCERR_0                      (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_CRCERR_1                      (uint32_t)0x1          // A CRC error occurred since last read of this register.
#define CAN_ESR1_ACKERR                          ((uint32_t)1 << 13)    // Acknowledge Error
#define   CAN_ESR1_ACKERR_0                      (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_ACKERR_1                      (uint32_t)0x1          // An ACK error occurred since last read of this register.
#define CAN_ESR1_BIT0ERR                         ((uint32_t)1 << 14)    // Bit0 Error
#define   CAN_ESR1_BIT0ERR_0                     (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_BIT0ERR_1                     (uint32_t)0x1          // At least one bit sent as dominant is received as recessive.
#define CAN_ESR1_BIT1ERR                         ((uint32_t)1 << 15)    // Bit1 Error
#define   CAN_ESR1_BIT1ERR_0                     (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_BIT1ERR_1                     (uint32_t)0x1          // At least one bit sent as recessive is received as dominant.
#define CAN_ESR1_RWRNINT                         ((uint32_t)1 << 16)    // Rx Warning Interrupt Flag
#define   CAN_ESR1_RWRNINT_0                     (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_RWRNINT_1                     (uint32_t)0x1          // The Rx error counter transitioned from less than 96 to greater than or equal to 96.
#define CAN_ESR1_TWRNINT                         ((uint32_t)1 << 17)    // Tx Warning Interrupt Flag
#define   CAN_ESR1_TWRNINT_0                     (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_TWRNINT_1                     (uint32_t)0x1          // The Tx error counter transitioned from less than 96 to greater than or equal to 96.
#define CAN_ESR1_SYNCH                           ((uint32_t)1 << 18)    // CAN Synchronization Status
#define   CAN_ESR1_SYNCH_0                       (uint32_t)0x0          // FlexCAN is not synchronized to the CAN bus.
#define   CAN_ESR1_SYNCH_1                       (uint32_t)0x1          // FlexCAN is synchronized to the CAN bus.
#define CAN_ESR1_BOFFDONEINT                     ((uint32_t)1 << 19)    // Bus Off Done Interrupt
#define   CAN_ESR1_BOFFDONEINT_0                 (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_BOFFDONEINT_1                 (uint32_t)0x1          // FlexCAN module has completed Bus Off process.
#define CAN_ESR1_ERRINT_FAST                     ((uint32_t)1 << 20)    // Error Interrupt for errors detected in the Data Phase of CAN FD frames with the BRS bit set
#define   CAN_ESR1_ERRINT_FAST_0                 (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_ERRINT_FAST_1                 (uint32_t)0x1          // Indicates setting of any Error Bit detected in the Data Phase of CAN FD frames with the BRS bit set.
#define CAN_ESR1_ERROVR                          ((uint32_t)1 << 21)    // Error Overrun bit
#define   CAN_ESR1_ERROVR_0                      (uint32_t)0x0          // Overrun has not occurred.
#define   CAN_ESR1_ERROVR_1                      (uint32_t)0x1          // Overrun has occurred.
#define CAN_ESR1_STFERR_FAST                     ((uint32_t)1 << 26)    // Stuffing Error in the Data Phase of CAN FD frames with the BRS bit set
#define   CAN_ESR1_STFERR_FAST_0                 (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_STFERR_FAST_1                 (uint32_t)0x1          // A Stuffing Error occurred since last read of this register.
#define CAN_ESR1_FRMERR_FAST                     ((uint32_t)1 << 27)    // Form Error in the Data Phase of CAN FD frames with the BRS bit set
#define   CAN_ESR1_FRMERR_FAST_0                 (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_FRMERR_FAST_1                 (uint32_t)0x1          // A Form Error occurred since last read of this register.
#define CAN_ESR1_CRCERR_FAST                     ((uint32_t)1 << 28)    // Cyclic Redundancy Check Error in the CRC field of CAN FD frames with the BRS bit set
#define   CAN_ESR1_CRCERR_FAST_0                 (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_CRCERR_FAST_1                 (uint32_t)0x1          // A CRC error occurred since last read of this register.
#define CAN_ESR1_BIT0ERR_FAST                    ((uint32_t)1 << 30)    // Bit0 Error in the Data Phase of CAN FD frames with the BRS bit set
#define   CAN_ESR1_BIT0ERR_FAST_0                (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_BIT0ERR_FAST_1                (uint32_t)0x1          // At least one bit sent as dominant is received as recessive.
#define CAN_ESR1_BIT1ERR_FAST                    ((uint32_t)1 << 31)    // Bit1 Error in the Data Phase of CAN FD frames with the BRS bit set
#define   CAN_ESR1_BIT1ERR_FAST_0                (uint32_t)0x0          // No such occurrence.
#define   CAN_ESR1_BIT1ERR_FAST_1                (uint32_t)0x1          // At least one bit sent as recessive is received as dominant.

    uint8_t _res1[4];
    uint32_t             IMASK1;                                        // Interrupt Masks 1 register
    uint8_t _res2[4];
    uint32_t             IFLAG1;                                        // Interrupt Flags 1 register
#define CAN_IFLAG1_BUF0I                         ((uint32_t)1 << 0)     // Buffer MB0 Interrupt Or Clear FIFO bit
#define   CAN_IFLAG1_BUF0I_0                     (uint32_t)0x0          // The corresponding buffer has no occurrence of successfully completed transmission or reception when MCR[RFEN]=0.
#define   CAN_IFLAG1_BUF0I_1                     (uint32_t)0x1          // The corresponding buffer has successfully completed transmission or reception when MCR[RFEN]=0.
                                                                        // Buffer MB i Interrupt Or "reserved"
#define CAN_IFLAG1_BUF4TO1I(_n)                  (((uint32_t)(_n) & 0xf) << 1)
#define CAN_IFLAG1_BUF4TO1I_INSERT(_v, _n)           (((_v) & ~0x1e) | ((uint32_t)(_n) & 0xf) << 1)
#define CAN_IFLAG1_BUF4TO1I_EXTRACT(_v)              (((_v) >> 1) & 0xf)
#define CAN_IFLAG1_BUF5I                         ((uint32_t)1 << 5)     // Buffer MB5 Interrupt Or "Frames available in Rx FIFO"
#define   CAN_IFLAG1_BUF5I_0                     (uint32_t)0x0          // No occurrence of MB5 completing transmission/reception when MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
#define   CAN_IFLAG1_BUF5I_1                     (uint32_t)0x1          // MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s) available in the Rx FIFO when MCR[RFEN]=1. It generates a DMA request in case of MCR[RFEN] and MCR[DMA] are enabled.
#define CAN_IFLAG1_BUF6I                         ((uint32_t)1 << 6)     // Buffer MB6 Interrupt Or "Rx FIFO Warning"
#define   CAN_IFLAG1_BUF6I_0                     (uint32_t)0x0          // No occurrence of MB6 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
#define   CAN_IFLAG1_BUF6I_1                     (uint32_t)0x1          // MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO almost full when MCR[RFEN]=1
#define CAN_IFLAG1_BUF7I                         ((uint32_t)1 << 7)     // Buffer MB7 Interrupt Or "Rx FIFO Overflow"
#define   CAN_IFLAG1_BUF7I_0                     (uint32_t)0x0          // No occurrence of MB7 completing transmission/reception when MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
#define   CAN_IFLAG1_BUF7I_1                     (uint32_t)0x1          // MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO overflow when MCR[RFEN]=1
                                                                        // Buffer MBi Interrupt
#define CAN_IFLAG1_BUF31TO8I(_n)                 (((uint32_t)(_n) & 0xffffff) << 8)
#define CAN_IFLAG1_BUF31TO8I_INSERT(_v, _n)          (((_v) & ~0xffffff00) | ((uint32_t)(_n) & 0xffffff) << 8)
#define CAN_IFLAG1_BUF31TO8I_EXTRACT(_v)             (((_v) >> 8) & 0xffffff)

    uint32_t             CTRL2;                                         // Control 2 register
#define CAN_CTRL2_EDFLTDIS                       ((uint32_t)1 << 11)    // Edge Filter Disable
#define   CAN_CTRL2_EDFLTDIS_0                   (uint32_t)0x0          // Edge Filter is enabled.
#define   CAN_CTRL2_EDFLTDIS_1                   (uint32_t)0x1          // Edge Filter is disabled.
#define CAN_CTRL2_ISOCANFDEN                     ((uint32_t)1 << 12)    // ISO CAN FD Enable
#define   CAN_CTRL2_ISOCANFDEN_0                 (uint32_t)0x0          // FlexCAN operates using the non-ISO CAN FD protocol.
#define   CAN_CTRL2_ISOCANFDEN_1                 (uint32_t)0x1          // FlexCAN operates using the ISO CAN FD protocol (ISO 11898-1).
#define CAN_CTRL2_PREXCEN                        ((uint32_t)1 << 14)    // Protocol Exception Enable
#define   CAN_CTRL2_PREXCEN_0                    (uint32_t)0x0          // Protocol Exception is disabled.
#define   CAN_CTRL2_PREXCEN_1                    (uint32_t)0x1          // Protocol Exception is enabled.
#define CAN_CTRL2_TIMER_SRC                      ((uint32_t)1 << 15)    // Timer Source
#define   CAN_CTRL2_TIMER_SRC_0                  (uint32_t)0x0          // The Free Running Timer is clocked by the CAN bit clock, which defines the baud rate on the CAN bus.
#define   CAN_CTRL2_TIMER_SRC_1                  (uint32_t)0x1          // The Free Running Timer is clocked by an external time tick. The period can be either adjusted to be equal to the baud rate on the CAN bus, or a different value as required. See the device specific section for details about the external time tick.
#define CAN_CTRL2_EACEN                          ((uint32_t)1 << 16)    // Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
#define   CAN_CTRL2_EACEN_0                      (uint32_t)0x0          // Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
#define   CAN_CTRL2_EACEN_1                      (uint32_t)0x1          // Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.
#define CAN_CTRL2_RRS                            ((uint32_t)1 << 17)    // Remote Request Storing
#define   CAN_CTRL2_RRS_0                        (uint32_t)0x0          // Remote Response Frame is generated.
#define   CAN_CTRL2_RRS_1                        (uint32_t)0x1          // Remote Request Frame is stored.
#define CAN_CTRL2_MRP                            ((uint32_t)1 << 18)    // Mailboxes Reception Priority
#define   CAN_CTRL2_MRP_0                        (uint32_t)0x0          // Matching starts from Rx FIFO and continues on Mailboxes.
#define   CAN_CTRL2_MRP_1                        (uint32_t)0x1          // Matching starts from Mailboxes and continues on Rx FIFO.
                                                                        // Tx Arbitration Start Delay
#define CAN_CTRL2_TASD(_n)                       (((uint32_t)(_n) & 0x1f) << 19)
#define CAN_CTRL2_TASD_INSERT(_v, _n)                (((_v) & ~0xf80000) | ((uint32_t)(_n) & 0x1f) << 19)
#define CAN_CTRL2_TASD_EXTRACT(_v)                   (((_v) >> 19) & 0x1f)
                                                                        // Number Of Rx FIFO Filters
#define CAN_CTRL2_RFFN(_n)                       (((uint32_t)(_n) & 0xf) << 24)
#define CAN_CTRL2_RFFN_INSERT(_v, _n)                (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define CAN_CTRL2_RFFN_EXTRACT(_v)                   (((_v) >> 24) & 0xf)
#define CAN_CTRL2_BOFFDONEMSK                    ((uint32_t)1 << 30)    // Bus Off Done Interrupt Mask
#define   CAN_CTRL2_BOFFDONEMSK_0                (uint32_t)0x0          // Bus Off Done interrupt disabled.
#define   CAN_CTRL2_BOFFDONEMSK_1                (uint32_t)0x1          // Bus Off Done interrupt enabled.
#define CAN_CTRL2_ERRMSK_FAST                    ((uint32_t)1 << 31)    // Error Interrupt Mask for errors detected in the Data Phase of fast CAN FD frames
#define   CAN_CTRL2_ERRMSK_FAST_0                (uint32_t)0x0          // ERRINT_FAST Error interrupt disabled.
#define   CAN_CTRL2_ERRMSK_FAST_1                (uint32_t)0x1          // ERRINT_FAST Error interrupt enabled.

    const uint32_t       ESR2;                                          // Error and Status 2 register
#define CAN_ESR2_IMB                             ((uint32_t)1 << 13)    // Inactive Mailbox
#define   CAN_ESR2_IMB_0                         (uint32_t)0x0          // If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
#define   CAN_ESR2_IMB_1                         (uint32_t)0x1          // If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.
#define CAN_ESR2_VPS                             ((uint32_t)1 << 14)    // Valid Priority Status
#define   CAN_ESR2_VPS_0                         (uint32_t)0x0          // Contents of IMB and LPTM are invalid.
#define   CAN_ESR2_VPS_1                         (uint32_t)0x1          // Contents of IMB and LPTM are valid.
                                                                        // Lowest Priority Tx Mailbox
#define CAN_ESR2_LPTM_EXTRACT(_v)                    (((_v) >> 16) & 0x7f)

    uint8_t _res3[8];
    const uint32_t       CRCR;                                          // CRC Register
                                                                        // Transmitted CRC value
#define CAN_CRCR_TXCRC_EXTRACT(_v)                   (((_v) >> 0) & 0x7fff)
                                                                        // CRC Mailbox
#define CAN_CRCR_MBCRC_EXTRACT(_v)                   (((_v) >> 16) & 0x7f)

    uint32_t             RXFGMASK;                                      // Rx FIFO Global Mask register
    const uint32_t       RXFIR;                                         // Rx FIFO Information Register
                                                                        // Identifier Acceptance Filter Hit Indicator
#define CAN_RXFIR_IDHIT_EXTRACT(_v)                  (((_v) >> 0) & 0x1ff)

    uint32_t             CBT;                                           // CAN Bit Timing Register
                                                                        // Extended Phase Segment 2
#define CAN_CBT_EPSEG2(_n)                       (((uint32_t)(_n) & 0x1f) << 0)
#define CAN_CBT_EPSEG2_INSERT(_v, _n)                (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define CAN_CBT_EPSEG2_EXTRACT(_v)                   (((_v) >> 0) & 0x1f)
                                                                        // Extended Phase Segment 1
#define CAN_CBT_EPSEG1(_n)                       (((uint32_t)(_n) & 0x1f) << 5)
#define CAN_CBT_EPSEG1_INSERT(_v, _n)                (((_v) & ~0x3e0) | ((uint32_t)(_n) & 0x1f) << 5)
#define CAN_CBT_EPSEG1_EXTRACT(_v)                   (((_v) >> 5) & 0x1f)
                                                                        // Extended Propagation Segment
#define CAN_CBT_EPROPSEG(_n)                     (((uint32_t)(_n) & 0x3f) << 10)
#define CAN_CBT_EPROPSEG_INSERT(_v, _n)              (((_v) & ~0xfc00) | ((uint32_t)(_n) & 0x3f) << 10)
#define CAN_CBT_EPROPSEG_EXTRACT(_v)                 (((_v) >> 10) & 0x3f)
                                                                        // Extended Resync Jump Width
#define CAN_CBT_ERJW(_n)                         (((uint32_t)(_n) & 0x1f) << 16)
#define CAN_CBT_ERJW_INSERT(_v, _n)                  (((_v) & ~0x1f0000) | ((uint32_t)(_n) & 0x1f) << 16)
#define CAN_CBT_ERJW_EXTRACT(_v)                     (((_v) >> 16) & 0x1f)
                                                                        // Extended Prescaler Division Factor
#define CAN_CBT_EPRESDIV(_n)                     (((uint32_t)(_n) & 0x3ff) << 21)
#define CAN_CBT_EPRESDIV_INSERT(_v, _n)              (((_v) & ~0x7fe00000) | ((uint32_t)(_n) & 0x3ff) << 21)
#define CAN_CBT_EPRESDIV_EXTRACT(_v)                 (((_v) >> 21) & 0x3ff)
#define CAN_CBT_BTF                              ((uint32_t)1 << 31)    // Bit Timing Format Enable
#define   CAN_CBT_BTF_0                          (uint32_t)0x0          // Extended bit time definitions disabled.
#define   CAN_CBT_BTF_1                          (uint32_t)0x1          // Extended bit time definitions enabled.

    uint8_t _res4[44];
    uint32_t             RAMn0;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn0_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn0_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn0_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn0_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn0_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn0_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn0_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn0_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn0_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn0_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn0_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn0_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn1;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn1_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn1_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn1_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn1_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn1_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn1_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn1_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn1_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn1_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn1_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn1_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn1_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn2;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn2_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn2_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn2_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn2_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn2_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn2_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn2_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn2_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn2_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn2_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn2_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn2_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn3;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn3_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn3_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn3_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn3_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn3_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn3_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn3_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn3_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn3_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn3_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn3_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn3_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn4;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn4_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn4_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn4_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn4_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn4_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn4_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn4_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn4_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn4_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn4_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn4_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn4_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn5;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn5_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn5_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn5_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn5_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn5_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn5_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn5_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn5_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn5_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn5_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn5_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn5_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn6;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn6_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn6_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn6_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn6_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn6_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn6_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn6_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn6_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn6_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn6_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn6_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn6_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn7;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn7_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn7_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn7_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn7_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn7_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn7_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn7_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn7_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn7_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn7_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn7_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn7_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn8;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn8_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn8_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn8_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn8_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn8_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn8_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn8_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn8_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn8_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn8_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn8_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn8_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn9;                                         // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn9_DATA_BYTE_3(_n)                (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn9_DATA_BYTE_3_INSERT(_v, _n)         (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn9_DATA_BYTE_3_EXTRACT(_v)            (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn9_DATA_BYTE_2(_n)                (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn9_DATA_BYTE_2_INSERT(_v, _n)         (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn9_DATA_BYTE_2_EXTRACT(_v)            (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn9_DATA_BYTE_1(_n)                (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn9_DATA_BYTE_1_INSERT(_v, _n)         (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn9_DATA_BYTE_1_EXTRACT(_v)            (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn9_DATA_BYTE_0(_n)                (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn9_DATA_BYTE_0_INSERT(_v, _n)         (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn9_DATA_BYTE_0_EXTRACT(_v)            (((_v) >> 24) & 0xff)

    uint32_t             RAMn10;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn10_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn10_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn10_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn10_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn10_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn10_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn10_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn10_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn10_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn10_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn10_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn10_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn11;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn11_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn11_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn11_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn11_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn11_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn11_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn11_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn11_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn11_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn11_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn11_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn11_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn12;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn12_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn12_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn12_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn12_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn12_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn12_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn12_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn12_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn12_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn12_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn12_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn12_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn13;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn13_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn13_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn13_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn13_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn13_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn13_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn13_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn13_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn13_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn13_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn13_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn13_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn14;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn14_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn14_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn14_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn14_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn14_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn14_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn14_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn14_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn14_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn14_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn14_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn14_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn15;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn15_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn15_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn15_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn15_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn15_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn15_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn15_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn15_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn15_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn15_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn15_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn15_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn16;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn16_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn16_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn16_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn16_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn16_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn16_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn16_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn16_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn16_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn16_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn16_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn16_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn17;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn17_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn17_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn17_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn17_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn17_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn17_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn17_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn17_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn17_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn17_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn17_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn17_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn18;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn18_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn18_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn18_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn18_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn18_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn18_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn18_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn18_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn18_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn18_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn18_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn18_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn19;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn19_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn19_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn19_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn19_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn19_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn19_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn19_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn19_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn19_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn19_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn19_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn19_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn20;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn20_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn20_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn20_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn20_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn20_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn20_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn20_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn20_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn20_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn20_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn20_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn20_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn21;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn21_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn21_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn21_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn21_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn21_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn21_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn21_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn21_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn21_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn21_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn21_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn21_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn22;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn22_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn22_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn22_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn22_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn22_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn22_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn22_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn22_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn22_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn22_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn22_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn22_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn23;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn23_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn23_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn23_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn23_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn23_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn23_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn23_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn23_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn23_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn23_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn23_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn23_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn24;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn24_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn24_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn24_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn24_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn24_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn24_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn24_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn24_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn24_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn24_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn24_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn24_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn25;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn25_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn25_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn25_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn25_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn25_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn25_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn25_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn25_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn25_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn25_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn25_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn25_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn26;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn26_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn26_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn26_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn26_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn26_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn26_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn26_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn26_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn26_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn26_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn26_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn26_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn27;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn27_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn27_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn27_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn27_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn27_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn27_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn27_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn27_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn27_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn27_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn27_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn27_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn28;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn28_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn28_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn28_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn28_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn28_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn28_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn28_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn28_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn28_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn28_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn28_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn28_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn29;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn29_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn29_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn29_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn29_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn29_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn29_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn29_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn29_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn29_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn29_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn29_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn29_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn30;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn30_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn30_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn30_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn30_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn30_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn30_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn30_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn30_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn30_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn30_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn30_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn30_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn31;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn31_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn31_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn31_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn31_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn31_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn31_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn31_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn31_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn31_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn31_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn31_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn31_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn32;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn32_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn32_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn32_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn32_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn32_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn32_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn32_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn32_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn32_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn32_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn32_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn32_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn33;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn33_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn33_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn33_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn33_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn33_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn33_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn33_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn33_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn33_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn33_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn33_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn33_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn34;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn34_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn34_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn34_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn34_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn34_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn34_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn34_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn34_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn34_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn34_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn34_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn34_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn35;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn35_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn35_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn35_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn35_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn35_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn35_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn35_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn35_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn35_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn35_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn35_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn35_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn36;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn36_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn36_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn36_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn36_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn36_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn36_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn36_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn36_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn36_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn36_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn36_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn36_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn37;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn37_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn37_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn37_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn37_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn37_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn37_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn37_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn37_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn37_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn37_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn37_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn37_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn38;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn38_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn38_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn38_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn38_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn38_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn38_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn38_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn38_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn38_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn38_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn38_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn38_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn39;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn39_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn39_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn39_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn39_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn39_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn39_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn39_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn39_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn39_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn39_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn39_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn39_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn40;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn40_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn40_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn40_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn40_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn40_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn40_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn40_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn40_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn40_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn40_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn40_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn40_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn41;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn41_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn41_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn41_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn41_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn41_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn41_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn41_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn41_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn41_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn41_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn41_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn41_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn42;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn42_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn42_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn42_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn42_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn42_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn42_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn42_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn42_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn42_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn42_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn42_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn42_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn43;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn43_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn43_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn43_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn43_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn43_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn43_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn43_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn43_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn43_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn43_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn43_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn43_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn44;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn44_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn44_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn44_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn44_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn44_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn44_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn44_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn44_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn44_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn44_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn44_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn44_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn45;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn45_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn45_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn45_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn45_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn45_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn45_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn45_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn45_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn45_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn45_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn45_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn45_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn46;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn46_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn46_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn46_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn46_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn46_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn46_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn46_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn46_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn46_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn46_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn46_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn46_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn47;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn47_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn47_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn47_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn47_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn47_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn47_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn47_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn47_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn47_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn47_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn47_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn47_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn48;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn48_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn48_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn48_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn48_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn48_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn48_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn48_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn48_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn48_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn48_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn48_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn48_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn49;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn49_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn49_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn49_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn49_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn49_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn49_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn49_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn49_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn49_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn49_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn49_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn49_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn50;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn50_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn50_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn50_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn50_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn50_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn50_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn50_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn50_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn50_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn50_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn50_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn50_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn51;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn51_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn51_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn51_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn51_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn51_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn51_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn51_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn51_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn51_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn51_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn51_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn51_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn52;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn52_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn52_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn52_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn52_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn52_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn52_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn52_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn52_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn52_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn52_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn52_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn52_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn53;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn53_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn53_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn53_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn53_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn53_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn53_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn53_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn53_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn53_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn53_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn53_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn53_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn54;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn54_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn54_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn54_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn54_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn54_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn54_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn54_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn54_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn54_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn54_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn54_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn54_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn55;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn55_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn55_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn55_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn55_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn55_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn55_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn55_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn55_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn55_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn55_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn55_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn55_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn56;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn56_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn56_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn56_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn56_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn56_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn56_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn56_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn56_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn56_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn56_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn56_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn56_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn57;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn57_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn57_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn57_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn57_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn57_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn57_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn57_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn57_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn57_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn57_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn57_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn57_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn58;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn58_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn58_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn58_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn58_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn58_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn58_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn58_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn58_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn58_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn58_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn58_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn58_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn59;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn59_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn59_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn59_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn59_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn59_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn59_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn59_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn59_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn59_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn59_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn59_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn59_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn60;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn60_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn60_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn60_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn60_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn60_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn60_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn60_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn60_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn60_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn60_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn60_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn60_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn61;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn61_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn61_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn61_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn61_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn61_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn61_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn61_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn61_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn61_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn61_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn61_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn61_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn62;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn62_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn62_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn62_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn62_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn62_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn62_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn62_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn62_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn62_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn62_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn62_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn62_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn63;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn63_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn63_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn63_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn63_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn63_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn63_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn63_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn63_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn63_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn63_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn63_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn63_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn64;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn64_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn64_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn64_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn64_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn64_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn64_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn64_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn64_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn64_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn64_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn64_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn64_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn65;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn65_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn65_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn65_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn65_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn65_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn65_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn65_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn65_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn65_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn65_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn65_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn65_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn66;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn66_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn66_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn66_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn66_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn66_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn66_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn66_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn66_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn66_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn66_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn66_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn66_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn67;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn67_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn67_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn67_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn67_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn67_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn67_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn67_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn67_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn67_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn67_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn67_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn67_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn68;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn68_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn68_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn68_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn68_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn68_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn68_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn68_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn68_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn68_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn68_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn68_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn68_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn69;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn69_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn69_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn69_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn69_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn69_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn69_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn69_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn69_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn69_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn69_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn69_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn69_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn70;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn70_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn70_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn70_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn70_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn70_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn70_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn70_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn70_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn70_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn70_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn70_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn70_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn71;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn71_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn71_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn71_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn71_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn71_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn71_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn71_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn71_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn71_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn71_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn71_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn71_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn72;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn72_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn72_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn72_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn72_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn72_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn72_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn72_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn72_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn72_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn72_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn72_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn72_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn73;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn73_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn73_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn73_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn73_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn73_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn73_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn73_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn73_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn73_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn73_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn73_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn73_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn74;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn74_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn74_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn74_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn74_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn74_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn74_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn74_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn74_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn74_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn74_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn74_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn74_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn75;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn75_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn75_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn75_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn75_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn75_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn75_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn75_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn75_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn75_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn75_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn75_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn75_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn76;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn76_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn76_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn76_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn76_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn76_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn76_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn76_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn76_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn76_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn76_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn76_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn76_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn77;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn77_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn77_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn77_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn77_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn77_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn77_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn77_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn77_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn77_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn77_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn77_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn77_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn78;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn78_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn78_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn78_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn78_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn78_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn78_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn78_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn78_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn78_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn78_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn78_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn78_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn79;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn79_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn79_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn79_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn79_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn79_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn79_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn79_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn79_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn79_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn79_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn79_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn79_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn80;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn80_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn80_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn80_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn80_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn80_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn80_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn80_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn80_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn80_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn80_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn80_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn80_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn81;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn81_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn81_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn81_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn81_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn81_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn81_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn81_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn81_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn81_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn81_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn81_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn81_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn82;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn82_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn82_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn82_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn82_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn82_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn82_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn82_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn82_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn82_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn82_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn82_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn82_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn83;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn83_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn83_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn83_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn83_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn83_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn83_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn83_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn83_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn83_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn83_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn83_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn83_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn84;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn84_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn84_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn84_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn84_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn84_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn84_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn84_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn84_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn84_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn84_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn84_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn84_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn85;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn85_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn85_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn85_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn85_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn85_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn85_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn85_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn85_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn85_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn85_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn85_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn85_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn86;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn86_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn86_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn86_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn86_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn86_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn86_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn86_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn86_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn86_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn86_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn86_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn86_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn87;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn87_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn87_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn87_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn87_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn87_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn87_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn87_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn87_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn87_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn87_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn87_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn87_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn88;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn88_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn88_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn88_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn88_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn88_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn88_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn88_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn88_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn88_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn88_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn88_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn88_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn89;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn89_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn89_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn89_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn89_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn89_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn89_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn89_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn89_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn89_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn89_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn89_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn89_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn90;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn90_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn90_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn90_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn90_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn90_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn90_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn90_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn90_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn90_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn90_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn90_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn90_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn91;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn91_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn91_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn91_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn91_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn91_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn91_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn91_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn91_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn91_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn91_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn91_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn91_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn92;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn92_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn92_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn92_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn92_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn92_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn92_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn92_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn92_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn92_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn92_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn92_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn92_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn93;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn93_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn93_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn93_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn93_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn93_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn93_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn93_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn93_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn93_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn93_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn93_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn93_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn94;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn94_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn94_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn94_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn94_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn94_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn94_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn94_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn94_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn94_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn94_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn94_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn94_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn95;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn95_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn95_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn95_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn95_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn95_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn95_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn95_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn95_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn95_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn95_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn95_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn95_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn96;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn96_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn96_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn96_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn96_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn96_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn96_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn96_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn96_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn96_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn96_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn96_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn96_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn97;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn97_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn97_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn97_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn97_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn97_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn97_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn97_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn97_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn97_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn97_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn97_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn97_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn98;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn98_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn98_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn98_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn98_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn98_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn98_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn98_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn98_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn98_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn98_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn98_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn98_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn99;                                        // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn99_DATA_BYTE_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn99_DATA_BYTE_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn99_DATA_BYTE_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn99_DATA_BYTE_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn99_DATA_BYTE_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn99_DATA_BYTE_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn99_DATA_BYTE_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn99_DATA_BYTE_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn99_DATA_BYTE_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn99_DATA_BYTE_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn99_DATA_BYTE_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn99_DATA_BYTE_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             RAMn100;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn100_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn100_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn100_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn100_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn100_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn100_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn100_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn100_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn100_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn100_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn100_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn100_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn101;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn101_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn101_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn101_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn101_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn101_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn101_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn101_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn101_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn101_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn101_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn101_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn101_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn102;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn102_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn102_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn102_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn102_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn102_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn102_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn102_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn102_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn102_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn102_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn102_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn102_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn103;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn103_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn103_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn103_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn103_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn103_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn103_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn103_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn103_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn103_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn103_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn103_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn103_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn104;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn104_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn104_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn104_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn104_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn104_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn104_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn104_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn104_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn104_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn104_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn104_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn104_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn105;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn105_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn105_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn105_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn105_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn105_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn105_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn105_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn105_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn105_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn105_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn105_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn105_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn106;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn106_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn106_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn106_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn106_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn106_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn106_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn106_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn106_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn106_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn106_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn106_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn106_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn107;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn107_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn107_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn107_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn107_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn107_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn107_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn107_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn107_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn107_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn107_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn107_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn107_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn108;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn108_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn108_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn108_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn108_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn108_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn108_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn108_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn108_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn108_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn108_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn108_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn108_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn109;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn109_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn109_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn109_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn109_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn109_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn109_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn109_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn109_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn109_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn109_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn109_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn109_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn110;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn110_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn110_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn110_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn110_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn110_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn110_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn110_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn110_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn110_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn110_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn110_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn110_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn111;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn111_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn111_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn111_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn111_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn111_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn111_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn111_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn111_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn111_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn111_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn111_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn111_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn112;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn112_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn112_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn112_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn112_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn112_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn112_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn112_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn112_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn112_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn112_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn112_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn112_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn113;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn113_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn113_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn113_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn113_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn113_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn113_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn113_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn113_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn113_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn113_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn113_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn113_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn114;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn114_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn114_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn114_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn114_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn114_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn114_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn114_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn114_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn114_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn114_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn114_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn114_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn115;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn115_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn115_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn115_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn115_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn115_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn115_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn115_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn115_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn115_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn115_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn115_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn115_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn116;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn116_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn116_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn116_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn116_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn116_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn116_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn116_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn116_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn116_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn116_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn116_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn116_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn117;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn117_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn117_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn117_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn117_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn117_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn117_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn117_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn117_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn117_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn117_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn117_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn117_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn118;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn118_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn118_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn118_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn118_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn118_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn118_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn118_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn118_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn118_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn118_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn118_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn118_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn119;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn119_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn119_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn119_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn119_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn119_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn119_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn119_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn119_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn119_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn119_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn119_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn119_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn120;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn120_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn120_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn120_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn120_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn120_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn120_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn120_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn120_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn120_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn120_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn120_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn120_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn121;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn121_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn121_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn121_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn121_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn121_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn121_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn121_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn121_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn121_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn121_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn121_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn121_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn122;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn122_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn122_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn122_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn122_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn122_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn122_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn122_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn122_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn122_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn122_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn122_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn122_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn123;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn123_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn123_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn123_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn123_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn123_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn123_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn123_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn123_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn123_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn123_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn123_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn123_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn124;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn124_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn124_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn124_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn124_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn124_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn124_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn124_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn124_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn124_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn124_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn124_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn124_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn125;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn125_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn125_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn125_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn125_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn125_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn125_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn125_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn125_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn125_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn125_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn125_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn125_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn126;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn126_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn126_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn126_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn126_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn126_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn126_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn126_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn126_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn126_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn126_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn126_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn126_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint32_t             RAMn127;                                       // Embedded RAM
                                                                        // Data byte 3 of Rx/Tx frame.
#define CAN_RAMn127_DATA_BYTE_3(_n)              (((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn127_DATA_BYTE_3_INSERT(_v, _n)       (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_RAMn127_DATA_BYTE_3_EXTRACT(_v)          (((_v) >> 0) & 0xff)
                                                                        // Data byte 2 of Rx/Tx frame.
#define CAN_RAMn127_DATA_BYTE_2(_n)              (((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn127_DATA_BYTE_2_INSERT(_v, _n)       (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_RAMn127_DATA_BYTE_2_EXTRACT(_v)          (((_v) >> 8) & 0xff)
                                                                        // Data byte 1 of Rx/Tx frame.
#define CAN_RAMn127_DATA_BYTE_1(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn127_DATA_BYTE_1_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_RAMn127_DATA_BYTE_1_EXTRACT(_v)          (((_v) >> 16) & 0xff)
                                                                        // Data byte 0 of Rx/Tx frame.
#define CAN_RAMn127_DATA_BYTE_0(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn127_DATA_BYTE_0_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_RAMn127_DATA_BYTE_0_EXTRACT(_v)          (((_v) >> 24) & 0xff)

    uint8_t _res5[1536];
    uint32_t             RXIMR0;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR1;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR2;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR3;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR4;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR5;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR6;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR7;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR8;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR9;                                        // Rx Individual Mask Registers
    uint32_t             RXIMR10;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR11;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR12;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR13;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR14;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR15;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR16;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR17;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR18;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR19;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR20;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR21;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR22;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR23;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR24;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR25;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR26;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR27;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR28;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR29;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR30;                                       // Rx Individual Mask Registers
    uint32_t             RXIMR31;                                       // Rx Individual Mask Registers
    uint8_t _res6[512];
    uint32_t             CTRL1_PN;                                      // Pretended Networking Control 1 Register
                                                                        // Filtering Combination Selection
#define CAN_CTRL1_PN_FCS(_n)                     (((uint32_t)(_n) & 0x3) << 0)
#define CAN_CTRL1_PN_FCS_INSERT(_v, _n)              (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define CAN_CTRL1_PN_FCS_EXTRACT(_v)                 (((_v) >> 0) & 0x3)
#define   CAN_CTRL1_PN_FCS_00                    (uint32_t)0x0          // Message ID filtering only
#define   CAN_CTRL1_PN_FCS_01                    (uint32_t)0x1          // Message ID filtering and payload filtering
#define   CAN_CTRL1_PN_FCS_10                    (uint32_t)0x2          // Message ID filtering occurring a specified number of times.
#define   CAN_CTRL1_PN_FCS_11                    (uint32_t)0x3          // Message ID filtering and payload filtering a specified number of times
                                                                        // ID Filtering Selection
#define CAN_CTRL1_PN_IDFS(_n)                    (((uint32_t)(_n) & 0x3) << 2)
#define CAN_CTRL1_PN_IDFS_INSERT(_v, _n)             (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define CAN_CTRL1_PN_IDFS_EXTRACT(_v)                (((_v) >> 2) & 0x3)
#define   CAN_CTRL1_PN_IDFS_00                   (uint32_t)0x0          // Match upon a ID contents against an exact target value
#define   CAN_CTRL1_PN_IDFS_01                   (uint32_t)0x1          // Match upon a ID value greater than or equal to a specified target value
#define   CAN_CTRL1_PN_IDFS_10                   (uint32_t)0x2          // Match upon a ID value smaller than or equal to a specified target value
#define   CAN_CTRL1_PN_IDFS_11                   (uint32_t)0x3          // Match upon a ID value inside a range, greater than or equal to a specified lower limit and smaller than or equal a specified upper limit
                                                                        // Payload Filtering Selection
#define CAN_CTRL1_PN_PLFS(_n)                    (((uint32_t)(_n) & 0x3) << 4)
#define CAN_CTRL1_PN_PLFS_INSERT(_v, _n)             (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define CAN_CTRL1_PN_PLFS_EXTRACT(_v)                (((_v) >> 4) & 0x3)
#define   CAN_CTRL1_PN_PLFS_00                   (uint32_t)0x0          // Match upon a payload contents against an exact target value
#define   CAN_CTRL1_PN_PLFS_01                   (uint32_t)0x1          // Match upon a payload value greater than or equal to a specified target value
#define   CAN_CTRL1_PN_PLFS_10                   (uint32_t)0x2          // Match upon a payload value smaller than or equal to a specified target value
#define   CAN_CTRL1_PN_PLFS_11                   (uint32_t)0x3          // Match upon a payload value inside a range, greater than or equal to a specified lower limit and smaller than or equal a specified upper limit
                                                                        // Number of Messages Matching the Same Filtering Criteria
#define CAN_CTRL1_PN_NMATCH(_n)                  (((uint32_t)(_n) & 0xff) << 8)
#define CAN_CTRL1_PN_NMATCH_INSERT(_v, _n)           (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_CTRL1_PN_NMATCH_EXTRACT(_v)              (((_v) >> 8) & 0xff)
#define   CAN_CTRL1_PN_NMATCH_00000001           (uint32_t)0x1          // Received message must match the predefined filtering criteria for ID and/or PL once before generating a wake up event.
#define   CAN_CTRL1_PN_NMATCH_00000010           (uint32_t)0x2          // Received message must match the predefined filtering criteria for ID and/or PL twice before generating a wake up event.
#define   CAN_CTRL1_PN_NMATCH_11111111           (uint32_t)0xff         // Received message must match the predefined filtering criteria for ID and/or PL 255 times before generating a wake up event.
#define CAN_CTRL1_PN_WUMF_MSK                    ((uint32_t)1 << 16)    // Wake Up by Match Flag Mask Bit
#define   CAN_CTRL1_PN_WUMF_MSK_0                (uint32_t)0x0          // Wake up match event is disabled
#define   CAN_CTRL1_PN_WUMF_MSK_1                (uint32_t)0x1          // Wake up match event is enabled
#define CAN_CTRL1_PN_WTOF_MSK                    ((uint32_t)1 << 17)    // Wake Up by Timeout Flag Mask Bit
#define   CAN_CTRL1_PN_WTOF_MSK_0                (uint32_t)0x0          // Timeout wake up event is disabled
#define   CAN_CTRL1_PN_WTOF_MSK_1                (uint32_t)0x1          // Timeout wake up event is enabled

    uint32_t             CTRL2_PN;                                      // Pretended Networking Control 2 Register
                                                                        // Timeout for No Message Matching the Filtering Criteria
#define CAN_CTRL2_PN_MATCHTO(_n)                 (((uint32_t)(_n) & 0xffff) << 0)
#define CAN_CTRL2_PN_MATCHTO_INSERT(_v, _n)          (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define CAN_CTRL2_PN_MATCHTO_EXTRACT(_v)             (((_v) >> 0) & 0xffff)

    uint32_t             WU_MTC;                                        // Pretended Networking Wake Up Match Register
                                                                        // Number of Matches while in Pretended Networking
#define CAN_WU_MTC_MCOUNTER(_n)                  (((uint32_t)(_n) & 0xff) << 8)
#define CAN_WU_MTC_MCOUNTER_INSERT(_v, _n)           (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_WU_MTC_MCOUNTER_EXTRACT(_v)              (((_v) >> 8) & 0xff)
#define CAN_WU_MTC_WUMF                          ((uint32_t)1 << 16)    // Wake Up by Match Flag Bit
#define   CAN_WU_MTC_WUMF_0                      (uint32_t)0x0          // No wake up by match event detected
#define   CAN_WU_MTC_WUMF_1                      (uint32_t)0x1          // Wake up by match event detected
#define CAN_WU_MTC_WTOF                          ((uint32_t)1 << 17)    // Wake Up by Timeout Flag Bit
#define   CAN_WU_MTC_WTOF_0                      (uint32_t)0x0          // No wake up by timeout event detected
#define   CAN_WU_MTC_WTOF_1                      (uint32_t)0x1          // Wake up by timeout event detected

    uint32_t             FLT_ID1;                                       // Pretended Networking ID Filter 1 Register
                                                                        // ID Filter 1 for Pretended Networking filtering
#define CAN_FLT_ID1_FLT_ID1(_n)                  (((uint32_t)(_n) & 0x1fffffff) << 0)
#define CAN_FLT_ID1_FLT_ID1_INSERT(_v, _n)           (((_v) & ~0x1fffffff) | ((uint32_t)(_n) & 0x1fffffff) << 0)
#define CAN_FLT_ID1_FLT_ID1_EXTRACT(_v)              (((_v) >> 0) & 0x1fffffff)
#define CAN_FLT_ID1_FLT_RTR                      ((uint32_t)1 << 29)    // Remote Transmission Request Filter
#define   CAN_FLT_ID1_FLT_RTR_0                  (uint32_t)0x0          // Reject remote frame (accept data frame)
#define   CAN_FLT_ID1_FLT_RTR_1                  (uint32_t)0x1          // Accept remote frame
#define CAN_FLT_ID1_FLT_IDE                      ((uint32_t)1 << 30)    // ID Extended Filter
#define   CAN_FLT_ID1_FLT_IDE_0                  (uint32_t)0x0          // Accept standard frame format
#define   CAN_FLT_ID1_FLT_IDE_1                  (uint32_t)0x1          // Accept extended frame format

    uint32_t             FLT_DLC;                                       // Pretended Networking DLC Filter Register
                                                                        // Upper Limit for Length of Data Bytes Filter
#define CAN_FLT_DLC_FLT_DLC_HI(_n)               (((uint32_t)(_n) & 0xf) << 0)
#define CAN_FLT_DLC_FLT_DLC_HI_INSERT(_v, _n)        (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define CAN_FLT_DLC_FLT_DLC_HI_EXTRACT(_v)           (((_v) >> 0) & 0xf)
                                                                        // Lower Limit for Length of Data Bytes Filter
#define CAN_FLT_DLC_FLT_DLC_LO(_n)               (((uint32_t)(_n) & 0xf) << 16)
#define CAN_FLT_DLC_FLT_DLC_LO_INSERT(_v, _n)        (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define CAN_FLT_DLC_FLT_DLC_LO_EXTRACT(_v)           (((_v) >> 16) & 0xf)

    uint32_t             PL1_LO;                                        // Pretended Networking Payload Low Filter 1 Register
                                                                        // Payload Filter 1 low order bits for Pretended Networking payload filtering corresponding to the data byte 3.
#define CAN_PL1_LO_Data_byte_3(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_PL1_LO_Data_byte_3_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_PL1_LO_Data_byte_3_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Payload Filter 1 low order bits for Pretended Networking payload filtering corresponding to the data byte 2.
#define CAN_PL1_LO_Data_byte_2(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_PL1_LO_Data_byte_2_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_PL1_LO_Data_byte_2_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Payload Filter 1 low order bits for Pretended Networking payload filtering corresponding to the data byte 1.
#define CAN_PL1_LO_Data_byte_1(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_PL1_LO_Data_byte_1_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_PL1_LO_Data_byte_1_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Payload Filter 1 low order bits for Pretended Networking payload filtering corresponding to the data byte 0.
#define CAN_PL1_LO_Data_byte_0(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_PL1_LO_Data_byte_0_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_PL1_LO_Data_byte_0_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             PL1_HI;                                        // Pretended Networking Payload High Filter 1 Register
                                                                        // Payload Filter 1 high order bits for Pretended Networking payload filtering corresponding to the data byte 7.
#define CAN_PL1_HI_Data_byte_7(_n)               (((uint32_t)(_n) & 0xff) << 0)
#define CAN_PL1_HI_Data_byte_7_INSERT(_v, _n)        (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_PL1_HI_Data_byte_7_EXTRACT(_v)           (((_v) >> 0) & 0xff)
                                                                        // Payload Filter 1 high order bits for Pretended Networking payload filtering corresponding to the data byte 6.
#define CAN_PL1_HI_Data_byte_6(_n)               (((uint32_t)(_n) & 0xff) << 8)
#define CAN_PL1_HI_Data_byte_6_INSERT(_v, _n)        (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_PL1_HI_Data_byte_6_EXTRACT(_v)           (((_v) >> 8) & 0xff)
                                                                        // Payload Filter 1 high order bits for Pretended Networking payload filtering corresponding to the data byte 5.
#define CAN_PL1_HI_Data_byte_5(_n)               (((uint32_t)(_n) & 0xff) << 16)
#define CAN_PL1_HI_Data_byte_5_INSERT(_v, _n)        (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_PL1_HI_Data_byte_5_EXTRACT(_v)           (((_v) >> 16) & 0xff)
                                                                        // Payload Filter 1 high order bits for Pretended Networking payload filtering corresponding to the data byte 4.
#define CAN_PL1_HI_Data_byte_4(_n)               (((uint32_t)(_n) & 0xff) << 24)
#define CAN_PL1_HI_Data_byte_4_INSERT(_v, _n)        (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_PL1_HI_Data_byte_4_EXTRACT(_v)           (((_v) >> 24) & 0xff)

    uint32_t             FLT_ID2_IDMASK;                                // Pretended Networking ID Filter 2 Register / ID Mask Register
                                                                        // ID Filter 2 for Pretended Networking Filtering / ID Mask Bits for Pretended Networking ID Filtering
#define CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK(_n)    (((uint32_t)(_n) & 0x1fffffff) << 0)
#define CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_INSERT(_v, _n) (((_v) & ~0x1fffffff) | ((uint32_t)(_n) & 0x1fffffff) << 0)
#define CAN_FLT_ID2_IDMASK_FLT_ID2_IDMASK_EXTRACT(_v) (((_v) >> 0) & 0x1fffffff)
#define CAN_FLT_ID2_IDMASK_RTR_MSK               ((uint32_t)1 << 29)    // Remote Transmission Request Mask Bit
#define   CAN_FLT_ID2_IDMASK_RTR_MSK_0           (uint32_t)0x0          // The corresponding bit in the filter is "don't care"
#define   CAN_FLT_ID2_IDMASK_RTR_MSK_1           (uint32_t)0x1          // The corresponding bit in the filter is checked
#define CAN_FLT_ID2_IDMASK_IDE_MSK               ((uint32_t)1 << 30)    // ID Extended Mask Bit
#define   CAN_FLT_ID2_IDMASK_IDE_MSK_0           (uint32_t)0x0          // The corresponding bit in the filter is "don't care"
#define   CAN_FLT_ID2_IDMASK_IDE_MSK_1           (uint32_t)0x1          // The corresponding bit in the filter is checked

    uint32_t             PL2_PLMASK_LO;                                 // Pretended Networking Payload Low Filter 2 Register / Payload Low Mask Register
                                                                        // Payload Filter 2 low order bits / Payload Mask low order bits for Pretended Networking payload filtering corresponding to the data byte 3.
#define CAN_PL2_PLMASK_LO_Data_byte_3(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CAN_PL2_PLMASK_LO_Data_byte_3_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_PL2_PLMASK_LO_Data_byte_3_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Payload Filter 2 low order bits / Payload Mask low order bits for Pretended Networking payload filtering corresponding to the data byte 2.
#define CAN_PL2_PLMASK_LO_Data_byte_2(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CAN_PL2_PLMASK_LO_Data_byte_2_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_PL2_PLMASK_LO_Data_byte_2_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Payload Filter 2 low order bits / Payload Mask low order bits for Pretended Networking payload filtering corresponding to the data byte 1.
#define CAN_PL2_PLMASK_LO_Data_byte_1(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CAN_PL2_PLMASK_LO_Data_byte_1_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_PL2_PLMASK_LO_Data_byte_1_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Payload Filter 2 low order bits / Payload Mask low order bits for Pretended Networking payload filtering corresponding to the data byte 0.
#define CAN_PL2_PLMASK_LO_Data_byte_0(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CAN_PL2_PLMASK_LO_Data_byte_0_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_PL2_PLMASK_LO_Data_byte_0_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint32_t             PL2_PLMASK_HI;                                 // Pretended Networking Payload High Filter 2 low order bits / Payload High Mask Register
                                                                        // Payload Filter 2 high order bits / Payload Mask high order bits for Pretended Networking payload filtering corresponding to the data byte 7.
#define CAN_PL2_PLMASK_HI_Data_byte_7(_n)        (((uint32_t)(_n) & 0xff) << 0)
#define CAN_PL2_PLMASK_HI_Data_byte_7_INSERT(_v, _n) (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CAN_PL2_PLMASK_HI_Data_byte_7_EXTRACT(_v)    (((_v) >> 0) & 0xff)
                                                                        // Payload Filter 2 high order bits / Payload Mask high order bits for Pretended Networking payload filtering corresponding to the data byte 6.
#define CAN_PL2_PLMASK_HI_Data_byte_6(_n)        (((uint32_t)(_n) & 0xff) << 8)
#define CAN_PL2_PLMASK_HI_Data_byte_6_INSERT(_v, _n) (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CAN_PL2_PLMASK_HI_Data_byte_6_EXTRACT(_v)    (((_v) >> 8) & 0xff)
                                                                        // Payload Filter 2 high order bits / Payload Mask high order bits for Pretended Networking payload filtering corresponding to the data byte 5.
#define CAN_PL2_PLMASK_HI_Data_byte_5(_n)        (((uint32_t)(_n) & 0xff) << 16)
#define CAN_PL2_PLMASK_HI_Data_byte_5_INSERT(_v, _n) (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CAN_PL2_PLMASK_HI_Data_byte_5_EXTRACT(_v)    (((_v) >> 16) & 0xff)
                                                                        // Payload Filter 2 high order bits / Payload Mask high order bits for Pretended Networking payload filtering corresponding to the data byte 4.
#define CAN_PL2_PLMASK_HI_Data_byte_4(_n)        (((uint32_t)(_n) & 0xff) << 24)
#define CAN_PL2_PLMASK_HI_Data_byte_4_INSERT(_v, _n) (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CAN_PL2_PLMASK_HI_Data_byte_4_EXTRACT(_v)    (((_v) >> 24) & 0xff)

    uint8_t _res7[24];
    const uint32_t       WMB0_CS;                                       // Wake Up Message Buffer Register for C/S
                                                                        // Length of Data in Bytes
#define CAN_WMB0_CS_DLC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define CAN_WMB0_CS_RTR                          ((uint32_t)1 << 20)    // Remote Transmission Request Bit
#define   CAN_WMB0_CS_RTR_0                      (uint32_t)0x0          // Frame is data one (not remote)
#define   CAN_WMB0_CS_RTR_1                      (uint32_t)0x1          // Frame is a remote one
#define CAN_WMB0_CS_IDE                          ((uint32_t)1 << 21)    // ID Extended Bit
#define   CAN_WMB0_CS_IDE_0                      (uint32_t)0x0          // Frame format is standard
#define   CAN_WMB0_CS_IDE_1                      (uint32_t)0x1          // Frame format is extended
#define CAN_WMB0_CS_SRR                          ((uint32_t)1 << 22)    // Substitute Remote Request

    const uint32_t       WMB0_ID;                                       // Wake Up Message Buffer Register for ID
                                                                        // Received ID under Pretended Networking mode
#define CAN_WMB0_ID_ID_EXTRACT(_v)                   (((_v) >> 0) & 0x1fffffff)

    const uint32_t       WMB0_D03;                                      // Wake Up Message Buffer Register for Data 0-3
                                                                        // Received payload corresponding to the data byte 3 under Pretended Networking mode
#define CAN_WMB0_D03_Data_byte_3_EXTRACT(_v)         (((_v) >> 0) & 0xff)
                                                                        // Received payload corresponding to the data byte 2 under Pretended Networking mode
#define CAN_WMB0_D03_Data_byte_2_EXTRACT(_v)         (((_v) >> 8) & 0xff)
                                                                        // Received payload corresponding to the data byte 1 under Pretended Networking mode
#define CAN_WMB0_D03_Data_byte_1_EXTRACT(_v)         (((_v) >> 16) & 0xff)
                                                                        // Received payload corresponding to the data byte 0 under Pretended Networking mode
#define CAN_WMB0_D03_Data_byte_0_EXTRACT(_v)         (((_v) >> 24) & 0xff)

    const uint32_t       WMB0_D47;                                      // Wake Up Message Buffer Register Data 4-7
                                                                        // Received payload corresponding to the data byte 7 under Pretended Networking mode
#define CAN_WMB0_D47_Data_byte_7_EXTRACT(_v)         (((_v) >> 0) & 0xff)
                                                                        // Received payload corresponding to the data byte 6 under Pretended Networking mode
#define CAN_WMB0_D47_Data_byte_6_EXTRACT(_v)         (((_v) >> 8) & 0xff)
                                                                        // Received payload corresponding to the data byte 5 under Pretended Networking mode
#define CAN_WMB0_D47_Data_byte_5_EXTRACT(_v)         (((_v) >> 16) & 0xff)
                                                                        // Received payload corresponding to the data byte 4 under Pretended Networking mode
#define CAN_WMB0_D47_Data_byte_4_EXTRACT(_v)         (((_v) >> 24) & 0xff)

    const uint32_t       WMB1_CS;                                       // Wake Up Message Buffer Register for C/S
                                                                        // Length of Data in Bytes
#define CAN_WMB1_CS_DLC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define CAN_WMB1_CS_RTR                          ((uint32_t)1 << 20)    // Remote Transmission Request Bit
#define   CAN_WMB1_CS_RTR_0                      (uint32_t)0x0          // Frame is data one (not remote)
#define   CAN_WMB1_CS_RTR_1                      (uint32_t)0x1          // Frame is a remote one
#define CAN_WMB1_CS_IDE                          ((uint32_t)1 << 21)    // ID Extended Bit
#define   CAN_WMB1_CS_IDE_0                      (uint32_t)0x0          // Frame format is standard
#define   CAN_WMB1_CS_IDE_1                      (uint32_t)0x1          // Frame format is extended
#define CAN_WMB1_CS_SRR                          ((uint32_t)1 << 22)    // Substitute Remote Request

    const uint32_t       WMB1_ID;                                       // Wake Up Message Buffer Register for ID
                                                                        // Received ID under Pretended Networking mode
#define CAN_WMB1_ID_ID_EXTRACT(_v)                   (((_v) >> 0) & 0x1fffffff)

    const uint32_t       WMB1_D03;                                      // Wake Up Message Buffer Register for Data 0-3
                                                                        // Received payload corresponding to the data byte 3 under Pretended Networking mode
#define CAN_WMB1_D03_Data_byte_3_EXTRACT(_v)         (((_v) >> 0) & 0xff)
                                                                        // Received payload corresponding to the data byte 2 under Pretended Networking mode
#define CAN_WMB1_D03_Data_byte_2_EXTRACT(_v)         (((_v) >> 8) & 0xff)
                                                                        // Received payload corresponding to the data byte 1 under Pretended Networking mode
#define CAN_WMB1_D03_Data_byte_1_EXTRACT(_v)         (((_v) >> 16) & 0xff)
                                                                        // Received payload corresponding to the data byte 0 under Pretended Networking mode
#define CAN_WMB1_D03_Data_byte_0_EXTRACT(_v)         (((_v) >> 24) & 0xff)

    const uint32_t       WMB1_D47;                                      // Wake Up Message Buffer Register Data 4-7
                                                                        // Received payload corresponding to the data byte 7 under Pretended Networking mode
#define CAN_WMB1_D47_Data_byte_7_EXTRACT(_v)         (((_v) >> 0) & 0xff)
                                                                        // Received payload corresponding to the data byte 6 under Pretended Networking mode
#define CAN_WMB1_D47_Data_byte_6_EXTRACT(_v)         (((_v) >> 8) & 0xff)
                                                                        // Received payload corresponding to the data byte 5 under Pretended Networking mode
#define CAN_WMB1_D47_Data_byte_5_EXTRACT(_v)         (((_v) >> 16) & 0xff)
                                                                        // Received payload corresponding to the data byte 4 under Pretended Networking mode
#define CAN_WMB1_D47_Data_byte_4_EXTRACT(_v)         (((_v) >> 24) & 0xff)

    const uint32_t       WMB2_CS;                                       // Wake Up Message Buffer Register for C/S
                                                                        // Length of Data in Bytes
#define CAN_WMB2_CS_DLC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define CAN_WMB2_CS_RTR                          ((uint32_t)1 << 20)    // Remote Transmission Request Bit
#define   CAN_WMB2_CS_RTR_0                      (uint32_t)0x0          // Frame is data one (not remote)
#define   CAN_WMB2_CS_RTR_1                      (uint32_t)0x1          // Frame is a remote one
#define CAN_WMB2_CS_IDE                          ((uint32_t)1 << 21)    // ID Extended Bit
#define   CAN_WMB2_CS_IDE_0                      (uint32_t)0x0          // Frame format is standard
#define   CAN_WMB2_CS_IDE_1                      (uint32_t)0x1          // Frame format is extended
#define CAN_WMB2_CS_SRR                          ((uint32_t)1 << 22)    // Substitute Remote Request

    const uint32_t       WMB2_ID;                                       // Wake Up Message Buffer Register for ID
                                                                        // Received ID under Pretended Networking mode
#define CAN_WMB2_ID_ID_EXTRACT(_v)                   (((_v) >> 0) & 0x1fffffff)

    const uint32_t       WMB2_D03;                                      // Wake Up Message Buffer Register for Data 0-3
                                                                        // Received payload corresponding to the data byte 3 under Pretended Networking mode
#define CAN_WMB2_D03_Data_byte_3_EXTRACT(_v)         (((_v) >> 0) & 0xff)
                                                                        // Received payload corresponding to the data byte 2 under Pretended Networking mode
#define CAN_WMB2_D03_Data_byte_2_EXTRACT(_v)         (((_v) >> 8) & 0xff)
                                                                        // Received payload corresponding to the data byte 1 under Pretended Networking mode
#define CAN_WMB2_D03_Data_byte_1_EXTRACT(_v)         (((_v) >> 16) & 0xff)
                                                                        // Received payload corresponding to the data byte 0 under Pretended Networking mode
#define CAN_WMB2_D03_Data_byte_0_EXTRACT(_v)         (((_v) >> 24) & 0xff)

    const uint32_t       WMB2_D47;                                      // Wake Up Message Buffer Register Data 4-7
                                                                        // Received payload corresponding to the data byte 7 under Pretended Networking mode
#define CAN_WMB2_D47_Data_byte_7_EXTRACT(_v)         (((_v) >> 0) & 0xff)
                                                                        // Received payload corresponding to the data byte 6 under Pretended Networking mode
#define CAN_WMB2_D47_Data_byte_6_EXTRACT(_v)         (((_v) >> 8) & 0xff)
                                                                        // Received payload corresponding to the data byte 5 under Pretended Networking mode
#define CAN_WMB2_D47_Data_byte_5_EXTRACT(_v)         (((_v) >> 16) & 0xff)
                                                                        // Received payload corresponding to the data byte 4 under Pretended Networking mode
#define CAN_WMB2_D47_Data_byte_4_EXTRACT(_v)         (((_v) >> 24) & 0xff)

    const uint32_t       WMB3_CS;                                       // Wake Up Message Buffer Register for C/S
                                                                        // Length of Data in Bytes
#define CAN_WMB3_CS_DLC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define CAN_WMB3_CS_RTR                          ((uint32_t)1 << 20)    // Remote Transmission Request Bit
#define   CAN_WMB3_CS_RTR_0                      (uint32_t)0x0          // Frame is data one (not remote)
#define   CAN_WMB3_CS_RTR_1                      (uint32_t)0x1          // Frame is a remote one
#define CAN_WMB3_CS_IDE                          ((uint32_t)1 << 21)    // ID Extended Bit
#define   CAN_WMB3_CS_IDE_0                      (uint32_t)0x0          // Frame format is standard
#define   CAN_WMB3_CS_IDE_1                      (uint32_t)0x1          // Frame format is extended
#define CAN_WMB3_CS_SRR                          ((uint32_t)1 << 22)    // Substitute Remote Request

    const uint32_t       WMB3_ID;                                       // Wake Up Message Buffer Register for ID
                                                                        // Received ID under Pretended Networking mode
#define CAN_WMB3_ID_ID_EXTRACT(_v)                   (((_v) >> 0) & 0x1fffffff)

    const uint32_t       WMB3_D03;                                      // Wake Up Message Buffer Register for Data 0-3
                                                                        // Received payload corresponding to the data byte 3 under Pretended Networking mode
#define CAN_WMB3_D03_Data_byte_3_EXTRACT(_v)         (((_v) >> 0) & 0xff)
                                                                        // Received payload corresponding to the data byte 2 under Pretended Networking mode
#define CAN_WMB3_D03_Data_byte_2_EXTRACT(_v)         (((_v) >> 8) & 0xff)
                                                                        // Received payload corresponding to the data byte 1 under Pretended Networking mode
#define CAN_WMB3_D03_Data_byte_1_EXTRACT(_v)         (((_v) >> 16) & 0xff)
                                                                        // Received payload corresponding to the data byte 0 under Pretended Networking mode
#define CAN_WMB3_D03_Data_byte_0_EXTRACT(_v)         (((_v) >> 24) & 0xff)

    const uint32_t       WMB3_D47;                                      // Wake Up Message Buffer Register Data 4-7
                                                                        // Received payload corresponding to the data byte 7 under Pretended Networking mode
#define CAN_WMB3_D47_Data_byte_7_EXTRACT(_v)         (((_v) >> 0) & 0xff)
                                                                        // Received payload corresponding to the data byte 6 under Pretended Networking mode
#define CAN_WMB3_D47_Data_byte_6_EXTRACT(_v)         (((_v) >> 8) & 0xff)
                                                                        // Received payload corresponding to the data byte 5 under Pretended Networking mode
#define CAN_WMB3_D47_Data_byte_5_EXTRACT(_v)         (((_v) >> 16) & 0xff)
                                                                        // Received payload corresponding to the data byte 4 under Pretended Networking mode
#define CAN_WMB3_D47_Data_byte_4_EXTRACT(_v)         (((_v) >> 24) & 0xff)

    uint8_t _res8[128];
    uint32_t             FDCTRL;                                        // CAN FD Control Register
                                                                        // Transceiver Delay Compensation Value
#define CAN_FDCTRL_TDCVAL(_n)                    (((uint32_t)(_n) & 0x3f) << 0)
#define CAN_FDCTRL_TDCVAL_INSERT(_v, _n)             (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define CAN_FDCTRL_TDCVAL_EXTRACT(_v)                (((_v) >> 0) & 0x3f)
                                                                        // Transceiver Delay Compensation Offset
#define CAN_FDCTRL_TDCOFF(_n)                    (((uint32_t)(_n) & 0x1f) << 8)
#define CAN_FDCTRL_TDCOFF_INSERT(_v, _n)             (((_v) & ~0x1f00) | ((uint32_t)(_n) & 0x1f) << 8)
#define CAN_FDCTRL_TDCOFF_EXTRACT(_v)                (((_v) >> 8) & 0x1f)
#define CAN_FDCTRL_TDCFAIL                       ((uint32_t)1 << 14)    // Transceiver Delay Compensation Fail
#define   CAN_FDCTRL_TDCFAIL_0                   (uint32_t)0x0          // Measured loop delay is in range.
#define   CAN_FDCTRL_TDCFAIL_1                   (uint32_t)0x1          // Measured loop delay is out of range.
#define CAN_FDCTRL_TDCEN                         ((uint32_t)1 << 15)    // Transceiver Delay Compensation Enable
#define   CAN_FDCTRL_TDCEN_0                     (uint32_t)0x0          // TDC is disabled
#define   CAN_FDCTRL_TDCEN_1                     (uint32_t)0x1          // TDC is enabled
                                                                        // Message Buffer Data Size for Region 0
#define CAN_FDCTRL_MBDSR0(_n)                    (((uint32_t)(_n) & 0x3) << 16)
#define CAN_FDCTRL_MBDSR0_INSERT(_v, _n)             (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define CAN_FDCTRL_MBDSR0_EXTRACT(_v)                (((_v) >> 16) & 0x3)
#define   CAN_FDCTRL_MBDSR0_00                   (uint32_t)0x0          // Selects 8 bytes per Message Buffer.
#define   CAN_FDCTRL_MBDSR0_01                   (uint32_t)0x1          // Selects 16 bytes per Message Buffer.
#define   CAN_FDCTRL_MBDSR0_10                   (uint32_t)0x2          // Selects 32 bytes per Message Buffer.
#define   CAN_FDCTRL_MBDSR0_11                   (uint32_t)0x3          // Selects 64 bytes per Message Buffer.
#define CAN_FDCTRL_FDRATE                        ((uint32_t)1 << 31)    // Bit Rate Switch Enable
#define   CAN_FDCTRL_FDRATE_0                    (uint32_t)0x0          // Transmit a frame in nominal rate. The BRS bit in the Tx MB has no effect.
#define   CAN_FDCTRL_FDRATE_1                    (uint32_t)0x1          // Transmit a frame with bit rate switching if the BRS bit in the Tx MB is recessive.

    uint32_t             FDCBT;                                         // CAN FD Bit Timing Register
                                                                        // Fast Phase Segment 2
#define CAN_FDCBT_FPSEG2(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define CAN_FDCBT_FPSEG2_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define CAN_FDCBT_FPSEG2_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
                                                                        // Fast Phase Segment 1
#define CAN_FDCBT_FPSEG1(_n)                     (((uint32_t)(_n) & 0x7) << 5)
#define CAN_FDCBT_FPSEG1_INSERT(_v, _n)              (((_v) & ~0xe0) | ((uint32_t)(_n) & 0x7) << 5)
#define CAN_FDCBT_FPSEG1_EXTRACT(_v)                 (((_v) >> 5) & 0x7)
                                                                        // Fast Propagation Segment
#define CAN_FDCBT_FPROPSEG(_n)                   (((uint32_t)(_n) & 0x1f) << 10)
#define CAN_FDCBT_FPROPSEG_INSERT(_v, _n)            (((_v) & ~0x7c00) | ((uint32_t)(_n) & 0x1f) << 10)
#define CAN_FDCBT_FPROPSEG_EXTRACT(_v)               (((_v) >> 10) & 0x1f)
                                                                        // Fast Resync Jump Width
#define CAN_FDCBT_FRJW(_n)                       (((uint32_t)(_n) & 0x7) << 16)
#define CAN_FDCBT_FRJW_INSERT(_v, _n)                (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define CAN_FDCBT_FRJW_EXTRACT(_v)                   (((_v) >> 16) & 0x7)
                                                                        // Fast Prescaler Division Factor
#define CAN_FDCBT_FPRESDIV(_n)                   (((uint32_t)(_n) & 0x3ff) << 20)
#define CAN_FDCBT_FPRESDIV_INSERT(_v, _n)            (((_v) & ~0x3ff00000) | ((uint32_t)(_n) & 0x3ff) << 20)
#define CAN_FDCBT_FPRESDIV_EXTRACT(_v)               (((_v) >> 20) & 0x3ff)

    const uint32_t       FDCRC;                                         // CAN FD CRC Register
                                                                        // Extended Transmitted CRC value
#define CAN_FDCRC_FD_TXCRC_EXTRACT(_v)               (((_v) >> 0) & 0x1fffff)
                                                                        // CRC Mailbox Number for FD_TXCRC
#define CAN_FDCRC_FD_MBCRC_EXTRACT(_v)               (((_v) >> 24) & 0x7f)

} CAN_regs_t;
                                                                        // --------------------
                                                                        // FlexTimer Module
typedef struct                                                          // --------------------
{
    uint32_t             SC;                                            // Status And Control
                                                                        // Prescale Factor Selection
#define FTM_SC_PS(_n)                            (((uint32_t)(_n) & 0x7) << 0)
#define FTM_SC_PS_INSERT(_v, _n)                     (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define FTM_SC_PS_EXTRACT(_v)                        (((_v) >> 0) & 0x7)
#define   FTM_SC_PS_000                          (uint32_t)0x0          // Divide by 1
#define   FTM_SC_PS_001                          (uint32_t)0x1          // Divide by 2
#define   FTM_SC_PS_010                          (uint32_t)0x2          // Divide by 4
#define   FTM_SC_PS_011                          (uint32_t)0x3          // Divide by 8
#define   FTM_SC_PS_100                          (uint32_t)0x4          // Divide by 16
#define   FTM_SC_PS_101                          (uint32_t)0x5          // Divide by 32
#define   FTM_SC_PS_110                          (uint32_t)0x6          // Divide by 64
#define   FTM_SC_PS_111                          (uint32_t)0x7          // Divide by 128
                                                                        // Clock Source Selection
#define FTM_SC_CLKS(_n)                          (((uint32_t)(_n) & 0x3) << 3)
#define FTM_SC_CLKS_INSERT(_v, _n)                   (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define FTM_SC_CLKS_EXTRACT(_v)                      (((_v) >> 3) & 0x3)
#define   FTM_SC_CLKS_00                         (uint32_t)0x0          // No clock selected. This in effect disables the FTM counter.
#define   FTM_SC_CLKS_01                         (uint32_t)0x1          // FTM input clock
#define   FTM_SC_CLKS_10                         (uint32_t)0x2          // Fixed frequency clock
#define   FTM_SC_CLKS_11                         (uint32_t)0x3          // External clock
#define FTM_SC_CPWMS                             ((uint32_t)1 << 5)     // Center-Aligned PWM Select
#define   FTM_SC_CPWMS_0                         (uint32_t)0x0          // FTM counter operates in Up Counting mode.
#define   FTM_SC_CPWMS_1                         (uint32_t)0x1          // FTM counter operates in Up-Down Counting mode.
#define FTM_SC_RIE                               ((uint32_t)1 << 6)     // Reload Point Interrupt Enable
#define   FTM_SC_RIE_0                           (uint32_t)0x0          // Reload point interrupt is disabled.
#define   FTM_SC_RIE_1                           (uint32_t)0x1          // Reload point interrupt is enabled.
#define FTM_SC_RF                                ((uint32_t)1 << 7)     // Reload Flag
#define   FTM_SC_RF_0                            (uint32_t)0x0          // A selected reload point did not happen.
#define   FTM_SC_RF_1                            (uint32_t)0x1          // A selected reload point happened.
#define FTM_SC_TOIE                              ((uint32_t)1 << 8)     // Timer Overflow Interrupt Enable
#define   FTM_SC_TOIE_0                          (uint32_t)0x0          // Disable TOF interrupts. Use software polling.
#define   FTM_SC_TOIE_1                          (uint32_t)0x1          // Enable TOF interrupts. An interrupt is generated when TOF equals one.
#define FTM_SC_TOF                               ((uint32_t)1 << 9)     // Timer Overflow Flag
#define   FTM_SC_TOF_0                           (uint32_t)0x0          // FTM counter has not overflowed.
#define   FTM_SC_TOF_1                           (uint32_t)0x1          // FTM counter has overflowed.
#define FTM_SC_PWMEN0                            ((uint32_t)1 << 16)    // Channel 0 PWM enable bit
#define   FTM_SC_PWMEN0_0                        (uint32_t)0x0          // Channel output port is disabled
#define   FTM_SC_PWMEN0_1                        (uint32_t)0x1          // Channel output port is enabled
#define FTM_SC_PWMEN1                            ((uint32_t)1 << 17)    // Channel 1 PWM enable bit
#define   FTM_SC_PWMEN1_0                        (uint32_t)0x0          // Channel output port is disabled
#define   FTM_SC_PWMEN1_1                        (uint32_t)0x1          // Channel output port is enabled
#define FTM_SC_PWMEN2                            ((uint32_t)1 << 18)    // Channel 2 PWM enable bit
#define   FTM_SC_PWMEN2_0                        (uint32_t)0x0          // Channel output port is disabled
#define   FTM_SC_PWMEN2_1                        (uint32_t)0x1          // Channel output port is enabled
#define FTM_SC_PWMEN3                            ((uint32_t)1 << 19)    // Channel 3 PWM enable bit
#define   FTM_SC_PWMEN3_0                        (uint32_t)0x0          // Channel output port is disabled
#define   FTM_SC_PWMEN3_1                        (uint32_t)0x1          // Channel output port is enabled
#define FTM_SC_PWMEN4                            ((uint32_t)1 << 20)    // Channel 4 PWM enable bit
#define   FTM_SC_PWMEN4_0                        (uint32_t)0x0          // Channel output port is disabled
#define   FTM_SC_PWMEN4_1                        (uint32_t)0x1          // Channel output port is enabled
#define FTM_SC_PWMEN5                            ((uint32_t)1 << 21)    // Channel 5 PWM enable bit
#define   FTM_SC_PWMEN5_0                        (uint32_t)0x0          // Channel output port is disabled
#define   FTM_SC_PWMEN5_1                        (uint32_t)0x1          // Channel output port is enabled
#define FTM_SC_PWMEN6                            ((uint32_t)1 << 22)    // Channel 6 PWM enable bit
#define   FTM_SC_PWMEN6_0                        (uint32_t)0x0          // Channel output port is disabled
#define   FTM_SC_PWMEN6_1                        (uint32_t)0x1          // Channel output port is enabled
#define FTM_SC_PWMEN7                            ((uint32_t)1 << 23)    // Channel 7 PWM enable bit
#define   FTM_SC_PWMEN7_0                        (uint32_t)0x0          // Channel output port is disabled
#define   FTM_SC_PWMEN7_1                        (uint32_t)0x1          // Channel output port is enabled
                                                                        // Filter Prescaler
#define FTM_SC_FLTPS(_n)                         (((uint32_t)(_n) & 0xf) << 24)
#define FTM_SC_FLTPS_INSERT(_v, _n)                  (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define FTM_SC_FLTPS_EXTRACT(_v)                     (((_v) >> 24) & 0xf)
#define   FTM_SC_FLTPS_0000                      (uint32_t)0x0          // Divide by 1
#define   FTM_SC_FLTPS_0001                      (uint32_t)0x1          // Divide by 2
#define   FTM_SC_FLTPS_0010                      (uint32_t)0x2          // Divide by 3
#define   FTM_SC_FLTPS_0011                      (uint32_t)0x3          // Divide by 4
#define   FTM_SC_FLTPS_0100                      (uint32_t)0x4          // Divide by 5
#define   FTM_SC_FLTPS_0101                      (uint32_t)0x5          // Divide by 6
#define   FTM_SC_FLTPS_0110                      (uint32_t)0x6          // Divide by 7
#define   FTM_SC_FLTPS_0111                      (uint32_t)0x7          // Divide by 8
#define   FTM_SC_FLTPS_1000                      (uint32_t)0x8          // Divide by 9
#define   FTM_SC_FLTPS_1001                      (uint32_t)0x9          // Divide by 10
#define   FTM_SC_FLTPS_1010                      (uint32_t)0xa          // Divide by 11
#define   FTM_SC_FLTPS_1011                      (uint32_t)0xb          // Divide by 12
#define   FTM_SC_FLTPS_1100                      (uint32_t)0xc          // Divide by 13
#define   FTM_SC_FLTPS_1101                      (uint32_t)0xd          // Divide by 14
#define   FTM_SC_FLTPS_1110                      (uint32_t)0xe          // Divide by 15
#define   FTM_SC_FLTPS_1111                      (uint32_t)0xf          // Divide by 16

    uint32_t             CNT;                                           // Counter
                                                                        // Counter Value
#define FTM_CNT_COUNT(_n)                        (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_CNT_COUNT_INSERT(_v, _n)                 (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_CNT_COUNT_EXTRACT(_v)                    (((_v) >> 0) & 0xffff)

    uint32_t             MOD;                                           // Modulo
                                                                        // MOD
#define FTM_MOD_MOD(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_MOD_MOD_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_MOD_MOD_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             C0SC;                                          // Channel (n) Status And Control
#define FTM_C0SC_DMA                             ((uint32_t)1 << 0)     // DMA Enable
#define   FTM_C0SC_DMA_0                         (uint32_t)0x0          // Disable DMA transfers.
#define   FTM_C0SC_DMA_1                         (uint32_t)0x1          // Enable DMA transfers.
#define FTM_C0SC_ICRST                           ((uint32_t)1 << 1)     // FTM counter reset by the selected input capture event.
#define   FTM_C0SC_ICRST_0                       (uint32_t)0x0          // FTM counter is not reset when the selected channel (n) input event is detected.
#define   FTM_C0SC_ICRST_1                       (uint32_t)0x1          // FTM counter is reset when the selected channel (n) input event is detected.
#define FTM_C0SC_ELSA                            ((uint32_t)1 << 2)     // Channel (n) Edge or Level Select
#define FTM_C0SC_ELSB                            ((uint32_t)1 << 3)     // Channel (n) Edge or Level Select
#define FTM_C0SC_MSA                             ((uint32_t)1 << 4)     // Channel (n) Mode Select
#define FTM_C0SC_MSB                             ((uint32_t)1 << 5)     // Channel (n) Mode Select
#define FTM_C0SC_CHIE                            ((uint32_t)1 << 6)     // Channel (n) Interrupt Enable
#define   FTM_C0SC_CHIE_0                        (uint32_t)0x0          // Disable channel (n) interrupt. Use software polling.
#define   FTM_C0SC_CHIE_1                        (uint32_t)0x1          // Enable channel (n) interrupt.
#define FTM_C0SC_CHF                             ((uint32_t)1 << 7)     // Channel (n) Flag
#define   FTM_C0SC_CHF_0                         (uint32_t)0x0          // No channel (n) event has occurred.
#define   FTM_C0SC_CHF_1                         (uint32_t)0x1          // A channel (n) event has occurred.
#define FTM_C0SC_TRIGMODE                        ((uint32_t)1 << 8)     // Trigger mode control
#define   FTM_C0SC_TRIGMODE_0                    (uint32_t)0x0          // Channel outputs will generate the normal PWM outputs without generating a pulse.
#define   FTM_C0SC_TRIGMODE_1                    (uint32_t)0x1          // If a match in the channel occurs, a trigger generation on channel output will happen. The trigger pulse width has one FTM clock cycle.
#define FTM_C0SC_CHIS                            ((uint32_t)1 << 9)     // Channel (n) Input State
#define   FTM_C0SC_CHIS_0                        (uint32_t)0x0          // The channel (n) input is zero.
#define   FTM_C0SC_CHIS_1                        (uint32_t)0x1          // The channel (n) input is one.
#define FTM_C0SC_CHOV                            ((uint32_t)1 << 10)    // Channel (n) Output Value
#define   FTM_C0SC_CHOV_0                        (uint32_t)0x0          // The channel (n) output is zero.
#define   FTM_C0SC_CHOV_1                        (uint32_t)0x1          // The channel (n) output is one.

    uint32_t             C0V;                                           // Channel (n) Value
                                                                        // Channel Value
#define FTM_C0V_VAL(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C0V_VAL_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C0V_VAL_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             C1SC;                                          // Channel (n) Status And Control
#define FTM_C1SC_DMA                             ((uint32_t)1 << 0)     // DMA Enable
#define   FTM_C1SC_DMA_0                         (uint32_t)0x0          // Disable DMA transfers.
#define   FTM_C1SC_DMA_1                         (uint32_t)0x1          // Enable DMA transfers.
#define FTM_C1SC_ICRST                           ((uint32_t)1 << 1)     // FTM counter reset by the selected input capture event.
#define   FTM_C1SC_ICRST_0                       (uint32_t)0x0          // FTM counter is not reset when the selected channel (n) input event is detected.
#define   FTM_C1SC_ICRST_1                       (uint32_t)0x1          // FTM counter is reset when the selected channel (n) input event is detected.
#define FTM_C1SC_ELSA                            ((uint32_t)1 << 2)     // Channel (n) Edge or Level Select
#define FTM_C1SC_ELSB                            ((uint32_t)1 << 3)     // Channel (n) Edge or Level Select
#define FTM_C1SC_MSA                             ((uint32_t)1 << 4)     // Channel (n) Mode Select
#define FTM_C1SC_MSB                             ((uint32_t)1 << 5)     // Channel (n) Mode Select
#define FTM_C1SC_CHIE                            ((uint32_t)1 << 6)     // Channel (n) Interrupt Enable
#define   FTM_C1SC_CHIE_0                        (uint32_t)0x0          // Disable channel (n) interrupt. Use software polling.
#define   FTM_C1SC_CHIE_1                        (uint32_t)0x1          // Enable channel (n) interrupt.
#define FTM_C1SC_CHF                             ((uint32_t)1 << 7)     // Channel (n) Flag
#define   FTM_C1SC_CHF_0                         (uint32_t)0x0          // No channel (n) event has occurred.
#define   FTM_C1SC_CHF_1                         (uint32_t)0x1          // A channel (n) event has occurred.
#define FTM_C1SC_TRIGMODE                        ((uint32_t)1 << 8)     // Trigger mode control
#define   FTM_C1SC_TRIGMODE_0                    (uint32_t)0x0          // Channel outputs will generate the normal PWM outputs without generating a pulse.
#define   FTM_C1SC_TRIGMODE_1                    (uint32_t)0x1          // If a match in the channel occurs, a trigger generation on channel output will happen. The trigger pulse width has one FTM clock cycle.
#define FTM_C1SC_CHIS                            ((uint32_t)1 << 9)     // Channel (n) Input State
#define   FTM_C1SC_CHIS_0                        (uint32_t)0x0          // The channel (n) input is zero.
#define   FTM_C1SC_CHIS_1                        (uint32_t)0x1          // The channel (n) input is one.
#define FTM_C1SC_CHOV                            ((uint32_t)1 << 10)    // Channel (n) Output Value
#define   FTM_C1SC_CHOV_0                        (uint32_t)0x0          // The channel (n) output is zero.
#define   FTM_C1SC_CHOV_1                        (uint32_t)0x1          // The channel (n) output is one.

    uint32_t             C1V;                                           // Channel (n) Value
                                                                        // Channel Value
#define FTM_C1V_VAL(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C1V_VAL_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C1V_VAL_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             C2SC;                                          // Channel (n) Status And Control
#define FTM_C2SC_DMA                             ((uint32_t)1 << 0)     // DMA Enable
#define   FTM_C2SC_DMA_0                         (uint32_t)0x0          // Disable DMA transfers.
#define   FTM_C2SC_DMA_1                         (uint32_t)0x1          // Enable DMA transfers.
#define FTM_C2SC_ICRST                           ((uint32_t)1 << 1)     // FTM counter reset by the selected input capture event.
#define   FTM_C2SC_ICRST_0                       (uint32_t)0x0          // FTM counter is not reset when the selected channel (n) input event is detected.
#define   FTM_C2SC_ICRST_1                       (uint32_t)0x1          // FTM counter is reset when the selected channel (n) input event is detected.
#define FTM_C2SC_ELSA                            ((uint32_t)1 << 2)     // Channel (n) Edge or Level Select
#define FTM_C2SC_ELSB                            ((uint32_t)1 << 3)     // Channel (n) Edge or Level Select
#define FTM_C2SC_MSA                             ((uint32_t)1 << 4)     // Channel (n) Mode Select
#define FTM_C2SC_MSB                             ((uint32_t)1 << 5)     // Channel (n) Mode Select
#define FTM_C2SC_CHIE                            ((uint32_t)1 << 6)     // Channel (n) Interrupt Enable
#define   FTM_C2SC_CHIE_0                        (uint32_t)0x0          // Disable channel (n) interrupt. Use software polling.
#define   FTM_C2SC_CHIE_1                        (uint32_t)0x1          // Enable channel (n) interrupt.
#define FTM_C2SC_CHF                             ((uint32_t)1 << 7)     // Channel (n) Flag
#define   FTM_C2SC_CHF_0                         (uint32_t)0x0          // No channel (n) event has occurred.
#define   FTM_C2SC_CHF_1                         (uint32_t)0x1          // A channel (n) event has occurred.
#define FTM_C2SC_TRIGMODE                        ((uint32_t)1 << 8)     // Trigger mode control
#define   FTM_C2SC_TRIGMODE_0                    (uint32_t)0x0          // Channel outputs will generate the normal PWM outputs without generating a pulse.
#define   FTM_C2SC_TRIGMODE_1                    (uint32_t)0x1          // If a match in the channel occurs, a trigger generation on channel output will happen. The trigger pulse width has one FTM clock cycle.
#define FTM_C2SC_CHIS                            ((uint32_t)1 << 9)     // Channel (n) Input State
#define   FTM_C2SC_CHIS_0                        (uint32_t)0x0          // The channel (n) input is zero.
#define   FTM_C2SC_CHIS_1                        (uint32_t)0x1          // The channel (n) input is one.
#define FTM_C2SC_CHOV                            ((uint32_t)1 << 10)    // Channel (n) Output Value
#define   FTM_C2SC_CHOV_0                        (uint32_t)0x0          // The channel (n) output is zero.
#define   FTM_C2SC_CHOV_1                        (uint32_t)0x1          // The channel (n) output is one.

    uint32_t             C2V;                                           // Channel (n) Value
                                                                        // Channel Value
#define FTM_C2V_VAL(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C2V_VAL_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C2V_VAL_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             C3SC;                                          // Channel (n) Status And Control
#define FTM_C3SC_DMA                             ((uint32_t)1 << 0)     // DMA Enable
#define   FTM_C3SC_DMA_0                         (uint32_t)0x0          // Disable DMA transfers.
#define   FTM_C3SC_DMA_1                         (uint32_t)0x1          // Enable DMA transfers.
#define FTM_C3SC_ICRST                           ((uint32_t)1 << 1)     // FTM counter reset by the selected input capture event.
#define   FTM_C3SC_ICRST_0                       (uint32_t)0x0          // FTM counter is not reset when the selected channel (n) input event is detected.
#define   FTM_C3SC_ICRST_1                       (uint32_t)0x1          // FTM counter is reset when the selected channel (n) input event is detected.
#define FTM_C3SC_ELSA                            ((uint32_t)1 << 2)     // Channel (n) Edge or Level Select
#define FTM_C3SC_ELSB                            ((uint32_t)1 << 3)     // Channel (n) Edge or Level Select
#define FTM_C3SC_MSA                             ((uint32_t)1 << 4)     // Channel (n) Mode Select
#define FTM_C3SC_MSB                             ((uint32_t)1 << 5)     // Channel (n) Mode Select
#define FTM_C3SC_CHIE                            ((uint32_t)1 << 6)     // Channel (n) Interrupt Enable
#define   FTM_C3SC_CHIE_0                        (uint32_t)0x0          // Disable channel (n) interrupt. Use software polling.
#define   FTM_C3SC_CHIE_1                        (uint32_t)0x1          // Enable channel (n) interrupt.
#define FTM_C3SC_CHF                             ((uint32_t)1 << 7)     // Channel (n) Flag
#define   FTM_C3SC_CHF_0                         (uint32_t)0x0          // No channel (n) event has occurred.
#define   FTM_C3SC_CHF_1                         (uint32_t)0x1          // A channel (n) event has occurred.
#define FTM_C3SC_TRIGMODE                        ((uint32_t)1 << 8)     // Trigger mode control
#define   FTM_C3SC_TRIGMODE_0                    (uint32_t)0x0          // Channel outputs will generate the normal PWM outputs without generating a pulse.
#define   FTM_C3SC_TRIGMODE_1                    (uint32_t)0x1          // If a match in the channel occurs, a trigger generation on channel output will happen. The trigger pulse width has one FTM clock cycle.
#define FTM_C3SC_CHIS                            ((uint32_t)1 << 9)     // Channel (n) Input State
#define   FTM_C3SC_CHIS_0                        (uint32_t)0x0          // The channel (n) input is zero.
#define   FTM_C3SC_CHIS_1                        (uint32_t)0x1          // The channel (n) input is one.
#define FTM_C3SC_CHOV                            ((uint32_t)1 << 10)    // Channel (n) Output Value
#define   FTM_C3SC_CHOV_0                        (uint32_t)0x0          // The channel (n) output is zero.
#define   FTM_C3SC_CHOV_1                        (uint32_t)0x1          // The channel (n) output is one.

    uint32_t             C3V;                                           // Channel (n) Value
                                                                        // Channel Value
#define FTM_C3V_VAL(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C3V_VAL_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C3V_VAL_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             C4SC;                                          // Channel (n) Status And Control
#define FTM_C4SC_DMA                             ((uint32_t)1 << 0)     // DMA Enable
#define   FTM_C4SC_DMA_0                         (uint32_t)0x0          // Disable DMA transfers.
#define   FTM_C4SC_DMA_1                         (uint32_t)0x1          // Enable DMA transfers.
#define FTM_C4SC_ICRST                           ((uint32_t)1 << 1)     // FTM counter reset by the selected input capture event.
#define   FTM_C4SC_ICRST_0                       (uint32_t)0x0          // FTM counter is not reset when the selected channel (n) input event is detected.
#define   FTM_C4SC_ICRST_1                       (uint32_t)0x1          // FTM counter is reset when the selected channel (n) input event is detected.
#define FTM_C4SC_ELSA                            ((uint32_t)1 << 2)     // Channel (n) Edge or Level Select
#define FTM_C4SC_ELSB                            ((uint32_t)1 << 3)     // Channel (n) Edge or Level Select
#define FTM_C4SC_MSA                             ((uint32_t)1 << 4)     // Channel (n) Mode Select
#define FTM_C4SC_MSB                             ((uint32_t)1 << 5)     // Channel (n) Mode Select
#define FTM_C4SC_CHIE                            ((uint32_t)1 << 6)     // Channel (n) Interrupt Enable
#define   FTM_C4SC_CHIE_0                        (uint32_t)0x0          // Disable channel (n) interrupt. Use software polling.
#define   FTM_C4SC_CHIE_1                        (uint32_t)0x1          // Enable channel (n) interrupt.
#define FTM_C4SC_CHF                             ((uint32_t)1 << 7)     // Channel (n) Flag
#define   FTM_C4SC_CHF_0                         (uint32_t)0x0          // No channel (n) event has occurred.
#define   FTM_C4SC_CHF_1                         (uint32_t)0x1          // A channel (n) event has occurred.
#define FTM_C4SC_TRIGMODE                        ((uint32_t)1 << 8)     // Trigger mode control
#define   FTM_C4SC_TRIGMODE_0                    (uint32_t)0x0          // Channel outputs will generate the normal PWM outputs without generating a pulse.
#define   FTM_C4SC_TRIGMODE_1                    (uint32_t)0x1          // If a match in the channel occurs, a trigger generation on channel output will happen. The trigger pulse width has one FTM clock cycle.
#define FTM_C4SC_CHIS                            ((uint32_t)1 << 9)     // Channel (n) Input State
#define   FTM_C4SC_CHIS_0                        (uint32_t)0x0          // The channel (n) input is zero.
#define   FTM_C4SC_CHIS_1                        (uint32_t)0x1          // The channel (n) input is one.
#define FTM_C4SC_CHOV                            ((uint32_t)1 << 10)    // Channel (n) Output Value
#define   FTM_C4SC_CHOV_0                        (uint32_t)0x0          // The channel (n) output is zero.
#define   FTM_C4SC_CHOV_1                        (uint32_t)0x1          // The channel (n) output is one.

    uint32_t             C4V;                                           // Channel (n) Value
                                                                        // Channel Value
#define FTM_C4V_VAL(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C4V_VAL_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C4V_VAL_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             C5SC;                                          // Channel (n) Status And Control
#define FTM_C5SC_DMA                             ((uint32_t)1 << 0)     // DMA Enable
#define   FTM_C5SC_DMA_0                         (uint32_t)0x0          // Disable DMA transfers.
#define   FTM_C5SC_DMA_1                         (uint32_t)0x1          // Enable DMA transfers.
#define FTM_C5SC_ICRST                           ((uint32_t)1 << 1)     // FTM counter reset by the selected input capture event.
#define   FTM_C5SC_ICRST_0                       (uint32_t)0x0          // FTM counter is not reset when the selected channel (n) input event is detected.
#define   FTM_C5SC_ICRST_1                       (uint32_t)0x1          // FTM counter is reset when the selected channel (n) input event is detected.
#define FTM_C5SC_ELSA                            ((uint32_t)1 << 2)     // Channel (n) Edge or Level Select
#define FTM_C5SC_ELSB                            ((uint32_t)1 << 3)     // Channel (n) Edge or Level Select
#define FTM_C5SC_MSA                             ((uint32_t)1 << 4)     // Channel (n) Mode Select
#define FTM_C5SC_MSB                             ((uint32_t)1 << 5)     // Channel (n) Mode Select
#define FTM_C5SC_CHIE                            ((uint32_t)1 << 6)     // Channel (n) Interrupt Enable
#define   FTM_C5SC_CHIE_0                        (uint32_t)0x0          // Disable channel (n) interrupt. Use software polling.
#define   FTM_C5SC_CHIE_1                        (uint32_t)0x1          // Enable channel (n) interrupt.
#define FTM_C5SC_CHF                             ((uint32_t)1 << 7)     // Channel (n) Flag
#define   FTM_C5SC_CHF_0                         (uint32_t)0x0          // No channel (n) event has occurred.
#define   FTM_C5SC_CHF_1                         (uint32_t)0x1          // A channel (n) event has occurred.
#define FTM_C5SC_TRIGMODE                        ((uint32_t)1 << 8)     // Trigger mode control
#define   FTM_C5SC_TRIGMODE_0                    (uint32_t)0x0          // Channel outputs will generate the normal PWM outputs without generating a pulse.
#define   FTM_C5SC_TRIGMODE_1                    (uint32_t)0x1          // If a match in the channel occurs, a trigger generation on channel output will happen. The trigger pulse width has one FTM clock cycle.
#define FTM_C5SC_CHIS                            ((uint32_t)1 << 9)     // Channel (n) Input State
#define   FTM_C5SC_CHIS_0                        (uint32_t)0x0          // The channel (n) input is zero.
#define   FTM_C5SC_CHIS_1                        (uint32_t)0x1          // The channel (n) input is one.
#define FTM_C5SC_CHOV                            ((uint32_t)1 << 10)    // Channel (n) Output Value
#define   FTM_C5SC_CHOV_0                        (uint32_t)0x0          // The channel (n) output is zero.
#define   FTM_C5SC_CHOV_1                        (uint32_t)0x1          // The channel (n) output is one.

    uint32_t             C5V;                                           // Channel (n) Value
                                                                        // Channel Value
#define FTM_C5V_VAL(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C5V_VAL_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C5V_VAL_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             C6SC;                                          // Channel (n) Status And Control
#define FTM_C6SC_DMA                             ((uint32_t)1 << 0)     // DMA Enable
#define   FTM_C6SC_DMA_0                         (uint32_t)0x0          // Disable DMA transfers.
#define   FTM_C6SC_DMA_1                         (uint32_t)0x1          // Enable DMA transfers.
#define FTM_C6SC_ICRST                           ((uint32_t)1 << 1)     // FTM counter reset by the selected input capture event.
#define   FTM_C6SC_ICRST_0                       (uint32_t)0x0          // FTM counter is not reset when the selected channel (n) input event is detected.
#define   FTM_C6SC_ICRST_1                       (uint32_t)0x1          // FTM counter is reset when the selected channel (n) input event is detected.
#define FTM_C6SC_ELSA                            ((uint32_t)1 << 2)     // Channel (n) Edge or Level Select
#define FTM_C6SC_ELSB                            ((uint32_t)1 << 3)     // Channel (n) Edge or Level Select
#define FTM_C6SC_MSA                             ((uint32_t)1 << 4)     // Channel (n) Mode Select
#define FTM_C6SC_MSB                             ((uint32_t)1 << 5)     // Channel (n) Mode Select
#define FTM_C6SC_CHIE                            ((uint32_t)1 << 6)     // Channel (n) Interrupt Enable
#define   FTM_C6SC_CHIE_0                        (uint32_t)0x0          // Disable channel (n) interrupt. Use software polling.
#define   FTM_C6SC_CHIE_1                        (uint32_t)0x1          // Enable channel (n) interrupt.
#define FTM_C6SC_CHF                             ((uint32_t)1 << 7)     // Channel (n) Flag
#define   FTM_C6SC_CHF_0                         (uint32_t)0x0          // No channel (n) event has occurred.
#define   FTM_C6SC_CHF_1                         (uint32_t)0x1          // A channel (n) event has occurred.
#define FTM_C6SC_TRIGMODE                        ((uint32_t)1 << 8)     // Trigger mode control
#define   FTM_C6SC_TRIGMODE_0                    (uint32_t)0x0          // Channel outputs will generate the normal PWM outputs without generating a pulse.
#define   FTM_C6SC_TRIGMODE_1                    (uint32_t)0x1          // If a match in the channel occurs, a trigger generation on channel output will happen. The trigger pulse width has one FTM clock cycle.
#define FTM_C6SC_CHIS                            ((uint32_t)1 << 9)     // Channel (n) Input State
#define   FTM_C6SC_CHIS_0                        (uint32_t)0x0          // The channel (n) input is zero.
#define   FTM_C6SC_CHIS_1                        (uint32_t)0x1          // The channel (n) input is one.
#define FTM_C6SC_CHOV                            ((uint32_t)1 << 10)    // Channel (n) Output Value
#define   FTM_C6SC_CHOV_0                        (uint32_t)0x0          // The channel (n) output is zero.
#define   FTM_C6SC_CHOV_1                        (uint32_t)0x1          // The channel (n) output is one.

    uint32_t             C6V;                                           // Channel (n) Value
                                                                        // Channel Value
#define FTM_C6V_VAL(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C6V_VAL_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C6V_VAL_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             C7SC;                                          // Channel (n) Status And Control
#define FTM_C7SC_DMA                             ((uint32_t)1 << 0)     // DMA Enable
#define   FTM_C7SC_DMA_0                         (uint32_t)0x0          // Disable DMA transfers.
#define   FTM_C7SC_DMA_1                         (uint32_t)0x1          // Enable DMA transfers.
#define FTM_C7SC_ICRST                           ((uint32_t)1 << 1)     // FTM counter reset by the selected input capture event.
#define   FTM_C7SC_ICRST_0                       (uint32_t)0x0          // FTM counter is not reset when the selected channel (n) input event is detected.
#define   FTM_C7SC_ICRST_1                       (uint32_t)0x1          // FTM counter is reset when the selected channel (n) input event is detected.
#define FTM_C7SC_ELSA                            ((uint32_t)1 << 2)     // Channel (n) Edge or Level Select
#define FTM_C7SC_ELSB                            ((uint32_t)1 << 3)     // Channel (n) Edge or Level Select
#define FTM_C7SC_MSA                             ((uint32_t)1 << 4)     // Channel (n) Mode Select
#define FTM_C7SC_MSB                             ((uint32_t)1 << 5)     // Channel (n) Mode Select
#define FTM_C7SC_CHIE                            ((uint32_t)1 << 6)     // Channel (n) Interrupt Enable
#define   FTM_C7SC_CHIE_0                        (uint32_t)0x0          // Disable channel (n) interrupt. Use software polling.
#define   FTM_C7SC_CHIE_1                        (uint32_t)0x1          // Enable channel (n) interrupt.
#define FTM_C7SC_CHF                             ((uint32_t)1 << 7)     // Channel (n) Flag
#define   FTM_C7SC_CHF_0                         (uint32_t)0x0          // No channel (n) event has occurred.
#define   FTM_C7SC_CHF_1                         (uint32_t)0x1          // A channel (n) event has occurred.
#define FTM_C7SC_TRIGMODE                        ((uint32_t)1 << 8)     // Trigger mode control
#define   FTM_C7SC_TRIGMODE_0                    (uint32_t)0x0          // Channel outputs will generate the normal PWM outputs without generating a pulse.
#define   FTM_C7SC_TRIGMODE_1                    (uint32_t)0x1          // If a match in the channel occurs, a trigger generation on channel output will happen. The trigger pulse width has one FTM clock cycle.
#define FTM_C7SC_CHIS                            ((uint32_t)1 << 9)     // Channel (n) Input State
#define   FTM_C7SC_CHIS_0                        (uint32_t)0x0          // The channel (n) input is zero.
#define   FTM_C7SC_CHIS_1                        (uint32_t)0x1          // The channel (n) input is one.
#define FTM_C7SC_CHOV                            ((uint32_t)1 << 10)    // Channel (n) Output Value
#define   FTM_C7SC_CHOV_0                        (uint32_t)0x0          // The channel (n) output is zero.
#define   FTM_C7SC_CHOV_1                        (uint32_t)0x1          // The channel (n) output is one.

    uint32_t             C7V;                                           // Channel (n) Value
                                                                        // Channel Value
#define FTM_C7V_VAL(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C7V_VAL_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_C7V_VAL_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             CNTIN;                                         // Counter Initial Value
                                                                        // INIT
#define FTM_CNTIN_INIT(_n)                       (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_CNTIN_INIT_INSERT(_v, _n)                (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_CNTIN_INIT_EXTRACT(_v)                   (((_v) >> 0) & 0xffff)

    const uint32_t       STATUS;                                        // Capture And Compare Status
#define FTM_STATUS_CH0F                          ((uint32_t)1 << 0)     // Channel 0 Flag
#define   FTM_STATUS_CH0F_0                      (uint32_t)0x0          // No channel event has occurred.
#define   FTM_STATUS_CH0F_1                      (uint32_t)0x1          // A channel event has occurred.
#define FTM_STATUS_CH1F                          ((uint32_t)1 << 1)     // Channel 1 Flag
#define   FTM_STATUS_CH1F_0                      (uint32_t)0x0          // No channel event has occurred.
#define   FTM_STATUS_CH1F_1                      (uint32_t)0x1          // A channel event has occurred.
#define FTM_STATUS_CH2F                          ((uint32_t)1 << 2)     // Channel 2 Flag
#define   FTM_STATUS_CH2F_0                      (uint32_t)0x0          // No channel event has occurred.
#define   FTM_STATUS_CH2F_1                      (uint32_t)0x1          // A channel event has occurred.
#define FTM_STATUS_CH3F                          ((uint32_t)1 << 3)     // Channel 3 Flag
#define   FTM_STATUS_CH3F_0                      (uint32_t)0x0          // No channel event has occurred.
#define   FTM_STATUS_CH3F_1                      (uint32_t)0x1          // A channel event has occurred.
#define FTM_STATUS_CH4F                          ((uint32_t)1 << 4)     // Channel 4 Flag
#define   FTM_STATUS_CH4F_0                      (uint32_t)0x0          // No channel event has occurred.
#define   FTM_STATUS_CH4F_1                      (uint32_t)0x1          // A channel event has occurred.
#define FTM_STATUS_CH5F                          ((uint32_t)1 << 5)     // Channel 5 Flag
#define   FTM_STATUS_CH5F_0                      (uint32_t)0x0          // No channel event has occurred.
#define   FTM_STATUS_CH5F_1                      (uint32_t)0x1          // A channel event has occurred.
#define FTM_STATUS_CH6F                          ((uint32_t)1 << 6)     // Channel 6 Flag
#define   FTM_STATUS_CH6F_0                      (uint32_t)0x0          // No channel event has occurred.
#define   FTM_STATUS_CH6F_1                      (uint32_t)0x1          // A channel event has occurred.
#define FTM_STATUS_CH7F                          ((uint32_t)1 << 7)     // Channel 7 Flag
#define   FTM_STATUS_CH7F_0                      (uint32_t)0x0          // No channel event has occurred.
#define   FTM_STATUS_CH7F_1                      (uint32_t)0x1          // A channel event has occurred.

    uint32_t             MODE;                                          // Features Mode Selection
#define FTM_MODE_FTMEN                           ((uint32_t)1 << 0)     // FTM Enable
#define   FTM_MODE_FTMEN_0                       (uint32_t)0x0          // TPM compatibility. Free running counter and synchronization compatible with TPM.
#define   FTM_MODE_FTMEN_1                       (uint32_t)0x1          // Free running counter and synchronization are different from TPM behavior.
#define FTM_MODE_INIT                            ((uint32_t)1 << 1)     // Initialize The Channels Output
#define FTM_MODE_WPDIS                           ((uint32_t)1 << 2)     // Write Protection Disable
#define   FTM_MODE_WPDIS_0                       (uint32_t)0x0          // Write protection is enabled.
#define   FTM_MODE_WPDIS_1                       (uint32_t)0x1          // Write protection is disabled.
#define FTM_MODE_PWMSYNC                         ((uint32_t)1 << 3)     // PWM Synchronization Mode
#define   FTM_MODE_PWMSYNC_0                     (uint32_t)0x0          // No restrictions. Software and hardware triggers can be used by MOD, CnV, OUTMASK, and FTM counter synchronization.
#define   FTM_MODE_PWMSYNC_1                     (uint32_t)0x1          // Software trigger can only be used by MOD and CnV synchronization, and hardware triggers can only be used by OUTMASK and FTM counter synchronization.
#define FTM_MODE_CAPTEST                         ((uint32_t)1 << 4)     // Capture Test Mode Enable
#define   FTM_MODE_CAPTEST_0                     (uint32_t)0x0          // Capture test mode is disabled.
#define   FTM_MODE_CAPTEST_1                     (uint32_t)0x1          // Capture test mode is enabled.
                                                                        // Fault Control Mode
#define FTM_MODE_FAULTM(_n)                      (((uint32_t)(_n) & 0x3) << 5)
#define FTM_MODE_FAULTM_INSERT(_v, _n)               (((_v) & ~0x60) | ((uint32_t)(_n) & 0x3) << 5)
#define FTM_MODE_FAULTM_EXTRACT(_v)                  (((_v) >> 5) & 0x3)
#define   FTM_MODE_FAULTM_00                     (uint32_t)0x0          // Fault control is disabled for all channels.
#define   FTM_MODE_FAULTM_01                     (uint32_t)0x1          // Fault control is enabled for even channels only (channels 0, 2, 4, and 6), and the selected mode is the manual fault clearing.
#define   FTM_MODE_FAULTM_10                     (uint32_t)0x2          // Fault control is enabled for all channels, and the selected mode is the manual fault clearing.
#define   FTM_MODE_FAULTM_11                     (uint32_t)0x3          // Fault control is enabled for all channels, and the selected mode is the automatic fault clearing.
#define FTM_MODE_FAULTIE                         ((uint32_t)1 << 7)     // Fault Interrupt Enable
#define   FTM_MODE_FAULTIE_0                     (uint32_t)0x0          // Fault control interrupt is disabled.
#define   FTM_MODE_FAULTIE_1                     (uint32_t)0x1          // Fault control interrupt is enabled.

    uint32_t             SYNC;                                          // Synchronization
#define FTM_SYNC_CNTMIN                          ((uint32_t)1 << 0)     // Minimum Loading Point Enable
#define   FTM_SYNC_CNTMIN_0                      (uint32_t)0x0          // The minimum loading point is disabled.
#define   FTM_SYNC_CNTMIN_1                      (uint32_t)0x1          // The minimum loading point is enabled.
#define FTM_SYNC_CNTMAX                          ((uint32_t)1 << 1)     // Maximum Loading Point Enable
#define   FTM_SYNC_CNTMAX_0                      (uint32_t)0x0          // The maximum loading point is disabled.
#define   FTM_SYNC_CNTMAX_1                      (uint32_t)0x1          // The maximum loading point is enabled.
#define FTM_SYNC_REINIT                          ((uint32_t)1 << 2)     // FTM Counter Reinitialization by Synchronization
#define   FTM_SYNC_REINIT_0                      (uint32_t)0x0          // FTM counter continues to count normally.
#define   FTM_SYNC_REINIT_1                      (uint32_t)0x1          // FTM counter is updated with its initial value when the selected trigger is detected.
#define FTM_SYNC_SYNCHOM                         ((uint32_t)1 << 3)     // Output Mask Synchronization
#define   FTM_SYNC_SYNCHOM_0                     (uint32_t)0x0          // OUTMASK register is updated with the value of its buffer in all rising edges of the FTM input clock.
#define   FTM_SYNC_SYNCHOM_1                     (uint32_t)0x1          // OUTMASK register is updated with the value of its buffer only by the PWM synchronization.
#define FTM_SYNC_TRIG0                           ((uint32_t)1 << 4)     // PWM Synchronization Hardware Trigger 0
#define   FTM_SYNC_TRIG0_0                       (uint32_t)0x0          // Trigger is disabled.
#define   FTM_SYNC_TRIG0_1                       (uint32_t)0x1          // Trigger is enabled.
#define FTM_SYNC_TRIG1                           ((uint32_t)1 << 5)     // PWM Synchronization Hardware Trigger 1
#define   FTM_SYNC_TRIG1_0                       (uint32_t)0x0          // Trigger is disabled.
#define   FTM_SYNC_TRIG1_1                       (uint32_t)0x1          // Trigger is enabled.
#define FTM_SYNC_TRIG2                           ((uint32_t)1 << 6)     // PWM Synchronization Hardware Trigger 2
#define   FTM_SYNC_TRIG2_0                       (uint32_t)0x0          // Trigger is disabled.
#define   FTM_SYNC_TRIG2_1                       (uint32_t)0x1          // Trigger is enabled.
#define FTM_SYNC_SWSYNC                          ((uint32_t)1 << 7)     // PWM Synchronization Software Trigger
#define   FTM_SYNC_SWSYNC_0                      (uint32_t)0x0          // Software trigger is not selected.
#define   FTM_SYNC_SWSYNC_1                      (uint32_t)0x1          // Software trigger is selected.

    uint32_t             OUTINIT;                                       // Initial State For Channels Output
#define FTM_OUTINIT_CH0OI                        ((uint32_t)1 << 0)     // Channel 0 Output Initialization Value
#define   FTM_OUTINIT_CH0OI_0                    (uint32_t)0x0          // The initialization value is 0.
#define   FTM_OUTINIT_CH0OI_1                    (uint32_t)0x1          // The initialization value is 1.
#define FTM_OUTINIT_CH1OI                        ((uint32_t)1 << 1)     // Channel 1 Output Initialization Value
#define   FTM_OUTINIT_CH1OI_0                    (uint32_t)0x0          // The initialization value is 0.
#define   FTM_OUTINIT_CH1OI_1                    (uint32_t)0x1          // The initialization value is 1.
#define FTM_OUTINIT_CH2OI                        ((uint32_t)1 << 2)     // Channel 2 Output Initialization Value
#define   FTM_OUTINIT_CH2OI_0                    (uint32_t)0x0          // The initialization value is 0.
#define   FTM_OUTINIT_CH2OI_1                    (uint32_t)0x1          // The initialization value is 1.
#define FTM_OUTINIT_CH3OI                        ((uint32_t)1 << 3)     // Channel 3 Output Initialization Value
#define   FTM_OUTINIT_CH3OI_0                    (uint32_t)0x0          // The initialization value is 0.
#define   FTM_OUTINIT_CH3OI_1                    (uint32_t)0x1          // The initialization value is 1.
#define FTM_OUTINIT_CH4OI                        ((uint32_t)1 << 4)     // Channel 4 Output Initialization Value
#define   FTM_OUTINIT_CH4OI_0                    (uint32_t)0x0          // The initialization value is 0.
#define   FTM_OUTINIT_CH4OI_1                    (uint32_t)0x1          // The initialization value is 1.
#define FTM_OUTINIT_CH5OI                        ((uint32_t)1 << 5)     // Channel 5 Output Initialization Value
#define   FTM_OUTINIT_CH5OI_0                    (uint32_t)0x0          // The initialization value is 0.
#define   FTM_OUTINIT_CH5OI_1                    (uint32_t)0x1          // The initialization value is 1.
#define FTM_OUTINIT_CH6OI                        ((uint32_t)1 << 6)     // Channel 6 Output Initialization Value
#define   FTM_OUTINIT_CH6OI_0                    (uint32_t)0x0          // The initialization value is 0.
#define   FTM_OUTINIT_CH6OI_1                    (uint32_t)0x1          // The initialization value is 1.
#define FTM_OUTINIT_CH7OI                        ((uint32_t)1 << 7)     // Channel 7 Output Initialization Value
#define   FTM_OUTINIT_CH7OI_0                    (uint32_t)0x0          // The initialization value is 0.
#define   FTM_OUTINIT_CH7OI_1                    (uint32_t)0x1          // The initialization value is 1.

    uint32_t             OUTMASK;                                       // Output Mask
#define FTM_OUTMASK_CH0OM                        ((uint32_t)1 << 0)     // Channel 0 Output Mask
#define   FTM_OUTMASK_CH0OM_0                    (uint32_t)0x0          // Channel output is not masked. It continues to operate normally.
#define   FTM_OUTMASK_CH0OM_1                    (uint32_t)0x1          // Channel output is masked. It is forced to its inactive state.
#define FTM_OUTMASK_CH1OM                        ((uint32_t)1 << 1)     // Channel 1 Output Mask
#define   FTM_OUTMASK_CH1OM_0                    (uint32_t)0x0          // Channel output is not masked. It continues to operate normally.
#define   FTM_OUTMASK_CH1OM_1                    (uint32_t)0x1          // Channel output is masked. It is forced to its inactive state.
#define FTM_OUTMASK_CH2OM                        ((uint32_t)1 << 2)     // Channel 2 Output Mask
#define   FTM_OUTMASK_CH2OM_0                    (uint32_t)0x0          // Channel output is not masked. It continues to operate normally.
#define   FTM_OUTMASK_CH2OM_1                    (uint32_t)0x1          // Channel output is masked. It is forced to its inactive state.
#define FTM_OUTMASK_CH3OM                        ((uint32_t)1 << 3)     // Channel 3 Output Mask
#define   FTM_OUTMASK_CH3OM_0                    (uint32_t)0x0          // Channel output is not masked. It continues to operate normally.
#define   FTM_OUTMASK_CH3OM_1                    (uint32_t)0x1          // Channel output is masked. It is forced to its inactive state.
#define FTM_OUTMASK_CH4OM                        ((uint32_t)1 << 4)     // Channel 4 Output Mask
#define   FTM_OUTMASK_CH4OM_0                    (uint32_t)0x0          // Channel output is not masked. It continues to operate normally.
#define   FTM_OUTMASK_CH4OM_1                    (uint32_t)0x1          // Channel output is masked. It is forced to its inactive state.
#define FTM_OUTMASK_CH5OM                        ((uint32_t)1 << 5)     // Channel 5 Output Mask
#define   FTM_OUTMASK_CH5OM_0                    (uint32_t)0x0          // Channel output is not masked. It continues to operate normally.
#define   FTM_OUTMASK_CH5OM_1                    (uint32_t)0x1          // Channel output is masked. It is forced to its inactive state.
#define FTM_OUTMASK_CH6OM                        ((uint32_t)1 << 6)     // Channel 6 Output Mask
#define   FTM_OUTMASK_CH6OM_0                    (uint32_t)0x0          // Channel output is not masked. It continues to operate normally.
#define   FTM_OUTMASK_CH6OM_1                    (uint32_t)0x1          // Channel output is masked. It is forced to its inactive state.
#define FTM_OUTMASK_CH7OM                        ((uint32_t)1 << 7)     // Channel 7 Output Mask
#define   FTM_OUTMASK_CH7OM_0                    (uint32_t)0x0          // Channel output is not masked. It continues to operate normally.
#define   FTM_OUTMASK_CH7OM_1                    (uint32_t)0x1          // Channel output is masked. It is forced to its inactive state.

    uint32_t             COMBINE;                                       // Function For Linked Channels
#define FTM_COMBINE_COMBINE0                     ((uint32_t)1 << 0)     // Combine Channels For n = 0
#define FTM_COMBINE_COMP0                        ((uint32_t)1 << 1)     // Complement Of Channel (n) For n = 0
#define   FTM_COMBINE_COMP0_0                    (uint32_t)0x0          // The channel (n+1) output is the same as the channel (n) output.
#define   FTM_COMBINE_COMP0_1                    (uint32_t)0x1          // The channel (n+1) output is the complement of the channel (n) output.
#define FTM_COMBINE_DECAPEN0                     ((uint32_t)1 << 2)     // Dual Edge Capture Mode Enable For n = 0
#define FTM_COMBINE_DECAP0                       ((uint32_t)1 << 3)     // Dual Edge Capture Mode Captures For n = 0
#define   FTM_COMBINE_DECAP0_0                   (uint32_t)0x0          // The dual edge captures are inactive.
#define   FTM_COMBINE_DECAP0_1                   (uint32_t)0x1          // The dual edge captures are active.
#define FTM_COMBINE_DTEN0                        ((uint32_t)1 << 4)     // Deadtime Enable For n = 0
#define   FTM_COMBINE_DTEN0_0                    (uint32_t)0x0          // The deadtime insertion in this pair of channels is disabled.
#define   FTM_COMBINE_DTEN0_1                    (uint32_t)0x1          // The deadtime insertion in this pair of channels is enabled.
#define FTM_COMBINE_SYNCEN0                      ((uint32_t)1 << 5)     // Synchronization Enable For n = 0
#define   FTM_COMBINE_SYNCEN0_0                  (uint32_t)0x0          // The PWM synchronization in this pair of channels is disabled.
#define   FTM_COMBINE_SYNCEN0_1                  (uint32_t)0x1          // The PWM synchronization in this pair of channels is enabled.
#define FTM_COMBINE_FAULTEN0                     ((uint32_t)1 << 6)     // Fault Control Enable For n = 0
#define   FTM_COMBINE_FAULTEN0_0                 (uint32_t)0x0          // The fault control in this pair of channels is disabled.
#define   FTM_COMBINE_FAULTEN0_1                 (uint32_t)0x1          // The fault control in this pair of channels is enabled.
#define FTM_COMBINE_MCOMBINE0                    ((uint32_t)1 << 7)     // Modified Combine Mode For n = 0
#define FTM_COMBINE_COMBINE1                     ((uint32_t)1 << 8)     // Combine Channels For n = 2
#define FTM_COMBINE_COMP1                        ((uint32_t)1 << 9)     // Complement Of Channel (n) For n = 2
#define   FTM_COMBINE_COMP1_0                    (uint32_t)0x0          // The channel (n+1) output is the same as the channel (n) output.
#define   FTM_COMBINE_COMP1_1                    (uint32_t)0x1          // The channel (n+1) output is the complement of the channel (n) output.
#define FTM_COMBINE_DECAPEN1                     ((uint32_t)1 << 10)    // Dual Edge Capture Mode Enable For n = 2
#define FTM_COMBINE_DECAP1                       ((uint32_t)1 << 11)    // Dual Edge Capture Mode Captures For n = 2
#define   FTM_COMBINE_DECAP1_0                   (uint32_t)0x0          // The dual edge captures are inactive.
#define   FTM_COMBINE_DECAP1_1                   (uint32_t)0x1          // The dual edge captures are active.
#define FTM_COMBINE_DTEN1                        ((uint32_t)1 << 12)    // Deadtime Enable For n = 2
#define   FTM_COMBINE_DTEN1_0                    (uint32_t)0x0          // The deadtime insertion in this pair of channels is disabled.
#define   FTM_COMBINE_DTEN1_1                    (uint32_t)0x1          // The deadtime insertion in this pair of channels is enabled.
#define FTM_COMBINE_SYNCEN1                      ((uint32_t)1 << 13)    // Synchronization Enable For n = 2
#define   FTM_COMBINE_SYNCEN1_0                  (uint32_t)0x0          // The PWM synchronization in this pair of channels is disabled.
#define   FTM_COMBINE_SYNCEN1_1                  (uint32_t)0x1          // The PWM synchronization in this pair of channels is enabled.
#define FTM_COMBINE_FAULTEN1                     ((uint32_t)1 << 14)    // Fault Control Enable For n = 2
#define   FTM_COMBINE_FAULTEN1_0                 (uint32_t)0x0          // The fault control in this pair of channels is disabled.
#define   FTM_COMBINE_FAULTEN1_1                 (uint32_t)0x1          // The fault control in this pair of channels is enabled.
#define FTM_COMBINE_MCOMBINE1                    ((uint32_t)1 << 15)    // Modified Combine Mode For n = 2
#define FTM_COMBINE_COMBINE2                     ((uint32_t)1 << 16)    // Combine Channels For n = 4
#define FTM_COMBINE_COMP2                        ((uint32_t)1 << 17)    // Complement Of Channel (n) For n = 4
#define   FTM_COMBINE_COMP2_0                    (uint32_t)0x0          // The channel (n+1) output is the same as the channel (n) output.
#define   FTM_COMBINE_COMP2_1                    (uint32_t)0x1          // The channel (n+1) output is the complement of the channel (n) output.
#define FTM_COMBINE_DECAPEN2                     ((uint32_t)1 << 18)    // Dual Edge Capture Mode Enable For n = 4
#define FTM_COMBINE_DECAP2                       ((uint32_t)1 << 19)    // Dual Edge Capture Mode Captures For n = 4
#define   FTM_COMBINE_DECAP2_0                   (uint32_t)0x0          // The dual edge captures are inactive.
#define   FTM_COMBINE_DECAP2_1                   (uint32_t)0x1          // The dual edge captures are active.
#define FTM_COMBINE_DTEN2                        ((uint32_t)1 << 20)    // Deadtime Enable For n = 4
#define   FTM_COMBINE_DTEN2_0                    (uint32_t)0x0          // The deadtime insertion in this pair of channels is disabled.
#define   FTM_COMBINE_DTEN2_1                    (uint32_t)0x1          // The deadtime insertion in this pair of channels is enabled.
#define FTM_COMBINE_SYNCEN2                      ((uint32_t)1 << 21)    // Synchronization Enable For n = 4
#define   FTM_COMBINE_SYNCEN2_0                  (uint32_t)0x0          // The PWM synchronization in this pair of channels is disabled.
#define   FTM_COMBINE_SYNCEN2_1                  (uint32_t)0x1          // The PWM synchronization in this pair of channels is enabled.
#define FTM_COMBINE_FAULTEN2                     ((uint32_t)1 << 22)    // Fault Control Enable For n = 4
#define   FTM_COMBINE_FAULTEN2_0                 (uint32_t)0x0          // The fault control in this pair of channels is disabled.
#define   FTM_COMBINE_FAULTEN2_1                 (uint32_t)0x1          // The fault control in this pair of channels is enabled.
#define FTM_COMBINE_MCOMBINE2                    ((uint32_t)1 << 23)    // Modified Combine Mode For n = 4
#define FTM_COMBINE_COMBINE3                     ((uint32_t)1 << 24)    // Combine Channels For n = 6
#define FTM_COMBINE_COMP3                        ((uint32_t)1 << 25)    // Complement Of Channel (n) for n = 6
#define   FTM_COMBINE_COMP3_0                    (uint32_t)0x0          // The channel (n+1) output is the same as the channel (n) output.
#define   FTM_COMBINE_COMP3_1                    (uint32_t)0x1          // The channel (n+1) output is the complement of the channel (n) output.
#define FTM_COMBINE_DECAPEN3                     ((uint32_t)1 << 26)    // Dual Edge Capture Mode Enable For n = 6
#define FTM_COMBINE_DECAP3                       ((uint32_t)1 << 27)    // Dual Edge Capture Mode Captures For n = 6
#define   FTM_COMBINE_DECAP3_0                   (uint32_t)0x0          // The dual edge captures are inactive.
#define   FTM_COMBINE_DECAP3_1                   (uint32_t)0x1          // The dual edge captures are active.
#define FTM_COMBINE_DTEN3                        ((uint32_t)1 << 28)    // Deadtime Enable For n = 6
#define   FTM_COMBINE_DTEN3_0                    (uint32_t)0x0          // The deadtime insertion in this pair of channels is disabled.
#define   FTM_COMBINE_DTEN3_1                    (uint32_t)0x1          // The deadtime insertion in this pair of channels is enabled.
#define FTM_COMBINE_SYNCEN3                      ((uint32_t)1 << 29)    // Synchronization Enable For n = 6
#define   FTM_COMBINE_SYNCEN3_0                  (uint32_t)0x0          // The PWM synchronization in this pair of channels is disabled.
#define   FTM_COMBINE_SYNCEN3_1                  (uint32_t)0x1          // The PWM synchronization in this pair of channels is enabled.
#define FTM_COMBINE_FAULTEN3                     ((uint32_t)1 << 30)    // Fault Control Enable For n = 6
#define   FTM_COMBINE_FAULTEN3_0                 (uint32_t)0x0          // The fault control in this pair of channels is disabled.
#define   FTM_COMBINE_FAULTEN3_1                 (uint32_t)0x1          // The fault control in this pair of channels is enabled.
#define FTM_COMBINE_MCOMBINE3                    ((uint32_t)1 << 31)    // Modified Combine Mode For n = 6

    uint32_t             DEADTIME;                                      // Deadtime Configuration
                                                                        // Deadtime Value
#define FTM_DEADTIME_DTVAL(_n)                   (((uint32_t)(_n) & 0x3f) << 0)
#define FTM_DEADTIME_DTVAL_INSERT(_v, _n)            (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define FTM_DEADTIME_DTVAL_EXTRACT(_v)               (((_v) >> 0) & 0x3f)
                                                                        // Deadtime Prescaler Value
#define FTM_DEADTIME_DTPS(_n)                    (((uint32_t)(_n) & 0x3) << 6)
#define FTM_DEADTIME_DTPS_INSERT(_v, _n)             (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define FTM_DEADTIME_DTPS_EXTRACT(_v)                (((_v) >> 6) & 0x3)
#define   FTM_DEADTIME_DTPS_0x                   (uint32_t)0x0          // Divide the FTM input clock by 1.
#define   FTM_DEADTIME_DTPS_10                   (uint32_t)0x2          // Divide the FTM input clock by 4.
#define   FTM_DEADTIME_DTPS_11                   (uint32_t)0x3          // Divide the FTM input clock by 16.
                                                                        // Extended Deadtime Value
#define FTM_DEADTIME_DTVALEX(_n)                 (((uint32_t)(_n) & 0xf) << 16)
#define FTM_DEADTIME_DTVALEX_INSERT(_v, _n)          (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define FTM_DEADTIME_DTVALEX_EXTRACT(_v)             (((_v) >> 16) & 0xf)

    uint32_t             EXTTRIG;                                       // FTM External Trigger
#define FTM_EXTTRIG_CH2TRIG                      ((uint32_t)1 << 0)     // Channel 2 External Trigger Enable
#define   FTM_EXTTRIG_CH2TRIG_0                  (uint32_t)0x0          // The generation of this external trigger is disabled.
#define   FTM_EXTTRIG_CH2TRIG_1                  (uint32_t)0x1          // The generation of this external trigger is enabled.
#define FTM_EXTTRIG_CH3TRIG                      ((uint32_t)1 << 1)     // Channel 3 External Trigger Enable
#define   FTM_EXTTRIG_CH3TRIG_0                  (uint32_t)0x0          // The generation of this external trigger is disabled.
#define   FTM_EXTTRIG_CH3TRIG_1                  (uint32_t)0x1          // The generation of this external trigger is enabled.
#define FTM_EXTTRIG_CH4TRIG                      ((uint32_t)1 << 2)     // Channel 4 External Trigger Enable
#define   FTM_EXTTRIG_CH4TRIG_0                  (uint32_t)0x0          // The generation of this external trigger is disabled.
#define   FTM_EXTTRIG_CH4TRIG_1                  (uint32_t)0x1          // The generation of this external trigger is enabled.
#define FTM_EXTTRIG_CH5TRIG                      ((uint32_t)1 << 3)     // Channel 5 External Trigger Enable
#define   FTM_EXTTRIG_CH5TRIG_0                  (uint32_t)0x0          // The generation of this external trigger is disabled.
#define   FTM_EXTTRIG_CH5TRIG_1                  (uint32_t)0x1          // The generation of this external trigger is enabled.
#define FTM_EXTTRIG_CH0TRIG                      ((uint32_t)1 << 4)     // Channel 0 External Trigger Enable
#define   FTM_EXTTRIG_CH0TRIG_0                  (uint32_t)0x0          // The generation of this external trigger is disabled.
#define   FTM_EXTTRIG_CH0TRIG_1                  (uint32_t)0x1          // The generation of this external trigger is enabled.
#define FTM_EXTTRIG_CH1TRIG                      ((uint32_t)1 << 5)     // Channel 1 External Trigger Enable
#define   FTM_EXTTRIG_CH1TRIG_0                  (uint32_t)0x0          // The generation of this external trigger is disabled.
#define   FTM_EXTTRIG_CH1TRIG_1                  (uint32_t)0x1          // The generation of this external trigger is enabled.
#define FTM_EXTTRIG_INITTRIGEN                   ((uint32_t)1 << 6)     // Initialization Trigger Enable
#define   FTM_EXTTRIG_INITTRIGEN_0               (uint32_t)0x0          // The generation of initialization trigger is disabled.
#define   FTM_EXTTRIG_INITTRIGEN_1               (uint32_t)0x1          // The generation of initialization trigger is enabled.
#define FTM_EXTTRIG_TRIGF                        ((uint32_t)1 << 7)     // Channel Trigger Flag
#define   FTM_EXTTRIG_TRIGF_0                    (uint32_t)0x0          // No channel trigger was generated.
#define   FTM_EXTTRIG_TRIGF_1                    (uint32_t)0x1          // A channel trigger was generated.
#define FTM_EXTTRIG_CH6TRIG                      ((uint32_t)1 << 8)     // Channel 6 External Trigger Enable
#define   FTM_EXTTRIG_CH6TRIG_0                  (uint32_t)0x0          // The generation of this external trigger is disabled.
#define   FTM_EXTTRIG_CH6TRIG_1                  (uint32_t)0x1          // The generation of this external trigger is enabled.
#define FTM_EXTTRIG_CH7TRIG                      ((uint32_t)1 << 9)     // Channel 7 External Trigger Enable
#define   FTM_EXTTRIG_CH7TRIG_0                  (uint32_t)0x0          // The generation of this external trigger is disabled.
#define   FTM_EXTTRIG_CH7TRIG_1                  (uint32_t)0x1          // The generation of this external trigger is enabled.

    uint32_t             POL;                                           // Channels Polarity
#define FTM_POL_POL0                             ((uint32_t)1 << 0)     // Channel 0 Polarity
#define   FTM_POL_POL0_0                         (uint32_t)0x0          // The channel polarity is active high.
#define   FTM_POL_POL0_1                         (uint32_t)0x1          // The channel polarity is active low.
#define FTM_POL_POL1                             ((uint32_t)1 << 1)     // Channel 1 Polarity
#define   FTM_POL_POL1_0                         (uint32_t)0x0          // The channel polarity is active high.
#define   FTM_POL_POL1_1                         (uint32_t)0x1          // The channel polarity is active low.
#define FTM_POL_POL2                             ((uint32_t)1 << 2)     // Channel 2 Polarity
#define   FTM_POL_POL2_0                         (uint32_t)0x0          // The channel polarity is active high.
#define   FTM_POL_POL2_1                         (uint32_t)0x1          // The channel polarity is active low.
#define FTM_POL_POL3                             ((uint32_t)1 << 3)     // Channel 3 Polarity
#define   FTM_POL_POL3_0                         (uint32_t)0x0          // The channel polarity is active high.
#define   FTM_POL_POL3_1                         (uint32_t)0x1          // The channel polarity is active low.
#define FTM_POL_POL4                             ((uint32_t)1 << 4)     // Channel 4 Polarity
#define   FTM_POL_POL4_0                         (uint32_t)0x0          // The channel polarity is active high.
#define   FTM_POL_POL4_1                         (uint32_t)0x1          // The channel polarity is active low.
#define FTM_POL_POL5                             ((uint32_t)1 << 5)     // Channel 5 Polarity
#define   FTM_POL_POL5_0                         (uint32_t)0x0          // The channel polarity is active high.
#define   FTM_POL_POL5_1                         (uint32_t)0x1          // The channel polarity is active low.
#define FTM_POL_POL6                             ((uint32_t)1 << 6)     // Channel 6 Polarity
#define   FTM_POL_POL6_0                         (uint32_t)0x0          // The channel polarity is active high.
#define   FTM_POL_POL6_1                         (uint32_t)0x1          // The channel polarity is active low.
#define FTM_POL_POL7                             ((uint32_t)1 << 7)     // Channel 7 Polarity
#define   FTM_POL_POL7_0                         (uint32_t)0x0          // The channel polarity is active high.
#define   FTM_POL_POL7_1                         (uint32_t)0x1          // The channel polarity is active low.

    uint32_t             FMS;                                           // Fault Mode Status
#define FTM_FMS_FAULTF0                          ((uint32_t)1 << 0)     // Fault Detection Flag 0
#define   FTM_FMS_FAULTF0_0                      (uint32_t)0x0          // No fault condition was detected at the fault input.
#define   FTM_FMS_FAULTF0_1                      (uint32_t)0x1          // A fault condition was detected at the fault input.
#define FTM_FMS_FAULTF1                          ((uint32_t)1 << 1)     // Fault Detection Flag 1
#define   FTM_FMS_FAULTF1_0                      (uint32_t)0x0          // No fault condition was detected at the fault input.
#define   FTM_FMS_FAULTF1_1                      (uint32_t)0x1          // A fault condition was detected at the fault input.
#define FTM_FMS_FAULTF2                          ((uint32_t)1 << 2)     // Fault Detection Flag 2
#define   FTM_FMS_FAULTF2_0                      (uint32_t)0x0          // No fault condition was detected at the fault input.
#define   FTM_FMS_FAULTF2_1                      (uint32_t)0x1          // A fault condition was detected at the fault input.
#define FTM_FMS_FAULTF3                          ((uint32_t)1 << 3)     // Fault Detection Flag 3
#define   FTM_FMS_FAULTF3_0                      (uint32_t)0x0          // No fault condition was detected at the fault input.
#define   FTM_FMS_FAULTF3_1                      (uint32_t)0x1          // A fault condition was detected at the fault input.
#define FTM_FMS_FAULTIN                          ((uint32_t)1 << 5)     // Fault Inputs
#define   FTM_FMS_FAULTIN_0                      (uint32_t)0x0          // The logic OR of the enabled fault inputs is 0.
#define   FTM_FMS_FAULTIN_1                      (uint32_t)0x1          // The logic OR of the enabled fault inputs is 1.
#define FTM_FMS_WPEN                             ((uint32_t)1 << 6)     // Write Protection Enable
#define   FTM_FMS_WPEN_0                         (uint32_t)0x0          // Write protection is disabled. Write protected bits can be written.
#define   FTM_FMS_WPEN_1                         (uint32_t)0x1          // Write protection is enabled. Write protected bits cannot be written.
#define FTM_FMS_FAULTF                           ((uint32_t)1 << 7)     // Fault Detection Flag
#define   FTM_FMS_FAULTF_0                       (uint32_t)0x0          // No fault condition was detected.
#define   FTM_FMS_FAULTF_1                       (uint32_t)0x1          // A fault condition was detected.

    uint32_t             FILTER;                                        // Input Capture Filter Control
                                                                        // Channel 0 Input Filter
#define FTM_FILTER_CH0FVAL(_n)                   (((uint32_t)(_n) & 0xf) << 0)
#define FTM_FILTER_CH0FVAL_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define FTM_FILTER_CH0FVAL_EXTRACT(_v)               (((_v) >> 0) & 0xf)
                                                                        // Channel 1 Input Filter
#define FTM_FILTER_CH1FVAL(_n)                   (((uint32_t)(_n) & 0xf) << 4)
#define FTM_FILTER_CH1FVAL_INSERT(_v, _n)            (((_v) & ~0xf0) | ((uint32_t)(_n) & 0xf) << 4)
#define FTM_FILTER_CH1FVAL_EXTRACT(_v)               (((_v) >> 4) & 0xf)
                                                                        // Channel 2 Input Filter
#define FTM_FILTER_CH2FVAL(_n)                   (((uint32_t)(_n) & 0xf) << 8)
#define FTM_FILTER_CH2FVAL_INSERT(_v, _n)            (((_v) & ~0xf00) | ((uint32_t)(_n) & 0xf) << 8)
#define FTM_FILTER_CH2FVAL_EXTRACT(_v)               (((_v) >> 8) & 0xf)
                                                                        // Channel 3 Input Filter
#define FTM_FILTER_CH3FVAL(_n)                   (((uint32_t)(_n) & 0xf) << 12)
#define FTM_FILTER_CH3FVAL_INSERT(_v, _n)            (((_v) & ~0xf000) | ((uint32_t)(_n) & 0xf) << 12)
#define FTM_FILTER_CH3FVAL_EXTRACT(_v)               (((_v) >> 12) & 0xf)

    uint32_t             FLTCTRL;                                       // Fault Control
#define FTM_FLTCTRL_FAULT0EN                     ((uint32_t)1 << 0)     // Fault Input 0 Enable
#define   FTM_FLTCTRL_FAULT0EN_0                 (uint32_t)0x0          // Fault input is disabled.
#define   FTM_FLTCTRL_FAULT0EN_1                 (uint32_t)0x1          // Fault input is enabled.
#define FTM_FLTCTRL_FAULT1EN                     ((uint32_t)1 << 1)     // Fault Input 1 Enable
#define   FTM_FLTCTRL_FAULT1EN_0                 (uint32_t)0x0          // Fault input is disabled.
#define   FTM_FLTCTRL_FAULT1EN_1                 (uint32_t)0x1          // Fault input is enabled.
#define FTM_FLTCTRL_FAULT2EN                     ((uint32_t)1 << 2)     // Fault Input 2 Enable
#define   FTM_FLTCTRL_FAULT2EN_0                 (uint32_t)0x0          // Fault input is disabled.
#define   FTM_FLTCTRL_FAULT2EN_1                 (uint32_t)0x1          // Fault input is enabled.
#define FTM_FLTCTRL_FAULT3EN                     ((uint32_t)1 << 3)     // Fault Input 3 Enable
#define   FTM_FLTCTRL_FAULT3EN_0                 (uint32_t)0x0          // Fault input is disabled.
#define   FTM_FLTCTRL_FAULT3EN_1                 (uint32_t)0x1          // Fault input is enabled.
#define FTM_FLTCTRL_FFLTR0EN                     ((uint32_t)1 << 4)     // Fault Input 0 Filter Enable
#define   FTM_FLTCTRL_FFLTR0EN_0                 (uint32_t)0x0          // Fault input filter is disabled.
#define   FTM_FLTCTRL_FFLTR0EN_1                 (uint32_t)0x1          // Fault input filter is enabled.
#define FTM_FLTCTRL_FFLTR1EN                     ((uint32_t)1 << 5)     // Fault Input 1 Filter Enable
#define   FTM_FLTCTRL_FFLTR1EN_0                 (uint32_t)0x0          // Fault input filter is disabled.
#define   FTM_FLTCTRL_FFLTR1EN_1                 (uint32_t)0x1          // Fault input filter is enabled.
#define FTM_FLTCTRL_FFLTR2EN                     ((uint32_t)1 << 6)     // Fault Input 2 Filter Enable
#define   FTM_FLTCTRL_FFLTR2EN_0                 (uint32_t)0x0          // Fault input filter is disabled.
#define   FTM_FLTCTRL_FFLTR2EN_1                 (uint32_t)0x1          // Fault input filter is enabled.
#define FTM_FLTCTRL_FFLTR3EN                     ((uint32_t)1 << 7)     // Fault Input 3 Filter Enable
#define   FTM_FLTCTRL_FFLTR3EN_0                 (uint32_t)0x0          // Fault input filter is disabled.
#define   FTM_FLTCTRL_FFLTR3EN_1                 (uint32_t)0x1          // Fault input filter is enabled.
                                                                        // Fault Input Filter
#define FTM_FLTCTRL_FFVAL(_n)                    (((uint32_t)(_n) & 0xf) << 8)
#define FTM_FLTCTRL_FFVAL_INSERT(_v, _n)             (((_v) & ~0xf00) | ((uint32_t)(_n) & 0xf) << 8)
#define FTM_FLTCTRL_FFVAL_EXTRACT(_v)                (((_v) >> 8) & 0xf)
#define FTM_FLTCTRL_FSTATE                       ((uint32_t)1 << 15)    // Fault output state
#define   FTM_FLTCTRL_FSTATE_0                   (uint32_t)0x0          // FTM outputs will be placed into safe values when fault events in ongoing (defined by POL bits).
#define   FTM_FLTCTRL_FSTATE_1                   (uint32_t)0x1          // FTM outputs will be tri-stated when fault event is ongoing

    uint32_t             QDCTRL;                                        // Quadrature Decoder Control And Status
#define FTM_QDCTRL_QUADEN                        ((uint32_t)1 << 0)     // Quadrature Decoder Mode Enable
#define   FTM_QDCTRL_QUADEN_0                    (uint32_t)0x0          // Quadrature Decoder mode is disabled.
#define   FTM_QDCTRL_QUADEN_1                    (uint32_t)0x1          // Quadrature Decoder mode is enabled.
#define FTM_QDCTRL_TOFDIR                        ((uint32_t)1 << 1)     // Timer Overflow Direction In Quadrature Decoder Mode
#define   FTM_QDCTRL_TOFDIR_0                    (uint32_t)0x0          // TOF bit was set on the bottom of counting. There was an FTM counter decrement and FTM counter changes from its minimum value (CNTIN register) to its maximum value (MOD register).
#define   FTM_QDCTRL_TOFDIR_1                    (uint32_t)0x1          // TOF bit was set on the top of counting. There was an FTM counter increment and FTM counter changes from its maximum value (MOD register) to its minimum value (CNTIN register).
#define FTM_QDCTRL_QUADIR                        ((uint32_t)1 << 2)     // FTM Counter Direction In Quadrature Decoder Mode
#define   FTM_QDCTRL_QUADIR_0                    (uint32_t)0x0          // Counting direction is decreasing (FTM counter decrement).
#define   FTM_QDCTRL_QUADIR_1                    (uint32_t)0x1          // Counting direction is increasing (FTM counter increment).
#define FTM_QDCTRL_QUADMODE                      ((uint32_t)1 << 3)     // Quadrature Decoder Mode
#define   FTM_QDCTRL_QUADMODE_0                  (uint32_t)0x0          // Phase A and phase B encoding mode.
#define   FTM_QDCTRL_QUADMODE_1                  (uint32_t)0x1          // Count and direction encoding mode.
#define FTM_QDCTRL_PHBPOL                        ((uint32_t)1 << 4)     // Phase B Input Polarity
#define   FTM_QDCTRL_PHBPOL_0                    (uint32_t)0x0          // Normal polarity. Phase B input signal is not inverted before identifying the rising and falling edges of this signal.
#define   FTM_QDCTRL_PHBPOL_1                    (uint32_t)0x1          // Inverted polarity. Phase B input signal is inverted before identifying the rising and falling edges of this signal.
#define FTM_QDCTRL_PHAPOL                        ((uint32_t)1 << 5)     // Phase A Input Polarity
#define   FTM_QDCTRL_PHAPOL_0                    (uint32_t)0x0          // Normal polarity. Phase A input signal is not inverted before identifying the rising and falling edges of this signal.
#define   FTM_QDCTRL_PHAPOL_1                    (uint32_t)0x1          // Inverted polarity. Phase A input signal is inverted before identifying the rising and falling edges of this signal.
#define FTM_QDCTRL_PHBFLTREN                     ((uint32_t)1 << 6)     // Phase B Input Filter Enable
#define   FTM_QDCTRL_PHBFLTREN_0                 (uint32_t)0x0          // Phase B input filter is disabled.
#define   FTM_QDCTRL_PHBFLTREN_1                 (uint32_t)0x1          // Phase B input filter is enabled.
#define FTM_QDCTRL_PHAFLTREN                     ((uint32_t)1 << 7)     // Phase A Input Filter Enable
#define   FTM_QDCTRL_PHAFLTREN_0                 (uint32_t)0x0          // Phase A input filter is disabled.
#define   FTM_QDCTRL_PHAFLTREN_1                 (uint32_t)0x1          // Phase A input filter is enabled.

    uint32_t             CONF;                                          // Configuration
                                                                        // Frequency of the Reload Opportunities
#define FTM_CONF_LDFQ(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define FTM_CONF_LDFQ_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define FTM_CONF_LDFQ_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
                                                                        // Debug Mode
#define FTM_CONF_BDMMODE(_n)                     (((uint32_t)(_n) & 0x3) << 6)
#define FTM_CONF_BDMMODE_INSERT(_v, _n)              (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define FTM_CONF_BDMMODE_EXTRACT(_v)                 (((_v) >> 6) & 0x3)
#define FTM_CONF_GTBEEN                          ((uint32_t)1 << 9)     // Global Time Base Enable
#define FTM_CONF_GTBEOUT                         ((uint32_t)1 << 10)    // Global Time Base Output
#define FTM_CONF_ITRIGR                          ((uint32_t)1 << 11)    // Initialization trigger on Reload Point
#define   FTM_CONF_ITRIGR_0                      (uint32_t)0x0          // Initialization trigger is generated on counter wrap events.
#define   FTM_CONF_ITRIGR_1                      (uint32_t)0x1          // Initialization trigger is generated when a reload point is reached.

    uint32_t             FLTPOL;                                        // FTM Fault Input Polarity
#define FTM_FLTPOL_FLT0POL                       ((uint32_t)1 << 0)     // Fault Input 0 Polarity
#define   FTM_FLTPOL_FLT0POL_0                   (uint32_t)0x0          // The fault input polarity is active high. A 1 at the fault input indicates a fault.
#define   FTM_FLTPOL_FLT0POL_1                   (uint32_t)0x1          // The fault input polarity is active low. A 0 at the fault input indicates a fault.
#define FTM_FLTPOL_FLT1POL                       ((uint32_t)1 << 1)     // Fault Input 1 Polarity
#define   FTM_FLTPOL_FLT1POL_0                   (uint32_t)0x0          // The fault input polarity is active high. A 1 at the fault input indicates a fault.
#define   FTM_FLTPOL_FLT1POL_1                   (uint32_t)0x1          // The fault input polarity is active low. A 0 at the fault input indicates a fault.
#define FTM_FLTPOL_FLT2POL                       ((uint32_t)1 << 2)     // Fault Input 2 Polarity
#define   FTM_FLTPOL_FLT2POL_0                   (uint32_t)0x0          // The fault input polarity is active high. A 1 at the fault input indicates a fault.
#define   FTM_FLTPOL_FLT2POL_1                   (uint32_t)0x1          // The fault input polarity is active low. A 0 at the fault input indicates a fault.
#define FTM_FLTPOL_FLT3POL                       ((uint32_t)1 << 3)     // Fault Input 3 Polarity
#define   FTM_FLTPOL_FLT3POL_0                   (uint32_t)0x0          // The fault input polarity is active high. A 1 at the fault input indicates a fault.
#define   FTM_FLTPOL_FLT3POL_1                   (uint32_t)0x1          // The fault input polarity is active low. A 0 at the fault input indicates a fault.

    uint32_t             SYNCONF;                                       // Synchronization Configuration
#define FTM_SYNCONF_HWTRIGMODE                   ((uint32_t)1 << 0)     // Hardware Trigger Mode
#define   FTM_SYNCONF_HWTRIGMODE_0               (uint32_t)0x0          // FTM clears the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
#define   FTM_SYNCONF_HWTRIGMODE_1               (uint32_t)0x1          // FTM does not clear the TRIGj bit when the hardware trigger j is detected, where j = 0, 1,2.
#define FTM_SYNCONF_CNTINC                       ((uint32_t)1 << 2)     // CNTIN Register Synchronization
#define   FTM_SYNCONF_CNTINC_0                   (uint32_t)0x0          // CNTIN register is updated with its buffer value at all rising edges of FTM input clock.
#define   FTM_SYNCONF_CNTINC_1                   (uint32_t)0x1          // CNTIN register is updated with its buffer value by the PWM synchronization.
#define FTM_SYNCONF_INVC                         ((uint32_t)1 << 4)     // INVCTRL Register Synchronization
#define   FTM_SYNCONF_INVC_0                     (uint32_t)0x0          // INVCTRL register is updated with its buffer value at all rising edges of FTM input clock.
#define   FTM_SYNCONF_INVC_1                     (uint32_t)0x1          // INVCTRL register is updated with its buffer value by the PWM synchronization.
#define FTM_SYNCONF_SWOC                         ((uint32_t)1 << 5)     // SWOCTRL Register Synchronization
#define   FTM_SYNCONF_SWOC_0                     (uint32_t)0x0          // SWOCTRL register is updated with its buffer value at all rising edges of FTM input clock.
#define   FTM_SYNCONF_SWOC_1                     (uint32_t)0x1          // SWOCTRL register is updated with its buffer value by the PWM synchronization.
#define FTM_SYNCONF_SYNCMODE                     ((uint32_t)1 << 7)     // Synchronization Mode
#define   FTM_SYNCONF_SYNCMODE_0                 (uint32_t)0x0          // Legacy PWM synchronization is selected.
#define   FTM_SYNCONF_SYNCMODE_1                 (uint32_t)0x1          // Enhanced PWM synchronization is selected.
#define FTM_SYNCONF_SWRSTCNT                     ((uint32_t)1 << 8)     // FTM counter synchronization is activated by the software trigger
#define   FTM_SYNCONF_SWRSTCNT_0                 (uint32_t)0x0          // The software trigger does not activate the FTM counter synchronization.
#define   FTM_SYNCONF_SWRSTCNT_1                 (uint32_t)0x1          // The software trigger activates the FTM counter synchronization.
#define FTM_SYNCONF_SWWRBUF                      ((uint32_t)1 << 9)     // MOD, HCR, CNTIN, and CV registers synchronization is activated by the software trigger
#define   FTM_SYNCONF_SWWRBUF_0                  (uint32_t)0x0          // The software trigger does not activate MOD, HCR, CNTIN, and CV registers synchronization.
#define   FTM_SYNCONF_SWWRBUF_1                  (uint32_t)0x1          // The software trigger activates MOD, HCR, CNTIN, and CV registers synchronization.
#define FTM_SYNCONF_SWOM                         ((uint32_t)1 << 10)    // Output mask synchronization is activated by the software trigger
#define   FTM_SYNCONF_SWOM_0                     (uint32_t)0x0          // The software trigger does not activate the OUTMASK register synchronization.
#define   FTM_SYNCONF_SWOM_1                     (uint32_t)0x1          // The software trigger activates the OUTMASK register synchronization.
#define FTM_SYNCONF_SWINVC                       ((uint32_t)1 << 11)    // Inverting control synchronization is activated by the software trigger
#define   FTM_SYNCONF_SWINVC_0                   (uint32_t)0x0          // The software trigger does not activate the INVCTRL register synchronization.
#define   FTM_SYNCONF_SWINVC_1                   (uint32_t)0x1          // The software trigger activates the INVCTRL register synchronization.
#define FTM_SYNCONF_SWSOC                        ((uint32_t)1 << 12)    // Software output control synchronization is activated by the software trigger
#define   FTM_SYNCONF_SWSOC_0                    (uint32_t)0x0          // The software trigger does not activate the SWOCTRL register synchronization.
#define   FTM_SYNCONF_SWSOC_1                    (uint32_t)0x1          // The software trigger activates the SWOCTRL register synchronization.
#define FTM_SYNCONF_HWRSTCNT                     ((uint32_t)1 << 16)    // FTM counter synchronization is activated by a hardware trigger
#define   FTM_SYNCONF_HWRSTCNT_0                 (uint32_t)0x0          // A hardware trigger does not activate the FTM counter synchronization.
#define   FTM_SYNCONF_HWRSTCNT_1                 (uint32_t)0x1          // A hardware trigger activates the FTM counter synchronization.
#define FTM_SYNCONF_HWWRBUF                      ((uint32_t)1 << 17)    // MOD, HCR, CNTIN, and CV registers synchronization is activated by a hardware trigger
#define   FTM_SYNCONF_HWWRBUF_0                  (uint32_t)0x0          // A hardware trigger does not activate MOD, HCR, CNTIN, and CV registers synchronization.
#define   FTM_SYNCONF_HWWRBUF_1                  (uint32_t)0x1          // A hardware trigger activates MOD, HCR, CNTIN, and CV registers synchronization.
#define FTM_SYNCONF_HWOM                         ((uint32_t)1 << 18)    // Output mask synchronization is activated by a hardware trigger
#define   FTM_SYNCONF_HWOM_0                     (uint32_t)0x0          // A hardware trigger does not activate the OUTMASK register synchronization.
#define   FTM_SYNCONF_HWOM_1                     (uint32_t)0x1          // A hardware trigger activates the OUTMASK register synchronization.
#define FTM_SYNCONF_HWINVC                       ((uint32_t)1 << 19)    // Inverting control synchronization is activated by a hardware trigger
#define   FTM_SYNCONF_HWINVC_0                   (uint32_t)0x0          // A hardware trigger does not activate the INVCTRL register synchronization.
#define   FTM_SYNCONF_HWINVC_1                   (uint32_t)0x1          // A hardware trigger activates the INVCTRL register synchronization.
#define FTM_SYNCONF_HWSOC                        ((uint32_t)1 << 20)    // Software output control synchronization is activated by a hardware trigger
#define   FTM_SYNCONF_HWSOC_0                    (uint32_t)0x0          // A hardware trigger does not activate the SWOCTRL register synchronization.
#define   FTM_SYNCONF_HWSOC_1                    (uint32_t)0x1          // A hardware trigger activates the SWOCTRL register synchronization.

    uint32_t             INVCTRL;                                       // FTM Inverting Control
#define FTM_INVCTRL_INV0EN                       ((uint32_t)1 << 0)     // Pair Channels 0 Inverting Enable
#define   FTM_INVCTRL_INV0EN_0                   (uint32_t)0x0          // Inverting is disabled.
#define   FTM_INVCTRL_INV0EN_1                   (uint32_t)0x1          // Inverting is enabled.
#define FTM_INVCTRL_INV1EN                       ((uint32_t)1 << 1)     // Pair Channels 1 Inverting Enable
#define   FTM_INVCTRL_INV1EN_0                   (uint32_t)0x0          // Inverting is disabled.
#define   FTM_INVCTRL_INV1EN_1                   (uint32_t)0x1          // Inverting is enabled.
#define FTM_INVCTRL_INV2EN                       ((uint32_t)1 << 2)     // Pair Channels 2 Inverting Enable
#define   FTM_INVCTRL_INV2EN_0                   (uint32_t)0x0          // Inverting is disabled.
#define   FTM_INVCTRL_INV2EN_1                   (uint32_t)0x1          // Inverting is enabled.
#define FTM_INVCTRL_INV3EN                       ((uint32_t)1 << 3)     // Pair Channels 3 Inverting Enable
#define   FTM_INVCTRL_INV3EN_0                   (uint32_t)0x0          // Inverting is disabled.
#define   FTM_INVCTRL_INV3EN_1                   (uint32_t)0x1          // Inverting is enabled.

    uint32_t             SWOCTRL;                                       // FTM Software Output Control
#define FTM_SWOCTRL_CH0OC                        ((uint32_t)1 << 0)     // Channel 0 Software Output Control Enable
#define   FTM_SWOCTRL_CH0OC_0                    (uint32_t)0x0          // The channel output is not affected by software output control.
#define   FTM_SWOCTRL_CH0OC_1                    (uint32_t)0x1          // The channel output is affected by software output control.
#define FTM_SWOCTRL_CH1OC                        ((uint32_t)1 << 1)     // Channel 1 Software Output Control Enable
#define   FTM_SWOCTRL_CH1OC_0                    (uint32_t)0x0          // The channel output is not affected by software output control.
#define   FTM_SWOCTRL_CH1OC_1                    (uint32_t)0x1          // The channel output is affected by software output control.
#define FTM_SWOCTRL_CH2OC                        ((uint32_t)1 << 2)     // Channel 2 Software Output Control Enable
#define   FTM_SWOCTRL_CH2OC_0                    (uint32_t)0x0          // The channel output is not affected by software output control.
#define   FTM_SWOCTRL_CH2OC_1                    (uint32_t)0x1          // The channel output is affected by software output control.
#define FTM_SWOCTRL_CH3OC                        ((uint32_t)1 << 3)     // Channel 3 Software Output Control Enable
#define   FTM_SWOCTRL_CH3OC_0                    (uint32_t)0x0          // The channel output is not affected by software output control.
#define   FTM_SWOCTRL_CH3OC_1                    (uint32_t)0x1          // The channel output is affected by software output control.
#define FTM_SWOCTRL_CH4OC                        ((uint32_t)1 << 4)     // Channel 4 Software Output Control Enable
#define   FTM_SWOCTRL_CH4OC_0                    (uint32_t)0x0          // The channel output is not affected by software output control.
#define   FTM_SWOCTRL_CH4OC_1                    (uint32_t)0x1          // The channel output is affected by software output control.
#define FTM_SWOCTRL_CH5OC                        ((uint32_t)1 << 5)     // Channel 5 Software Output Control Enable
#define   FTM_SWOCTRL_CH5OC_0                    (uint32_t)0x0          // The channel output is not affected by software output control.
#define   FTM_SWOCTRL_CH5OC_1                    (uint32_t)0x1          // The channel output is affected by software output control.
#define FTM_SWOCTRL_CH6OC                        ((uint32_t)1 << 6)     // Channel 6 Software Output Control Enable
#define   FTM_SWOCTRL_CH6OC_0                    (uint32_t)0x0          // The channel output is not affected by software output control.
#define   FTM_SWOCTRL_CH6OC_1                    (uint32_t)0x1          // The channel output is affected by software output control.
#define FTM_SWOCTRL_CH7OC                        ((uint32_t)1 << 7)     // Channel 7 Software Output Control Enable
#define   FTM_SWOCTRL_CH7OC_0                    (uint32_t)0x0          // The channel output is not affected by software output control.
#define   FTM_SWOCTRL_CH7OC_1                    (uint32_t)0x1          // The channel output is affected by software output control.
#define FTM_SWOCTRL_CH0OCV                       ((uint32_t)1 << 8)     // Channel 0 Software Output Control Value
#define   FTM_SWOCTRL_CH0OCV_0                   (uint32_t)0x0          // The software output control forces 0 to the channel output.
#define   FTM_SWOCTRL_CH0OCV_1                   (uint32_t)0x1          // The software output control forces 1 to the channel output.
#define FTM_SWOCTRL_CH1OCV                       ((uint32_t)1 << 9)     // Channel 1 Software Output Control Value
#define   FTM_SWOCTRL_CH1OCV_0                   (uint32_t)0x0          // The software output control forces 0 to the channel output.
#define   FTM_SWOCTRL_CH1OCV_1                   (uint32_t)0x1          // The software output control forces 1 to the channel output.
#define FTM_SWOCTRL_CH2OCV                       ((uint32_t)1 << 10)    // Channel 2 Software Output Control Value
#define   FTM_SWOCTRL_CH2OCV_0                   (uint32_t)0x0          // The software output control forces 0 to the channel output.
#define   FTM_SWOCTRL_CH2OCV_1                   (uint32_t)0x1          // The software output control forces 1 to the channel output.
#define FTM_SWOCTRL_CH3OCV                       ((uint32_t)1 << 11)    // Channel 3 Software Output Control Value
#define   FTM_SWOCTRL_CH3OCV_0                   (uint32_t)0x0          // The software output control forces 0 to the channel output.
#define   FTM_SWOCTRL_CH3OCV_1                   (uint32_t)0x1          // The software output control forces 1 to the channel output.
#define FTM_SWOCTRL_CH4OCV                       ((uint32_t)1 << 12)    // Channel 4 Software Output Control Value
#define   FTM_SWOCTRL_CH4OCV_0                   (uint32_t)0x0          // The software output control forces 0 to the channel output.
#define   FTM_SWOCTRL_CH4OCV_1                   (uint32_t)0x1          // The software output control forces 1 to the channel output.
#define FTM_SWOCTRL_CH5OCV                       ((uint32_t)1 << 13)    // Channel 5 Software Output Control Value
#define   FTM_SWOCTRL_CH5OCV_0                   (uint32_t)0x0          // The software output control forces 0 to the channel output.
#define   FTM_SWOCTRL_CH5OCV_1                   (uint32_t)0x1          // The software output control forces 1 to the channel output.
#define FTM_SWOCTRL_CH6OCV                       ((uint32_t)1 << 14)    // Channel 6 Software Output Control Value
#define   FTM_SWOCTRL_CH6OCV_0                   (uint32_t)0x0          // The software output control forces 0 to the channel output.
#define   FTM_SWOCTRL_CH6OCV_1                   (uint32_t)0x1          // The software output control forces 1 to the channel output.
#define FTM_SWOCTRL_CH7OCV                       ((uint32_t)1 << 15)    // Channel 7 Software Output Control Value
#define   FTM_SWOCTRL_CH7OCV_0                   (uint32_t)0x0          // The software output control forces 0 to the channel output.
#define   FTM_SWOCTRL_CH7OCV_1                   (uint32_t)0x1          // The software output control forces 1 to the channel output.

    uint32_t             PWMLOAD;                                       // FTM PWM Load
#define FTM_PWMLOAD_CH0SEL                       ((uint32_t)1 << 0)     // Channel 0 Select
#define   FTM_PWMLOAD_CH0SEL_0                   (uint32_t)0x0          // Channel match is not included as a reload opportunity.
#define   FTM_PWMLOAD_CH0SEL_1                   (uint32_t)0x1          // Channel match is included as a reload opportunity.
#define FTM_PWMLOAD_CH1SEL                       ((uint32_t)1 << 1)     // Channel 1 Select
#define   FTM_PWMLOAD_CH1SEL_0                   (uint32_t)0x0          // Channel match is not included as a reload opportunity.
#define   FTM_PWMLOAD_CH1SEL_1                   (uint32_t)0x1          // Channel match is included as a reload opportunity.
#define FTM_PWMLOAD_CH2SEL                       ((uint32_t)1 << 2)     // Channel 2 Select
#define   FTM_PWMLOAD_CH2SEL_0                   (uint32_t)0x0          // Channel match is not included as a reload opportunity.
#define   FTM_PWMLOAD_CH2SEL_1                   (uint32_t)0x1          // Channel match is included as a reload opportunity.
#define FTM_PWMLOAD_CH3SEL                       ((uint32_t)1 << 3)     // Channel 3 Select
#define   FTM_PWMLOAD_CH3SEL_0                   (uint32_t)0x0          // Channel match is not included as a reload opportunity.
#define   FTM_PWMLOAD_CH3SEL_1                   (uint32_t)0x1          // Channel match is included as a reload opportunity.
#define FTM_PWMLOAD_CH4SEL                       ((uint32_t)1 << 4)     // Channel 4 Select
#define   FTM_PWMLOAD_CH4SEL_0                   (uint32_t)0x0          // Channel match is not included as a reload opportunity.
#define   FTM_PWMLOAD_CH4SEL_1                   (uint32_t)0x1          // Channel match is included as a reload opportunity.
#define FTM_PWMLOAD_CH5SEL                       ((uint32_t)1 << 5)     // Channel 5 Select
#define   FTM_PWMLOAD_CH5SEL_0                   (uint32_t)0x0          // Channel match is not included as a reload opportunity.
#define   FTM_PWMLOAD_CH5SEL_1                   (uint32_t)0x1          // Channel match is included as a reload opportunity.
#define FTM_PWMLOAD_CH6SEL                       ((uint32_t)1 << 6)     // Channel 6 Select
#define   FTM_PWMLOAD_CH6SEL_0                   (uint32_t)0x0          // Channel match is not included as a reload opportunity.
#define   FTM_PWMLOAD_CH6SEL_1                   (uint32_t)0x1          // Channel match is included as a reload opportunity.
#define FTM_PWMLOAD_CH7SEL                       ((uint32_t)1 << 7)     // Channel 7 Select
#define   FTM_PWMLOAD_CH7SEL_0                   (uint32_t)0x0          // Channel match is not included as a reload opportunity.
#define   FTM_PWMLOAD_CH7SEL_1                   (uint32_t)0x1          // Channel match is included as a reload opportunity.
#define FTM_PWMLOAD_HCSEL                        ((uint32_t)1 << 8)     // Half Cycle Select
#define   FTM_PWMLOAD_HCSEL_0                    (uint32_t)0x0          // Half cycle reload is disabled and it is not considered as a reload opportunity.
#define   FTM_PWMLOAD_HCSEL_1                    (uint32_t)0x1          // Half cycle reload is enabled and it is considered as a reload opportunity.
#define FTM_PWMLOAD_LDOK                         ((uint32_t)1 << 9)     // Load Enable
#define   FTM_PWMLOAD_LDOK_0                     (uint32_t)0x0          // Loading updated values is disabled.
#define   FTM_PWMLOAD_LDOK_1                     (uint32_t)0x1          // Loading updated values is enabled.
#define FTM_PWMLOAD_GLEN                         ((uint32_t)1 << 10)    // Global Load Enable
#define   FTM_PWMLOAD_GLEN_0                     (uint32_t)0x0          // Global Load Ok disabled.
#define   FTM_PWMLOAD_GLEN_1                     (uint32_t)0x1          // Global Load OK enabled. A pulse event on the module global load input sets the LDOK bit.
#define FTM_PWMLOAD_GLDOK                        ((uint32_t)1 << 11)    // Global Load OK
#define   FTM_PWMLOAD_GLDOK_0                    (uint32_t)0x0          // No action.
#define   FTM_PWMLOAD_GLDOK_1                    (uint32_t)0x1          // LDOK bit is set.

    uint32_t             HCR;                                           // Half Cycle Register
                                                                        // Half Cycle Value
#define FTM_HCR_HCVAL(_n)                        (((uint32_t)(_n) & 0xffff) << 0)
#define FTM_HCR_HCVAL_INSERT(_v, _n)                 (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FTM_HCR_HCVAL_EXTRACT(_v)                    (((_v) >> 0) & 0xffff)

    uint32_t             PAIR0DEADTIME;                                 // Pair 0 Deadtime Configuration
                                                                        // Deadtime Value
#define FTM_PAIR0DEADTIME_DTVAL(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define FTM_PAIR0DEADTIME_DTVAL_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define FTM_PAIR0DEADTIME_DTVAL_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Deadtime Prescaler Value
#define FTM_PAIR0DEADTIME_DTPS(_n)               (((uint32_t)(_n) & 0x3) << 6)
#define FTM_PAIR0DEADTIME_DTPS_INSERT(_v, _n)        (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define FTM_PAIR0DEADTIME_DTPS_EXTRACT(_v)           (((_v) >> 6) & 0x3)
#define   FTM_PAIR0DEADTIME_DTPS_0x              (uint32_t)0x0          // Divide the FTM input clock by 1.
#define   FTM_PAIR0DEADTIME_DTPS_10              (uint32_t)0x2          // Divide the FTM input clock by 4.
#define   FTM_PAIR0DEADTIME_DTPS_11              (uint32_t)0x3          // Divide the FTM input clock by 16.
                                                                        // Extended Deadtime Value
#define FTM_PAIR0DEADTIME_DTVALEX(_n)            (((uint32_t)(_n) & 0xf) << 16)
#define FTM_PAIR0DEADTIME_DTVALEX_INSERT(_v, _n)     (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define FTM_PAIR0DEADTIME_DTVALEX_EXTRACT(_v)        (((_v) >> 16) & 0xf)

    uint8_t _res0[4];
    uint32_t             PAIR1DEADTIME;                                 // Pair 1 Deadtime Configuration
                                                                        // Deadtime Value
#define FTM_PAIR1DEADTIME_DTVAL(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define FTM_PAIR1DEADTIME_DTVAL_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define FTM_PAIR1DEADTIME_DTVAL_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Deadtime Prescaler Value
#define FTM_PAIR1DEADTIME_DTPS(_n)               (((uint32_t)(_n) & 0x3) << 6)
#define FTM_PAIR1DEADTIME_DTPS_INSERT(_v, _n)        (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define FTM_PAIR1DEADTIME_DTPS_EXTRACT(_v)           (((_v) >> 6) & 0x3)
#define   FTM_PAIR1DEADTIME_DTPS_0x              (uint32_t)0x0          // Divide the FTM input clock by 1.
#define   FTM_PAIR1DEADTIME_DTPS_10              (uint32_t)0x2          // Divide the FTM input clock by 4.
#define   FTM_PAIR1DEADTIME_DTPS_11              (uint32_t)0x3          // Divide the FTM input clock by 16.
                                                                        // Extended Deadtime Value
#define FTM_PAIR1DEADTIME_DTVALEX(_n)            (((uint32_t)(_n) & 0xf) << 16)
#define FTM_PAIR1DEADTIME_DTVALEX_INSERT(_v, _n)     (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define FTM_PAIR1DEADTIME_DTVALEX_EXTRACT(_v)        (((_v) >> 16) & 0xf)

    uint8_t _res1[4];
    uint32_t             PAIR2DEADTIME;                                 // Pair 2 Deadtime Configuration
                                                                        // Deadtime Value
#define FTM_PAIR2DEADTIME_DTVAL(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define FTM_PAIR2DEADTIME_DTVAL_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define FTM_PAIR2DEADTIME_DTVAL_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Deadtime Prescaler Value
#define FTM_PAIR2DEADTIME_DTPS(_n)               (((uint32_t)(_n) & 0x3) << 6)
#define FTM_PAIR2DEADTIME_DTPS_INSERT(_v, _n)        (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define FTM_PAIR2DEADTIME_DTPS_EXTRACT(_v)           (((_v) >> 6) & 0x3)
#define   FTM_PAIR2DEADTIME_DTPS_0x              (uint32_t)0x0          // Divide the FTM input clock by 1.
#define   FTM_PAIR2DEADTIME_DTPS_10              (uint32_t)0x2          // Divide the FTM input clock by 4.
#define   FTM_PAIR2DEADTIME_DTPS_11              (uint32_t)0x3          // Divide the FTM input clock by 16.
                                                                        // Extended Deadtime Value
#define FTM_PAIR2DEADTIME_DTVALEX(_n)            (((uint32_t)(_n) & 0xf) << 16)
#define FTM_PAIR2DEADTIME_DTVALEX_INSERT(_v, _n)     (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define FTM_PAIR2DEADTIME_DTVALEX_EXTRACT(_v)        (((_v) >> 16) & 0xf)

    uint8_t _res2[4];
    uint32_t             PAIR3DEADTIME;                                 // Pair 3 Deadtime Configuration
                                                                        // Deadtime Value
#define FTM_PAIR3DEADTIME_DTVAL(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define FTM_PAIR3DEADTIME_DTVAL_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define FTM_PAIR3DEADTIME_DTVAL_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Deadtime Prescaler Value
#define FTM_PAIR3DEADTIME_DTPS(_n)               (((uint32_t)(_n) & 0x3) << 6)
#define FTM_PAIR3DEADTIME_DTPS_INSERT(_v, _n)        (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define FTM_PAIR3DEADTIME_DTPS_EXTRACT(_v)           (((_v) >> 6) & 0x3)
#define   FTM_PAIR3DEADTIME_DTPS_0x              (uint32_t)0x0          // Divide the FTM input clock by 1.
#define   FTM_PAIR3DEADTIME_DTPS_10              (uint32_t)0x2          // Divide the FTM input clock by 4.
#define   FTM_PAIR3DEADTIME_DTPS_11              (uint32_t)0x3          // Divide the FTM input clock by 16.
                                                                        // Extended Deadtime Value
#define FTM_PAIR3DEADTIME_DTVALEX(_n)            (((uint32_t)(_n) & 0xf) << 16)
#define FTM_PAIR3DEADTIME_DTVALEX_INSERT(_v, _n)     (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define FTM_PAIR3DEADTIME_DTVALEX_EXTRACT(_v)        (((_v) >> 16) & 0xf)

} FTM_regs_t;
                                                                        // --------------------
                                                                        // Analog-to-Digital Converter
typedef struct                                                          // --------------------
{
    uint32_t             SC1A;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1A_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1A_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1A_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1A_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1A_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1A_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1A_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1A_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1A_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1A_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1A_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1A_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1A_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1A_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1A_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1A_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1A_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1A_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1A_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1A_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1A_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1A_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1A_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1A_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1A_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1A_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1A_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1A_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1A_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1A_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1A_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1A_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1A_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1A_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1A_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1A_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1B;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1B_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1B_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1B_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1B_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1B_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1B_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1B_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1B_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1B_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1B_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1B_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1B_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1B_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1B_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1B_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1B_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1B_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1B_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1B_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1B_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1B_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1B_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1B_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1B_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1B_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1B_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1B_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1B_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1B_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1B_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1B_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1B_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1B_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1B_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1B_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1B_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1C;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1C_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1C_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1C_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1C_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1C_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1C_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1C_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1C_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1C_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1C_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1C_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1C_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1C_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1C_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1C_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1C_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1C_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1C_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1C_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1C_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1C_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1C_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1C_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1C_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1C_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1C_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1C_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1C_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1C_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1C_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1C_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1C_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1C_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1C_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1C_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1C_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1D;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1D_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1D_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1D_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1D_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1D_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1D_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1D_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1D_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1D_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1D_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1D_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1D_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1D_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1D_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1D_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1D_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1D_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1D_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1D_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1D_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1D_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1D_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1D_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1D_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1D_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1D_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1D_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1D_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1D_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1D_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1D_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1D_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1D_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1D_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1D_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1D_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1E;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1E_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1E_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1E_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1E_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1E_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1E_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1E_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1E_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1E_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1E_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1E_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1E_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1E_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1E_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1E_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1E_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1E_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1E_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1E_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1E_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1E_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1E_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1E_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1E_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1E_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1E_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1E_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1E_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1E_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1E_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1E_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1E_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1E_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1E_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1E_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1E_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1F;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1F_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1F_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1F_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1F_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1F_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1F_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1F_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1F_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1F_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1F_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1F_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1F_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1F_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1F_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1F_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1F_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1F_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1F_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1F_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1F_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1F_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1F_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1F_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1F_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1F_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1F_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1F_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1F_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1F_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1F_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1F_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1F_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1F_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1F_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1F_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1F_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1G;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1G_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1G_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1G_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1G_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1G_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1G_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1G_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1G_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1G_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1G_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1G_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1G_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1G_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1G_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1G_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1G_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1G_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1G_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1G_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1G_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1G_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1G_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1G_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1G_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1G_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1G_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1G_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1G_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1G_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1G_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1G_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1G_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1G_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1G_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1G_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1G_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1H;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1H_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1H_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1H_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1H_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1H_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1H_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1H_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1H_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1H_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1H_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1H_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1H_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1H_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1H_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1H_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1H_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1H_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1H_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1H_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1H_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1H_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1H_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1H_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1H_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1H_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1H_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1H_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1H_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1H_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1H_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1H_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1H_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1H_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1H_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1H_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1H_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1I;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1I_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1I_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1I_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1I_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1I_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1I_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1I_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1I_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1I_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1I_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1I_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1I_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1I_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1I_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1I_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1I_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1I_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1I_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1I_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1I_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1I_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1I_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1I_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1I_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1I_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1I_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1I_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1I_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1I_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1I_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1I_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1I_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1I_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1I_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1I_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1I_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1J;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1J_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1J_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1J_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1J_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1J_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1J_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1J_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1J_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1J_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1J_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1J_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1J_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1J_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1J_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1J_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1J_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1J_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1J_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1J_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1J_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1J_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1J_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1J_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1J_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1J_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1J_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1J_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1J_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1J_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1J_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1J_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1J_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1J_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1J_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1J_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1J_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1K;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1K_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1K_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1K_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1K_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1K_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1K_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1K_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1K_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1K_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1K_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1K_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1K_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1K_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1K_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1K_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1K_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1K_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1K_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1K_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1K_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1K_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1K_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1K_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1K_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1K_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1K_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1K_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1K_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1K_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1K_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1K_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1K_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1K_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1K_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1K_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1K_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1L;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1L_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1L_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1L_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1L_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1L_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1L_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1L_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1L_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1L_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1L_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1L_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1L_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1L_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1L_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1L_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1L_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1L_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1L_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1L_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1L_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1L_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1L_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1L_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1L_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1L_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1L_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1L_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1L_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1L_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1L_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1L_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1L_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1L_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1L_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1L_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1L_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1M;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1M_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1M_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1M_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1M_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1M_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1M_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1M_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1M_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1M_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1M_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1M_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1M_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1M_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1M_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1M_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1M_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1M_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1M_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1M_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1M_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1M_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1M_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1M_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1M_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1M_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1M_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1M_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1M_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1M_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1M_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1M_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1M_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1M_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1M_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1M_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1M_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1N;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1N_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1N_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1N_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1N_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1N_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1N_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1N_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1N_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1N_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1N_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1N_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1N_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1N_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1N_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1N_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1N_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1N_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1N_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1N_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1N_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1N_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1N_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1N_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1N_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1N_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1N_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1N_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1N_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1N_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1N_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1N_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1N_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1N_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1N_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1N_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1N_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1O;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1O_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1O_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1O_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1O_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1O_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1O_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1O_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1O_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1O_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1O_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1O_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1O_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1O_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1O_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1O_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1O_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1O_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1O_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1O_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1O_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1O_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1O_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1O_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1O_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1O_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1O_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1O_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1O_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1O_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1O_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1O_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1O_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1O_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1O_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1O_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1O_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             SC1P;                                          // ADC Status and Control Register 1
                                                                        // Input channel select
#define ADC_SC1P_ADCH(_n)                        (((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1P_ADCH_INSERT(_v, _n)                 (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define ADC_SC1P_ADCH_EXTRACT(_v)                    (((_v) >> 0) & 0x1f)
#define   ADC_SC1P_ADCH_00000                    (uint32_t)0x0          // Exernal channel 0 is selected as input.
#define   ADC_SC1P_ADCH_00001                    (uint32_t)0x1          // Exernal channel 1 is selected as input.
#define   ADC_SC1P_ADCH_00010                    (uint32_t)0x2          // Exernal channel 2 is selected as input.
#define   ADC_SC1P_ADCH_00011                    (uint32_t)0x3          // Exernal channel 3 is selected as input.
#define   ADC_SC1P_ADCH_00100                    (uint32_t)0x4          // Exernal channel 4 is selected as input.
#define   ADC_SC1P_ADCH_00101                    (uint32_t)0x5          // Exernal channel 5 is selected as input.
#define   ADC_SC1P_ADCH_00110                    (uint32_t)0x6          // Exernal channel 6 is selected as input.
#define   ADC_SC1P_ADCH_00111                    (uint32_t)0x7          // Exernal channel 7 is selected as input.
#define   ADC_SC1P_ADCH_01000                    (uint32_t)0x8          // Exernal channel 8 is selected as input.
#define   ADC_SC1P_ADCH_01001                    (uint32_t)0x9          // Exernal channel 9 is selected as input.
#define   ADC_SC1P_ADCH_01010                    (uint32_t)0xa          // Exernal channel 10 is selected as input.
#define   ADC_SC1P_ADCH_01011                    (uint32_t)0xb          // Exernal channel 11 is selected as input.
#define   ADC_SC1P_ADCH_01100                    (uint32_t)0xc          // Exernal channel 12 is selected as input.
#define   ADC_SC1P_ADCH_01101                    (uint32_t)0xd          // Exernal channel 13 is selected as input.
#define   ADC_SC1P_ADCH_01110                    (uint32_t)0xe          // Exernal channel 14 is selected as input.
#define   ADC_SC1P_ADCH_01111                    (uint32_t)0xf          // Exernal channel 15 is selected as input.
#define   ADC_SC1P_ADCH_10010                    (uint32_t)0x12         // Exernal channel 18 is selected as input.
#define   ADC_SC1P_ADCH_10011                    (uint32_t)0x13         // Exernal channel 19 is selected as input.
#define   ADC_SC1P_ADCH_10101                    (uint32_t)0x15         // Internal channel 0 is selected as input.
#define   ADC_SC1P_ADCH_10110                    (uint32_t)0x16         // Internal channel 1 is selected as input.
#define   ADC_SC1P_ADCH_10111                    (uint32_t)0x17         // Internal channel 2 is selected as input.
#define   ADC_SC1P_ADCH_11010                    (uint32_t)0x1a         // Temp Sensor
#define   ADC_SC1P_ADCH_11011                    (uint32_t)0x1b         // Band Gap
#define   ADC_SC1P_ADCH_11100                    (uint32_t)0x1c         // Internal channel 3 is selected as input.
#define   ADC_SC1P_ADCH_11101                    (uint32_t)0x1d         // VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1P_ADCH_11110                    (uint32_t)0x1e         // VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].
#define   ADC_SC1P_ADCH_11111                    (uint32_t)0x1f         // Module is disabled
#define ADC_SC1P_AIEN                            ((uint32_t)1 << 6)     // Interrupt Enable
#define   ADC_SC1P_AIEN_0                        (uint32_t)0x0          // Conversion complete interrupt is disabled.
#define   ADC_SC1P_AIEN_1                        (uint32_t)0x1          // Conversion complete interrupt is enabled.
#define ADC_SC1P_COCO                            ((uint32_t)1 << 7)     // Conversion Complete Flag
#define   ADC_SC1P_COCO_0                        (uint32_t)0x0          // Conversion is not completed.
#define   ADC_SC1P_COCO_1                        (uint32_t)0x1          // Conversion is completed.

    uint32_t             CFG1;                                          // ADC Configuration Register 1
                                                                        // Input Clock Select
#define ADC_CFG1_ADICLK(_n)                      (((uint32_t)(_n) & 0x3) << 0)
#define ADC_CFG1_ADICLK_INSERT(_v, _n)               (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define ADC_CFG1_ADICLK_EXTRACT(_v)                  (((_v) >> 0) & 0x3)
#define   ADC_CFG1_ADICLK_00                     (uint32_t)0x0          // Alternate clock 1 (ADC_ALTCLK1)
#define   ADC_CFG1_ADICLK_01                     (uint32_t)0x1          // Alternate clock 2 (ADC_ALTCLK2)
#define   ADC_CFG1_ADICLK_10                     (uint32_t)0x2          // Alternate clock 3 (ADC_ALTCLK3)
#define   ADC_CFG1_ADICLK_11                     (uint32_t)0x3          // Alternate clock 4 (ADC_ALTCLK4)
                                                                        // Conversion mode selection
#define ADC_CFG1_MODE(_n)                        (((uint32_t)(_n) & 0x3) << 2)
#define ADC_CFG1_MODE_INSERT(_v, _n)                 (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define ADC_CFG1_MODE_EXTRACT(_v)                    (((_v) >> 2) & 0x3)
#define   ADC_CFG1_MODE_00                       (uint32_t)0x0          // 8-bit conversion.
#define   ADC_CFG1_MODE_01                       (uint32_t)0x1          // 12-bit conversion.
#define   ADC_CFG1_MODE_10                       (uint32_t)0x2          // 10-bit conversion.
                                                                        // Clock Divide Select
#define ADC_CFG1_ADIV(_n)                        (((uint32_t)(_n) & 0x3) << 5)
#define ADC_CFG1_ADIV_INSERT(_v, _n)                 (((_v) & ~0x60) | ((uint32_t)(_n) & 0x3) << 5)
#define ADC_CFG1_ADIV_EXTRACT(_v)                    (((_v) >> 5) & 0x3)
#define   ADC_CFG1_ADIV_00                       (uint32_t)0x0          // The divide ratio is 1 and the clock rate is input clock.
#define   ADC_CFG1_ADIV_01                       (uint32_t)0x1          // The divide ratio is 2 and the clock rate is (input clock)/2.
#define   ADC_CFG1_ADIV_10                       (uint32_t)0x2          // The divide ratio is 4 and the clock rate is (input clock)/4.
#define   ADC_CFG1_ADIV_11                       (uint32_t)0x3          // The divide ratio is 8 and the clock rate is (input clock)/8.
#define ADC_CFG1_CLRLTRG                         ((uint32_t)1 << 8)     // Clear Latch Trigger in Trigger Handler Block

    uint32_t             CFG2;                                          // ADC Configuration Register 2
                                                                        // Sample Time Select
#define ADC_CFG2_SMPLTS(_n)                      (((uint32_t)(_n) & 0xff) << 0)
#define ADC_CFG2_SMPLTS_INSERT(_v, _n)               (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define ADC_CFG2_SMPLTS_EXTRACT(_v)                  (((_v) >> 0) & 0xff)

    const uint32_t       RA;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RA_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RB;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RB_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RC;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RC_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RD;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RD_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RE;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RE_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RF;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RF_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RG;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RG_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RH;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RH_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RI;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RI_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RJ;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RJ_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RK;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RK_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RL;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RL_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RM;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RM_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RN;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RN_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RO;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RO_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    const uint32_t       RP;                                            // ADC Data Result Registers
                                                                        // Data result
#define ADC_RP_D_EXTRACT(_v)                         (((_v) >> 0) & 0xfff)

    uint32_t             CV1;                                           // Compare Value Registers
                                                                        // Compare Value.
#define ADC_CV1_CV(_n)                           (((uint32_t)(_n) & 0xffff) << 0)
#define ADC_CV1_CV_INSERT(_v, _n)                    (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define ADC_CV1_CV_EXTRACT(_v)                       (((_v) >> 0) & 0xffff)

    uint32_t             CV2;                                           // Compare Value Registers
                                                                        // Compare Value.
#define ADC_CV2_CV(_n)                           (((uint32_t)(_n) & 0xffff) << 0)
#define ADC_CV2_CV_INSERT(_v, _n)                    (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define ADC_CV2_CV_EXTRACT(_v)                       (((_v) >> 0) & 0xffff)

    uint32_t             SC2;                                           // Status and Control Register 2
                                                                        // Voltage Reference Selection
#define ADC_SC2_REFSEL(_n)                       (((uint32_t)(_n) & 0x3) << 0)
#define ADC_SC2_REFSEL_INSERT(_v, _n)                (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define ADC_SC2_REFSEL_EXTRACT(_v)                   (((_v) >> 0) & 0x3)
#define   ADC_SC2_REFSEL_00                      (uint32_t)0x0          // Default voltage reference pin pair, that is, external pins VREFH and VREFL
#define   ADC_SC2_REFSEL_01                      (uint32_t)0x1          // Alternate reference voltage, that is, VALTH. This voltage may be additional external pin or internal source depending on the MCU configuration. See the chip configuration information for details specific to this MCU.
#define ADC_SC2_DMAEN                            ((uint32_t)1 << 2)     // DMA Enable
#define   ADC_SC2_DMAEN_0                        (uint32_t)0x0          // DMA is disabled.
#define   ADC_SC2_DMAEN_1                        (uint32_t)0x1          // DMA is enabled and will assert the ADC DMA request during an ADC conversion complete event , which is indicated when any SC1n[COCO] flag is asserted.
#define ADC_SC2_ACREN                            ((uint32_t)1 << 3)     // Compare Function Range Enable
#define ADC_SC2_ACFGT                            ((uint32_t)1 << 4)     // Compare Function Greater Than Enable
#define ADC_SC2_ACFE                             ((uint32_t)1 << 5)     // Compare Function Enable
#define   ADC_SC2_ACFE_0                         (uint32_t)0x0          // Compare function disabled.
#define   ADC_SC2_ACFE_1                         (uint32_t)0x1          // Compare function enabled.
#define ADC_SC2_ADTRG                            ((uint32_t)1 << 6)     // Conversion Trigger Select
#define   ADC_SC2_ADTRG_0                        (uint32_t)0x0          // Software trigger selected.
#define   ADC_SC2_ADTRG_1                        (uint32_t)0x1          // Hardware trigger selected.
#define ADC_SC2_ADACT                            ((uint32_t)1 << 7)     // Conversion Active
#define   ADC_SC2_ADACT_0                        (uint32_t)0x0          // Conversion not in progress.
#define   ADC_SC2_ADACT_1                        (uint32_t)0x1          // Conversion in progress.
                                                                        // Trigger Process Number
#define ADC_SC2_TRGPRNUM(_n)                     (((uint32_t)(_n) & 0x3) << 13)
#define ADC_SC2_TRGPRNUM_INSERT(_v, _n)              (((_v) & ~0x6000) | ((uint32_t)(_n) & 0x3) << 13)
#define ADC_SC2_TRGPRNUM_EXTRACT(_v)                 (((_v) >> 13) & 0x3)
                                                                        // Trigger Status
#define ADC_SC2_TRGSTLAT(_n)                     (((uint32_t)(_n) & 0xf) << 16)
#define ADC_SC2_TRGSTLAT_INSERT(_v, _n)              (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define ADC_SC2_TRGSTLAT_EXTRACT(_v)                 (((_v) >> 16) & 0xf)
#define   ADC_SC2_TRGSTLAT_0                     (uint32_t)0x0          // No trigger request has been latched
#define   ADC_SC2_TRGSTLAT_1                     (uint32_t)0x1          // A trigger request has been latched
                                                                        // Error in Multiplexed Trigger Request
#define ADC_SC2_TRGSTERR(_n)                     (((uint32_t)(_n) & 0xf) << 24)
#define ADC_SC2_TRGSTERR_INSERT(_v, _n)              (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define ADC_SC2_TRGSTERR_EXTRACT(_v)                 (((_v) >> 24) & 0xf)
#define   ADC_SC2_TRGSTERR_0                     (uint32_t)0x0          // No error has occurred
#define   ADC_SC2_TRGSTERR_1                     (uint32_t)0x1          // An error has occurred

    uint32_t             SC3;                                           // Status and Control Register 3
                                                                        // Hardware Average Select
#define ADC_SC3_AVGS(_n)                         (((uint32_t)(_n) & 0x3) << 0)
#define ADC_SC3_AVGS_INSERT(_v, _n)                  (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define ADC_SC3_AVGS_EXTRACT(_v)                     (((_v) >> 0) & 0x3)
#define   ADC_SC3_AVGS_00                        (uint32_t)0x0          // 4 samples averaged.
#define   ADC_SC3_AVGS_01                        (uint32_t)0x1          // 8 samples averaged.
#define   ADC_SC3_AVGS_10                        (uint32_t)0x2          // 16 samples averaged.
#define   ADC_SC3_AVGS_11                        (uint32_t)0x3          // 32 samples averaged.
#define ADC_SC3_AVGE                             ((uint32_t)1 << 2)     // Hardware Average Enable
#define   ADC_SC3_AVGE_0                         (uint32_t)0x0          // Hardware average function disabled.
#define   ADC_SC3_AVGE_1                         (uint32_t)0x1          // Hardware average function enabled.
#define ADC_SC3_ADCO                             ((uint32_t)1 << 3)     // Continuous Conversion Enable
#define   ADC_SC3_ADCO_0                         (uint32_t)0x0          // One conversion will be performed (or one set of conversions, if AVGE is set) after a conversion is initiated.
#define   ADC_SC3_ADCO_1                         (uint32_t)0x1          // Continuous conversions will be performed (or continuous sets of conversions, if AVGE is set) after a conversion is initiated.
#define ADC_SC3_CAL                              ((uint32_t)1 << 7)     // Calibration

    uint32_t             BASE_OFS;                                      // BASE Offset Register
                                                                        // Base Offset Error Correction Value
#define ADC_BASE_OFS_BA_OFS(_n)                  (((uint32_t)(_n) & 0xff) << 0)
#define ADC_BASE_OFS_BA_OFS_INSERT(_v, _n)           (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define ADC_BASE_OFS_BA_OFS_EXTRACT(_v)              (((_v) >> 0) & 0xff)

    uint32_t             OFS;                                           // ADC Offset Correction Register
                                                                        // Offset Error Correction Value
#define ADC_OFS_OFS(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define ADC_OFS_OFS_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define ADC_OFS_OFS_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             USR_OFS;                                       // USER Offset Correction Register
                                                                        // USER Offset Error Correction Value
#define ADC_USR_OFS_USR_OFS(_n)                  (((uint32_t)(_n) & 0xff) << 0)
#define ADC_USR_OFS_USR_OFS_INSERT(_v, _n)           (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define ADC_USR_OFS_USR_OFS_EXTRACT(_v)              (((_v) >> 0) & 0xff)

    uint32_t             XOFS;                                          // ADC X Offset Correction Register
                                                                        // X offset error correction value
#define ADC_XOFS_XOFS(_n)                        (((uint32_t)(_n) & 0x3f) << 0)
#define ADC_XOFS_XOFS_INSERT(_v, _n)                 (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define ADC_XOFS_XOFS_EXTRACT(_v)                    (((_v) >> 0) & 0x3f)

    uint32_t             YOFS;                                          // ADC Y Offset Correction Register
                                                                        // Y offset error correction value
#define ADC_YOFS_YOFS(_n)                        (((uint32_t)(_n) & 0xff) << 0)
#define ADC_YOFS_YOFS_INSERT(_v, _n)                 (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define ADC_YOFS_YOFS_EXTRACT(_v)                    (((_v) >> 0) & 0xff)

    uint32_t             G;                                             // ADC Gain Register
                                                                        // Gain error adjustment factor for the overall conversion
#define ADC_G_G(_n)                              (((uint32_t)(_n) & 0x7ff) << 0)
#define ADC_G_G_INSERT(_v, _n)                       (((_v) & ~0x7ff) | ((uint32_t)(_n) & 0x7ff) << 0)
#define ADC_G_G_EXTRACT(_v)                          (((_v) >> 0) & 0x7ff)

    uint32_t             UG;                                            // ADC User Gain Register
                                                                        // User gain error correction value
#define ADC_UG_UG(_n)                            (((uint32_t)(_n) & 0x3ff) << 0)
#define ADC_UG_UG_INSERT(_v, _n)                     (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define ADC_UG_UG_EXTRACT(_v)                        (((_v) >> 0) & 0x3ff)

    uint32_t             CLPS;                                          // ADC General Calibration Value Register S
                                                                        // Calibration Value
#define ADC_CLPS_CLPS(_n)                        (((uint32_t)(_n) & 0x7f) << 0)
#define ADC_CLPS_CLPS_INSERT(_v, _n)                 (((_v) & ~0x7f) | ((uint32_t)(_n) & 0x7f) << 0)
#define ADC_CLPS_CLPS_EXTRACT(_v)                    (((_v) >> 0) & 0x7f)

    uint32_t             CLP3;                                          // ADC Plus-Side General Calibration Value Register 3
                                                                        // Calibration Value
#define ADC_CLP3_CLP3(_n)                        (((uint32_t)(_n) & 0x3ff) << 0)
#define ADC_CLP3_CLP3_INSERT(_v, _n)                 (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define ADC_CLP3_CLP3_EXTRACT(_v)                    (((_v) >> 0) & 0x3ff)

    uint32_t             CLP2;                                          // ADC Plus-Side General Calibration Value Register 2
                                                                        // Calibration Value
#define ADC_CLP2_CLP2(_n)                        (((uint32_t)(_n) & 0x3ff) << 0)
#define ADC_CLP2_CLP2_INSERT(_v, _n)                 (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define ADC_CLP2_CLP2_EXTRACT(_v)                    (((_v) >> 0) & 0x3ff)

    uint32_t             CLP1;                                          // ADC Plus-Side General Calibration Value Register 1
                                                                        // Calibration Value
#define ADC_CLP1_CLP1(_n)                        (((uint32_t)(_n) & 0x1ff) << 0)
#define ADC_CLP1_CLP1_INSERT(_v, _n)                 (((_v) & ~0x1ff) | ((uint32_t)(_n) & 0x1ff) << 0)
#define ADC_CLP1_CLP1_EXTRACT(_v)                    (((_v) >> 0) & 0x1ff)

    uint32_t             CLP0;                                          // ADC Plus-Side General Calibration Value Register 0
                                                                        // Calibration Value
#define ADC_CLP0_CLP0(_n)                        (((uint32_t)(_n) & 0xff) << 0)
#define ADC_CLP0_CLP0_INSERT(_v, _n)                 (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define ADC_CLP0_CLP0_EXTRACT(_v)                    (((_v) >> 0) & 0xff)

    uint32_t             CLPX;                                          // ADC Plus-Side General Calibration Value Register X
                                                                        // Calibration Value
#define ADC_CLPX_CLPX(_n)                        (((uint32_t)(_n) & 0x7f) << 0)
#define ADC_CLPX_CLPX_INSERT(_v, _n)                 (((_v) & ~0x7f) | ((uint32_t)(_n) & 0x7f) << 0)
#define ADC_CLPX_CLPX_EXTRACT(_v)                    (((_v) >> 0) & 0x7f)

    uint32_t             CLP9;                                          // ADC Plus-Side General Calibration Value Register 9
                                                                        // Calibration Value
#define ADC_CLP9_CLP9(_n)                        (((uint32_t)(_n) & 0x7f) << 0)
#define ADC_CLP9_CLP9_INSERT(_v, _n)                 (((_v) & ~0x7f) | ((uint32_t)(_n) & 0x7f) << 0)
#define ADC_CLP9_CLP9_EXTRACT(_v)                    (((_v) >> 0) & 0x7f)

    uint32_t             CLPS_OFS;                                      // ADC General Calibration Offset Value Register S
                                                                        // CLPS Offset
#define ADC_CLPS_OFS_CLPS_OFS(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLPS_OFS_CLPS_OFS_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLPS_OFS_CLPS_OFS_EXTRACT(_v)            (((_v) >> 0) & 0xf)

    uint32_t             CLP3_OFS;                                      // ADC Plus-Side General Calibration Offset Value Register 3
                                                                        // CLP3 Offset
#define ADC_CLP3_OFS_CLP3_OFS(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLP3_OFS_CLP3_OFS_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLP3_OFS_CLP3_OFS_EXTRACT(_v)            (((_v) >> 0) & 0xf)

    uint32_t             CLP2_OFS;                                      // ADC Plus-Side General Calibration Offset Value Register 2
                                                                        // CLP2 Offset
#define ADC_CLP2_OFS_CLP2_OFS(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLP2_OFS_CLP2_OFS_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLP2_OFS_CLP2_OFS_EXTRACT(_v)            (((_v) >> 0) & 0xf)

    uint32_t             CLP1_OFS;                                      // ADC Plus-Side General Calibration Offset Value Register 1
                                                                        // CLP1 Offset
#define ADC_CLP1_OFS_CLP1_OFS(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLP1_OFS_CLP1_OFS_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLP1_OFS_CLP1_OFS_EXTRACT(_v)            (((_v) >> 0) & 0xf)

    uint32_t             CLP0_OFS;                                      // ADC Plus-Side General Calibration Offset Value Register 0
                                                                        // CLP0 Offset
#define ADC_CLP0_OFS_CLP0_OFS(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLP0_OFS_CLP0_OFS_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define ADC_CLP0_OFS_CLP0_OFS_EXTRACT(_v)            (((_v) >> 0) & 0xf)

    uint32_t             CLPX_OFS;                                      // ADC Plus-Side General Calibration Offset Value Register X
                                                                        // CLPX Offset
#define ADC_CLPX_OFS_CLPX_OFS(_n)                (((uint32_t)(_n) & 0xfff) << 0)
#define ADC_CLPX_OFS_CLPX_OFS_INSERT(_v, _n)         (((_v) & ~0xfff) | ((uint32_t)(_n) & 0xfff) << 0)
#define ADC_CLPX_OFS_CLPX_OFS_EXTRACT(_v)            (((_v) >> 0) & 0xfff)

    uint32_t             CLP9_OFS;                                      // ADC Plus-Side General Calibration Offset Value Register 9
                                                                        // CLP9 Offset
#define ADC_CLP9_OFS_CLP9_OFS(_n)                (((uint32_t)(_n) & 0xfff) << 0)
#define ADC_CLP9_OFS_CLP9_OFS_INSERT(_v, _n)         (((_v) & ~0xfff) | ((uint32_t)(_n) & 0xfff) << 0)
#define ADC_CLP9_OFS_CLP9_OFS_EXTRACT(_v)            (((_v) >> 0) & 0xfff)

} ADC_regs_t;
                                                                        // --------------------
                                                                        // The LPSPI Memory Map/Register Definition can be found here.
typedef struct                                                          // --------------------
{
    const uint32_t       VERID;                                         // Version ID Register
                                                                        // Module Identification Number
#define LPSPI_VERID_FEATURE_EXTRACT(_v)              (((_v) >> 0) & 0xffff)
#define   LPSPI_VERID_FEATURE_0000000000000100   (uint32_t)0x4          // Standard feature set supporting 32-bit shift register.
                                                                        // Minor Version Number
#define LPSPI_VERID_MINOR_EXTRACT(_v)                (((_v) >> 16) & 0xff)
                                                                        // Major Version Number
#define LPSPI_VERID_MAJOR_EXTRACT(_v)                (((_v) >> 24) & 0xff)

    const uint32_t       PARAM;                                         // Parameter Register
                                                                        // Transmit FIFO Size
#define LPSPI_PARAM_TXFIFO_EXTRACT(_v)               (((_v) >> 0) & 0xff)
                                                                        // Receive FIFO Size
#define LPSPI_PARAM_RXFIFO_EXTRACT(_v)               (((_v) >> 8) & 0xff)

    uint8_t _res0[8];
    uint32_t             CR;                                            // Control Register
#define LPSPI_CR_MEN                             ((uint32_t)1 << 0)     // Module Enable
#define   LPSPI_CR_MEN_0                         (uint32_t)0x0          // Module is disabled.
#define   LPSPI_CR_MEN_1                         (uint32_t)0x1          // Module is enabled.
#define LPSPI_CR_RST                             ((uint32_t)1 << 1)     // Software Reset
#define   LPSPI_CR_RST_0                         (uint32_t)0x0          // Master logic is not reset.
#define   LPSPI_CR_RST_1                         (uint32_t)0x1          // Master logic is reset.
#define LPSPI_CR_DOZEN                           ((uint32_t)1 << 2)     // Doze mode enable
#define   LPSPI_CR_DOZEN_0                       (uint32_t)0x0          // Module is enabled in Doze mode.
#define   LPSPI_CR_DOZEN_1                       (uint32_t)0x1          // Module is disabled in Doze mode.
#define LPSPI_CR_DBGEN                           ((uint32_t)1 << 3)     // Debug Enable
#define   LPSPI_CR_DBGEN_0                       (uint32_t)0x0          // Module is disabled in debug mode.
#define   LPSPI_CR_DBGEN_1                       (uint32_t)0x1          // Module is enabled in debug mode.
#define LPSPI_CR_RTF                             ((uint32_t)1 << 8)     // Reset Transmit FIFO
#define   LPSPI_CR_RTF_0                         (uint32_t)0x0          // No effect.
#define   LPSPI_CR_RTF_1                         (uint32_t)0x1          // Transmit FIFO is reset.
#define LPSPI_CR_RRF                             ((uint32_t)1 << 9)     // Reset Receive FIFO
#define   LPSPI_CR_RRF_0                         (uint32_t)0x0          // No effect.
#define   LPSPI_CR_RRF_1                         (uint32_t)0x1          // Receive FIFO is reset.

    uint32_t             SR;                                            // Status Register
#define LPSPI_SR_TDF                             ((uint32_t)1 << 0)     // Transmit Data Flag
#define   LPSPI_SR_TDF_0                         (uint32_t)0x0          // Transmit data not requested.
#define   LPSPI_SR_TDF_1                         (uint32_t)0x1          // Transmit data is requested.
#define LPSPI_SR_RDF                             ((uint32_t)1 << 1)     // Receive Data Flag
#define   LPSPI_SR_RDF_0                         (uint32_t)0x0          // Receive Data is not ready.
#define   LPSPI_SR_RDF_1                         (uint32_t)0x1          // Receive data is ready.
#define LPSPI_SR_WCF                             ((uint32_t)1 << 8)     // Word Complete Flag
#define   LPSPI_SR_WCF_0                         (uint32_t)0x0          // Transfer word not completed.
#define   LPSPI_SR_WCF_1                         (uint32_t)0x1          // Transfer word completed.
#define LPSPI_SR_FCF                             ((uint32_t)1 << 9)     // Frame Complete Flag
#define   LPSPI_SR_FCF_0                         (uint32_t)0x0          // Frame transfer has not completed.
#define   LPSPI_SR_FCF_1                         (uint32_t)0x1          // Frame transfer has completed.
#define LPSPI_SR_TCF                             ((uint32_t)1 << 10)    // Transfer Complete Flag
#define   LPSPI_SR_TCF_0                         (uint32_t)0x0          // All transfers have not completed.
#define   LPSPI_SR_TCF_1                         (uint32_t)0x1          // All transfers have completed.
#define LPSPI_SR_TEF                             ((uint32_t)1 << 11)    // Transmit Error Flag
#define   LPSPI_SR_TEF_0                         (uint32_t)0x0          // Transmit FIFO underrun has not occurred.
#define   LPSPI_SR_TEF_1                         (uint32_t)0x1          // Transmit FIFO underrun has occurred
#define LPSPI_SR_REF                             ((uint32_t)1 << 12)    // Receive Error Flag
#define   LPSPI_SR_REF_0                         (uint32_t)0x0          // Receive FIFO has not overflowed.
#define   LPSPI_SR_REF_1                         (uint32_t)0x1          // Receive FIFO has overflowed.
#define LPSPI_SR_DMF                             ((uint32_t)1 << 13)    // Data Match Flag
#define   LPSPI_SR_DMF_0                         (uint32_t)0x0          // Have not received matching data.
#define   LPSPI_SR_DMF_1                         (uint32_t)0x1          // Have received matching data.
#define LPSPI_SR_MBF                             ((uint32_t)1 << 24)    // Module Busy Flag
#define   LPSPI_SR_MBF_0                         (uint32_t)0x0          // LPSPI is idle.
#define   LPSPI_SR_MBF_1                         (uint32_t)0x1          // LPSPI is busy.

    uint32_t             IER;                                           // Interrupt Enable Register
#define LPSPI_IER_TDIE                           ((uint32_t)1 << 0)     // Transmit Data Interrupt Enable
#define   LPSPI_IER_TDIE_0                       (uint32_t)0x0          // Interrupt disabled.
#define   LPSPI_IER_TDIE_1                       (uint32_t)0x1          // Interrupt enabled
#define LPSPI_IER_RDIE                           ((uint32_t)1 << 1)     // Receive Data Interrupt Enable
#define   LPSPI_IER_RDIE_0                       (uint32_t)0x0          // Interrupt disabled.
#define   LPSPI_IER_RDIE_1                       (uint32_t)0x1          // Interrupt enabled.
#define LPSPI_IER_WCIE                           ((uint32_t)1 << 8)     // Word Complete Interrupt Enable
#define   LPSPI_IER_WCIE_0                       (uint32_t)0x0          // Interrupt disabled.
#define   LPSPI_IER_WCIE_1                       (uint32_t)0x1          // Interrupt enabled.
#define LPSPI_IER_FCIE                           ((uint32_t)1 << 9)     // Frame Complete Interrupt Enable
#define   LPSPI_IER_FCIE_0                       (uint32_t)0x0          // Interrupt disabled.
#define   LPSPI_IER_FCIE_1                       (uint32_t)0x1          // Interrupt enabled.
#define LPSPI_IER_TCIE                           ((uint32_t)1 << 10)    // Transfer Complete Interrupt Enable
#define   LPSPI_IER_TCIE_0                       (uint32_t)0x0          // Interrupt disabled.
#define   LPSPI_IER_TCIE_1                       (uint32_t)0x1          // Interrupt enabled.
#define LPSPI_IER_TEIE                           ((uint32_t)1 << 11)    // Transmit Error Interrupt Enable
#define   LPSPI_IER_TEIE_0                       (uint32_t)0x0          // Interrupt disabled.
#define   LPSPI_IER_TEIE_1                       (uint32_t)0x1          // Interrupt enabled.
#define LPSPI_IER_REIE                           ((uint32_t)1 << 12)    // Receive Error Interrupt Enable
#define   LPSPI_IER_REIE_0                       (uint32_t)0x0          // Interrupt disabled.
#define   LPSPI_IER_REIE_1                       (uint32_t)0x1          // Interrupt enabled.
#define LPSPI_IER_DMIE                           ((uint32_t)1 << 13)    // Data Match Interrupt Enable
#define   LPSPI_IER_DMIE_0                       (uint32_t)0x0          // Interrupt disabled.
#define   LPSPI_IER_DMIE_1                       (uint32_t)0x1          // Interrupt enabled.

    uint32_t             DER;                                           // DMA Enable Register
#define LPSPI_DER_TDDE                           ((uint32_t)1 << 0)     // Transmit Data DMA Enable
#define   LPSPI_DER_TDDE_0                       (uint32_t)0x0          // DMA request disabled.
#define   LPSPI_DER_TDDE_1                       (uint32_t)0x1          // DMA request enabled
#define LPSPI_DER_RDDE                           ((uint32_t)1 << 1)     // Receive Data DMA Enable
#define   LPSPI_DER_RDDE_0                       (uint32_t)0x0          // DMA request disabled.
#define   LPSPI_DER_RDDE_1                       (uint32_t)0x1          // DMA request enabled.

    uint32_t             CFGR0;                                         // Configuration Register 0
#define LPSPI_CFGR0_HREN                         ((uint32_t)1 << 0)     // Host Request Enable
#define   LPSPI_CFGR0_HREN_0                     (uint32_t)0x0          // Host request is disabled.
#define   LPSPI_CFGR0_HREN_1                     (uint32_t)0x1          // Host request is enabled.
#define LPSPI_CFGR0_HRPOL                        ((uint32_t)1 << 1)     // Host Request Polarity
#define   LPSPI_CFGR0_HRPOL_0                    (uint32_t)0x0          // Active low.
#define   LPSPI_CFGR0_HRPOL_1                    (uint32_t)0x1          // Active high.
#define LPSPI_CFGR0_HRSEL                        ((uint32_t)1 << 2)     // Host Request Select
#define   LPSPI_CFGR0_HRSEL_0                    (uint32_t)0x0          // Host request input is pin LPSPI_HREQ.
#define   LPSPI_CFGR0_HRSEL_1                    (uint32_t)0x1          // Host request input is input trigger.
#define LPSPI_CFGR0_CIRFIFO                      ((uint32_t)1 << 8)     // Circular FIFO Enable
#define   LPSPI_CFGR0_CIRFIFO_0                  (uint32_t)0x0          // Circular FIFO is disabled.
#define   LPSPI_CFGR0_CIRFIFO_1                  (uint32_t)0x1          // Circular FIFO is enabled.
#define LPSPI_CFGR0_RDMO                         ((uint32_t)1 << 9)     // Receive Data Match Only
#define   LPSPI_CFGR0_RDMO_0                     (uint32_t)0x0          // Received data is stored in the receive FIFO as normal.
#define   LPSPI_CFGR0_RDMO_1                     (uint32_t)0x1          // Received data is discarded unless the DMF is set.

    uint32_t             CFGR1;                                         // Configuration Register 1
#define LPSPI_CFGR1_MASTER                       ((uint32_t)1 << 0)     // Master Mode
#define   LPSPI_CFGR1_MASTER_0                   (uint32_t)0x0          // Slave mode.
#define   LPSPI_CFGR1_MASTER_1                   (uint32_t)0x1          // Master mode.
#define LPSPI_CFGR1_SAMPLE                       ((uint32_t)1 << 1)     // Sample Point
#define   LPSPI_CFGR1_SAMPLE_0                   (uint32_t)0x0          // Input data sampled on SCK edge.
#define   LPSPI_CFGR1_SAMPLE_1                   (uint32_t)0x1          // Input data sampled on delayed SCK edge.
#define LPSPI_CFGR1_AUTOPCS                      ((uint32_t)1 << 2)     // Automatic PCS
#define   LPSPI_CFGR1_AUTOPCS_0                  (uint32_t)0x0          // Automatic PCS generation disabled.
#define   LPSPI_CFGR1_AUTOPCS_1                  (uint32_t)0x1          // Automatic PCS generation enabled.
#define LPSPI_CFGR1_NOSTALL                      ((uint32_t)1 << 3)     // No Stall
#define   LPSPI_CFGR1_NOSTALL_0                  (uint32_t)0x0          // Transfers will stall when transmit FIFO is empty or receive FIFO is full.
#define   LPSPI_CFGR1_NOSTALL_1                  (uint32_t)0x1          // Transfers will not stall, allowing transmit FIFO underrun or receive FIFO overrun to occur.
                                                                        // Peripheral Chip Select Polarity
#define LPSPI_CFGR1_PCSPOL(_n)                   (((uint32_t)(_n) & 0xf) << 8)
#define LPSPI_CFGR1_PCSPOL_INSERT(_v, _n)            (((_v) & ~0xf00) | ((uint32_t)(_n) & 0xf) << 8)
#define LPSPI_CFGR1_PCSPOL_EXTRACT(_v)               (((_v) >> 8) & 0xf)
#define   LPSPI_CFGR1_PCSPOL_0000                (uint32_t)0x0          // The PCSx is active low.
#define   LPSPI_CFGR1_PCSPOL_0001                (uint32_t)0x1          // The PCSx is active high.
                                                                        // Match Configuration
#define LPSPI_CFGR1_MATCFG(_n)                   (((uint32_t)(_n) & 0x7) << 16)
#define LPSPI_CFGR1_MATCFG_INSERT(_v, _n)            (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define LPSPI_CFGR1_MATCFG_EXTRACT(_v)               (((_v) >> 16) & 0x7)
#define   LPSPI_CFGR1_MATCFG_000                 (uint32_t)0x0          // Match is disabled.
#define   LPSPI_CFGR1_MATCFG_010                 (uint32_t)0x2          // 010b - Match is enabled, if 1st data word equals MATCH0 OR MATCH1, i.e., (1st data word = MATCH0 + MATCH1)
#define   LPSPI_CFGR1_MATCFG_011                 (uint32_t)0x3          // 011b - Match is enabled, if any data word equals MATCH0 OR MATCH1, i.e., (any data word = MATCH0 + MATCH1)
#define   LPSPI_CFGR1_MATCFG_100                 (uint32_t)0x4          // 100b - Match is enabled, if 1st data word equals MATCH0 AND 2nd data word equals MATCH1, i.e., [(1st data word = MATCH0) * (2nd data word = MATCH1)]
#define   LPSPI_CFGR1_MATCFG_101                 (uint32_t)0x5          // 101b - Match is enabled, if any data word equals MATCH0 AND the next data word equals MATCH1, i.e., [(any data word = MATCH0) * (next data word = MATCH1)]
#define   LPSPI_CFGR1_MATCFG_110                 (uint32_t)0x6          // 110b - Match is enabled, if (1st data word AND MATCH1) equals (MATCH0 AND MATCH1), i.e., [(1st data word * MATCH1) = (MATCH0 * MATCH1)]
#define   LPSPI_CFGR1_MATCFG_111                 (uint32_t)0x7          // 111b - Match is enabled, if (any data word AND MATCH1) equals (MATCH0 AND MATCH1), i.e., [(any data word * MATCH1) = (MATCH0 * MATCH1)]
                                                                        // Pin Configuration
#define LPSPI_CFGR1_PINCFG(_n)                   (((uint32_t)(_n) & 0x3) << 24)
#define LPSPI_CFGR1_PINCFG_INSERT(_v, _n)            (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define LPSPI_CFGR1_PINCFG_EXTRACT(_v)               (((_v) >> 24) & 0x3)
#define   LPSPI_CFGR1_PINCFG_00                  (uint32_t)0x0          // SIN is used for input data and SOUT for output data.
#define   LPSPI_CFGR1_PINCFG_01                  (uint32_t)0x1          // SIN is used for both input and output data.
#define   LPSPI_CFGR1_PINCFG_10                  (uint32_t)0x2          // SOUT is used for both input and output data.
#define   LPSPI_CFGR1_PINCFG_11                  (uint32_t)0x3          // SOUT is used for input data and SIN for output data.
#define LPSPI_CFGR1_OUTCFG                       ((uint32_t)1 << 26)    // Output Config
#define   LPSPI_CFGR1_OUTCFG_0                   (uint32_t)0x0          // Output data retains last value when chip select is negated.
#define   LPSPI_CFGR1_OUTCFG_1                   (uint32_t)0x1          // Output data is tristated when chip select is negated.
#define LPSPI_CFGR1_PCSCFG                       ((uint32_t)1 << 27)    // Peripheral Chip Select Configuration
#define   LPSPI_CFGR1_PCSCFG_0                   (uint32_t)0x0          // PCS[3:2] are enabled.
#define   LPSPI_CFGR1_PCSCFG_1                   (uint32_t)0x1          // PCS[3:2] are disabled.

    uint8_t _res1[8];
    uint32_t             DMR0;                                          // Data Match Register 0
    uint32_t             DMR1;                                          // Data Match Register 1
    uint8_t _res2[8];
    uint32_t             CCR;                                           // Clock Configuration Register
                                                                        // SCK Divider
#define LPSPI_CCR_SCKDIV(_n)                     (((uint32_t)(_n) & 0xff) << 0)
#define LPSPI_CCR_SCKDIV_INSERT(_v, _n)              (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define LPSPI_CCR_SCKDIV_EXTRACT(_v)                 (((_v) >> 0) & 0xff)
                                                                        // Delay Between Transfers
#define LPSPI_CCR_DBT(_n)                        (((uint32_t)(_n) & 0xff) << 8)
#define LPSPI_CCR_DBT_INSERT(_v, _n)                 (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define LPSPI_CCR_DBT_EXTRACT(_v)                    (((_v) >> 8) & 0xff)
                                                                        // PCS to SCK Delay
#define LPSPI_CCR_PCSSCK(_n)                     (((uint32_t)(_n) & 0xff) << 16)
#define LPSPI_CCR_PCSSCK_INSERT(_v, _n)              (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define LPSPI_CCR_PCSSCK_EXTRACT(_v)                 (((_v) >> 16) & 0xff)
                                                                        // SCK to PCS Delay
#define LPSPI_CCR_SCKPCS(_n)                     (((uint32_t)(_n) & 0xff) << 24)
#define LPSPI_CCR_SCKPCS_INSERT(_v, _n)              (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define LPSPI_CCR_SCKPCS_EXTRACT(_v)                 (((_v) >> 24) & 0xff)

    uint8_t _res3[20];
    uint32_t             FCR;                                           // FIFO Control Register
                                                                        // Transmit FIFO Watermark
#define LPSPI_FCR_TXWATER(_n)                    (((uint32_t)(_n) & 0x3) << 0)
#define LPSPI_FCR_TXWATER_INSERT(_v, _n)             (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define LPSPI_FCR_TXWATER_EXTRACT(_v)                (((_v) >> 0) & 0x3)
                                                                        // Receive FIFO Watermark
#define LPSPI_FCR_RXWATER(_n)                    (((uint32_t)(_n) & 0x3) << 16)
#define LPSPI_FCR_RXWATER_INSERT(_v, _n)             (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define LPSPI_FCR_RXWATER_EXTRACT(_v)                (((_v) >> 16) & 0x3)

    const uint32_t       FSR;                                           // FIFO Status Register
                                                                        // Transmit FIFO Count
#define LPSPI_FSR_TXCOUNT_EXTRACT(_v)                (((_v) >> 0) & 0x7)
                                                                        // Receive FIFO Count
#define LPSPI_FSR_RXCOUNT_EXTRACT(_v)                (((_v) >> 16) & 0x7)

    uint32_t             TCR;                                           // Transmit Command Register
                                                                        // Frame Size
#define LPSPI_TCR_FRAMESZ(_n)                    (((uint32_t)(_n) & 0xfff) << 0)
#define LPSPI_TCR_FRAMESZ_INSERT(_v, _n)             (((_v) & ~0xfff) | ((uint32_t)(_n) & 0xfff) << 0)
#define LPSPI_TCR_FRAMESZ_EXTRACT(_v)                (((_v) >> 0) & 0xfff)
                                                                        // Transfer Width
#define LPSPI_TCR_WIDTH(_n)                      (((uint32_t)(_n) & 0x3) << 16)
#define LPSPI_TCR_WIDTH_INSERT(_v, _n)               (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define LPSPI_TCR_WIDTH_EXTRACT(_v)                  (((_v) >> 16) & 0x3)
#define   LPSPI_TCR_WIDTH_00                     (uint32_t)0x0          // Single bit transfer.
#define   LPSPI_TCR_WIDTH_01                     (uint32_t)0x1          // Two bit transfer.
#define   LPSPI_TCR_WIDTH_10                     (uint32_t)0x2          // Four bit transfer.
#define LPSPI_TCR_TXMSK                          ((uint32_t)1 << 18)    // Transmit Data Mask
#define   LPSPI_TCR_TXMSK_0                      (uint32_t)0x0          // Normal transfer.
#define   LPSPI_TCR_TXMSK_1                      (uint32_t)0x1          // Mask transmit data.
#define LPSPI_TCR_RXMSK                          ((uint32_t)1 << 19)    // Receive Data Mask
#define   LPSPI_TCR_RXMSK_0                      (uint32_t)0x0          // Normal transfer.
#define   LPSPI_TCR_RXMSK_1                      (uint32_t)0x1          // Receive data is masked.
#define LPSPI_TCR_CONTC                          ((uint32_t)1 << 20)    // Continuing Command
#define   LPSPI_TCR_CONTC_0                      (uint32_t)0x0          // Command word for start of new transfer.
#define   LPSPI_TCR_CONTC_1                      (uint32_t)0x1          // Command word for continuing transfer.
#define LPSPI_TCR_CONT                           ((uint32_t)1 << 21)    // Continuous Transfer
#define   LPSPI_TCR_CONT_0                       (uint32_t)0x0          // Continuous transfer disabled.
#define   LPSPI_TCR_CONT_1                       (uint32_t)0x1          // Continuous transfer enabled.
#define LPSPI_TCR_BYSW                           ((uint32_t)1 << 22)    // Byte Swap
#define   LPSPI_TCR_BYSW_0                       (uint32_t)0x0          // Byte swap disabled.
#define   LPSPI_TCR_BYSW_1                       (uint32_t)0x1          // Byte swap enabled.
#define LPSPI_TCR_LSBF                           ((uint32_t)1 << 23)    // LSB First
#define   LPSPI_TCR_LSBF_0                       (uint32_t)0x0          // Data is transferred MSB first.
#define   LPSPI_TCR_LSBF_1                       (uint32_t)0x1          // Data is transferred LSB first.
                                                                        // Peripheral Chip Select
#define LPSPI_TCR_PCS(_n)                        (((uint32_t)(_n) & 0x3) << 24)
#define LPSPI_TCR_PCS_INSERT(_v, _n)                 (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define LPSPI_TCR_PCS_EXTRACT(_v)                    (((_v) >> 24) & 0x3)
#define   LPSPI_TCR_PCS_00                       (uint32_t)0x0          // Transfer using LPSPI_PCS[0]
#define   LPSPI_TCR_PCS_01                       (uint32_t)0x1          // Transfer using LPSPI_PCS[1]
#define   LPSPI_TCR_PCS_10                       (uint32_t)0x2          // Transfer using LPSPI_PCS[2]
#define   LPSPI_TCR_PCS_11                       (uint32_t)0x3          // Transfer using LPSPI_PCS[3]
                                                                        // Prescaler Value
#define LPSPI_TCR_PRESCALE(_n)                   (((uint32_t)(_n) & 0x7) << 27)
#define LPSPI_TCR_PRESCALE_INSERT(_v, _n)            (((_v) & ~0x38000000) | ((uint32_t)(_n) & 0x7) << 27)
#define LPSPI_TCR_PRESCALE_EXTRACT(_v)               (((_v) >> 27) & 0x7)
#define   LPSPI_TCR_PRESCALE_000                 (uint32_t)0x0          // Divide by 1.
#define   LPSPI_TCR_PRESCALE_001                 (uint32_t)0x1          // Divide by 2.
#define   LPSPI_TCR_PRESCALE_010                 (uint32_t)0x2          // Divide by 4.
#define   LPSPI_TCR_PRESCALE_011                 (uint32_t)0x3          // Divide by 8.
#define   LPSPI_TCR_PRESCALE_100                 (uint32_t)0x4          // Divide by 16.
#define   LPSPI_TCR_PRESCALE_101                 (uint32_t)0x5          // Divide by 32.
#define   LPSPI_TCR_PRESCALE_110                 (uint32_t)0x6          // Divide by 64.
#define   LPSPI_TCR_PRESCALE_111                 (uint32_t)0x7          // Divide by 128.
#define LPSPI_TCR_CPHA                           ((uint32_t)1 << 30)    // Clock Phase
#define   LPSPI_TCR_CPHA_0                       (uint32_t)0x0          // Data is captured on the leading edge of SCK and changed on the following edge.
#define   LPSPI_TCR_CPHA_1                       (uint32_t)0x1          // Data is changed on the leading edge of SCK and captured on the following edge.
#define LPSPI_TCR_CPOL                           ((uint32_t)1 << 31)    // Clock Polarity
#define   LPSPI_TCR_CPOL_0                       (uint32_t)0x0          // The inactive state value of SCK is low.
#define   LPSPI_TCR_CPOL_1                       (uint32_t)0x1          // The inactive state value of SCK is high.

    uint32_t             TDR;                                           // Transmit Data Register
    uint8_t _res4[8];
    const uint32_t       RSR;                                           // Receive Status Register
#define LPSPI_RSR_SOF                            ((uint32_t)1 << 0)     // Start Of Frame
#define   LPSPI_RSR_SOF_0                        (uint32_t)0x0          // Subsequent data word received after LPSPI_PCS assertion.
#define   LPSPI_RSR_SOF_1                        (uint32_t)0x1          // First data word received after LPSPI_PCS assertion.
#define LPSPI_RSR_RXEMPTY                        ((uint32_t)1 << 1)     // RX FIFO Empty
#define   LPSPI_RSR_RXEMPTY_0                    (uint32_t)0x0          // RX FIFO is not empty.
#define   LPSPI_RSR_RXEMPTY_1                    (uint32_t)0x1          // RX FIFO is empty.

    const uint32_t       RDR;                                           // Receive Data Register
} LPSPI_regs_t;
                                                                        // --------------------
                                                                        // Programmable Delay Block
typedef struct                                                          // --------------------
{
    uint32_t             SC;                                            // Status and Control register
#define PDB_SC_LDOK                              ((uint32_t)1 << 0)     // Load OK
#define PDB_SC_CONT                              ((uint32_t)1 << 1)     // Continuous Mode Enable
#define   PDB_SC_CONT_0                          (uint32_t)0x0          // PDB operation in One-Shot mode
#define   PDB_SC_CONT_1                          (uint32_t)0x1          // PDB operation in Continuous mode
                                                                        // Multiplication Factor Select for Prescaler
#define PDB_SC_MULT(_n)                          (((uint32_t)(_n) & 0x3) << 2)
#define PDB_SC_MULT_INSERT(_v, _n)                   (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define PDB_SC_MULT_EXTRACT(_v)                      (((_v) >> 2) & 0x3)
#define   PDB_SC_MULT_00                         (uint32_t)0x0          // Multiplication factor is 1.
#define   PDB_SC_MULT_01                         (uint32_t)0x1          // Multiplication factor is 10.
#define   PDB_SC_MULT_10                         (uint32_t)0x2          // Multiplication factor is 20.
#define   PDB_SC_MULT_11                         (uint32_t)0x3          // Multiplication factor is 40.
#define PDB_SC_PDBIE                             ((uint32_t)1 << 5)     // PDB Interrupt Enable
#define   PDB_SC_PDBIE_0                         (uint32_t)0x0          // PDB interrupt disabled.
#define   PDB_SC_PDBIE_1                         (uint32_t)0x1          // PDB interrupt enabled.
#define PDB_SC_PDBIF                             ((uint32_t)1 << 6)     // PDB Interrupt Flag
#define PDB_SC_PDBEN                             ((uint32_t)1 << 7)     // PDB Enable
#define   PDB_SC_PDBEN_0                         (uint32_t)0x0          // PDB disabled. Counter is off.
#define   PDB_SC_PDBEN_1                         (uint32_t)0x1          // PDB enabled.
                                                                        // Trigger Input Source Select
#define PDB_SC_TRGSEL(_n)                        (((uint32_t)(_n) & 0xf) << 8)
#define PDB_SC_TRGSEL_INSERT(_v, _n)                 (((_v) & ~0xf00) | ((uint32_t)(_n) & 0xf) << 8)
#define PDB_SC_TRGSEL_EXTRACT(_v)                    (((_v) >> 8) & 0xf)
#define   PDB_SC_TRGSEL_0000                     (uint32_t)0x0          // Trigger-In 0 is selected.
#define   PDB_SC_TRGSEL_0001                     (uint32_t)0x1          // Trigger-In 1 is selected.
#define   PDB_SC_TRGSEL_0010                     (uint32_t)0x2          // Trigger-In 2 is selected.
#define   PDB_SC_TRGSEL_0011                     (uint32_t)0x3          // Trigger-In 3 is selected.
#define   PDB_SC_TRGSEL_0100                     (uint32_t)0x4          // Trigger-In 4 is selected.
#define   PDB_SC_TRGSEL_0101                     (uint32_t)0x5          // Trigger-In 5 is selected.
#define   PDB_SC_TRGSEL_0110                     (uint32_t)0x6          // Trigger-In 6 is selected.
#define   PDB_SC_TRGSEL_0111                     (uint32_t)0x7          // Trigger-In 7 is selected.
#define   PDB_SC_TRGSEL_1000                     (uint32_t)0x8          // Trigger-In 8 is selected.
#define   PDB_SC_TRGSEL_1001                     (uint32_t)0x9          // Trigger-In 9 is selected.
#define   PDB_SC_TRGSEL_1010                     (uint32_t)0xa          // Trigger-In 10 is selected.
#define   PDB_SC_TRGSEL_1011                     (uint32_t)0xb          // Trigger-In 11 is selected.
#define   PDB_SC_TRGSEL_1100                     (uint32_t)0xc          // Trigger-In 12 is selected.
#define   PDB_SC_TRGSEL_1101                     (uint32_t)0xd          // Trigger-In 13 is selected.
#define   PDB_SC_TRGSEL_1110                     (uint32_t)0xe          // Trigger-In 14 is selected.
#define   PDB_SC_TRGSEL_1111                     (uint32_t)0xf          // Software trigger is selected.
                                                                        // Prescaler Divider Select
#define PDB_SC_PRESCALER(_n)                     (((uint32_t)(_n) & 0x7) << 12)
#define PDB_SC_PRESCALER_INSERT(_v, _n)              (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define PDB_SC_PRESCALER_EXTRACT(_v)                 (((_v) >> 12) & 0x7)
#define   PDB_SC_PRESCALER_000                   (uint32_t)0x0          // Counting uses the peripheral clock divided by MULT (the multiplication factor).
#define   PDB_SC_PRESCALER_001                   (uint32_t)0x1          // Counting uses the peripheral clock divided by 2 x MULT (the multiplication factor).
#define   PDB_SC_PRESCALER_010                   (uint32_t)0x2          // Counting uses the peripheral clock divided by 4 x MULT (the multiplication factor).
#define   PDB_SC_PRESCALER_011                   (uint32_t)0x3          // Counting uses the peripheral clock divided by 8 x MULT (the multiplication factor).
#define   PDB_SC_PRESCALER_100                   (uint32_t)0x4          // Counting uses the peripheral clock divided by 16 x MULT (the multiplication factor).
#define   PDB_SC_PRESCALER_101                   (uint32_t)0x5          // Counting uses the peripheral clock divided by 32 x MULT (the multiplication factor).
#define   PDB_SC_PRESCALER_110                   (uint32_t)0x6          // Counting uses the peripheral clock divided by 64 x MULT (the multiplication factor).
#define   PDB_SC_PRESCALER_111                   (uint32_t)0x7          // Counting uses the peripheral clock divided by 128 x MULT (the multiplication factor).
#define PDB_SC_DMAEN                             ((uint32_t)1 << 15)    // DMA Enable
#define   PDB_SC_DMAEN_0                         (uint32_t)0x0          // DMA disabled.
#define   PDB_SC_DMAEN_1                         (uint32_t)0x1          // DMA enabled.
#define PDB_SC_SWTRIG                            ((uint32_t)1 << 16)    // Software Trigger
#define PDB_SC_PDBEIE                            ((uint32_t)1 << 17)    // PDB Sequence Error Interrupt Enable
#define   PDB_SC_PDBEIE_0                        (uint32_t)0x0          // PDB sequence error interrupt disabled.
#define   PDB_SC_PDBEIE_1                        (uint32_t)0x1          // PDB sequence error interrupt enabled.
                                                                        // Load Mode Select
#define PDB_SC_LDMOD(_n)                         (((uint32_t)(_n) & 0x3) << 18)
#define PDB_SC_LDMOD_INSERT(_v, _n)                  (((_v) & ~0xc0000) | ((uint32_t)(_n) & 0x3) << 18)
#define PDB_SC_LDMOD_EXTRACT(_v)                     (((_v) >> 18) & 0x3)
#define   PDB_SC_LDMOD_00                        (uint32_t)0x0          // The internal registers are loaded with the values from their buffers, immediately after 1 is written to LDOK.
#define   PDB_SC_LDMOD_01                        (uint32_t)0x1          // The internal registers are loaded with the values from their buffers when the PDB counter (CNT) = MOD + 1 CNT delay elapsed, after 1 is written to LDOK.
#define   PDB_SC_LDMOD_10                        (uint32_t)0x2          // The internal registers are loaded with the values from their buffers when a trigger input event is detected, after 1 is written to LDOK.
#define   PDB_SC_LDMOD_11                        (uint32_t)0x3          // The internal registers are loaded with the values from their buffers when either the PDB counter (CNT) = MOD + 1 CNT delay elapsed, or a trigger input event is detected, after 1 is written to LDOK.

    uint32_t             MOD;                                           // Modulus register
                                                                        // PDB Modulus
#define PDB_MOD_MOD(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_MOD_MOD_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_MOD_MOD_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    const uint32_t       CNT;                                           // Counter register
                                                                        // PDB Counter
#define PDB_CNT_CNT_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             IDLY;                                          // Interrupt Delay register
                                                                        // PDB Interrupt Delay
#define PDB_IDLY_IDLY(_n)                        (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_IDLY_IDLY_INSERT(_v, _n)                 (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_IDLY_IDLY_EXTRACT(_v)                    (((_v) >> 0) & 0xffff)

    uint32_t             CH0C1;                                         // Channel n Control register 1
                                                                        // PDB Channel Pre-Trigger Enable
#define PDB_CH0C1_EN(_n)                         (((uint32_t)(_n) & 0xff) << 0)
#define PDB_CH0C1_EN_INSERT(_v, _n)                  (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define PDB_CH0C1_EN_EXTRACT(_v)                     (((_v) >> 0) & 0xff)
#define   PDB_CH0C1_EN_0                         (uint32_t)0x0          // PDB channel's corresponding pre-trigger disabled.
#define   PDB_CH0C1_EN_1                         (uint32_t)0x1          // PDB channel's corresponding pre-trigger enabled.
                                                                        // PDB Channel Pre-Trigger Output Select
#define PDB_CH0C1_TOS(_n)                        (((uint32_t)(_n) & 0xff) << 8)
#define PDB_CH0C1_TOS_INSERT(_v, _n)                 (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define PDB_CH0C1_TOS_EXTRACT(_v)                    (((_v) >> 8) & 0xff)
#define   PDB_CH0C1_TOS_0                        (uint32_t)0x0          // PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
#define   PDB_CH0C1_TOS_1                        (uint32_t)0x1          // PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
                                                                        // PDB Channel Pre-Trigger Back-to-Back Operation Enable
#define PDB_CH0C1_BB(_n)                         (((uint32_t)(_n) & 0xff) << 16)
#define PDB_CH0C1_BB_INSERT(_v, _n)                  (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define PDB_CH0C1_BB_EXTRACT(_v)                     (((_v) >> 16) & 0xff)
#define   PDB_CH0C1_BB_0                         (uint32_t)0x0          // PDB channel's corresponding pre-trigger back-to-back operation disabled.
#define   PDB_CH0C1_BB_1                         (uint32_t)0x1          // PDB channel's corresponding pre-trigger back-to-back operation enabled.

    uint32_t             CH0S;                                          // Channel n Status register
                                                                        // PDB Channel Sequence Error Flags
#define PDB_CH0S_ERR(_n)                         (((uint32_t)(_n) & 0xff) << 0)
#define PDB_CH0S_ERR_INSERT(_v, _n)                  (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define PDB_CH0S_ERR_EXTRACT(_v)                     (((_v) >> 0) & 0xff)
#define   PDB_CH0S_ERR_0                         (uint32_t)0x0          // Sequence error not detected on PDB channel's corresponding pre-trigger.
#define   PDB_CH0S_ERR_1                         (uint32_t)0x1          // Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
                                                                        // PDB Channel Flags
#define PDB_CH0S_CF(_n)                          (((uint32_t)(_n) & 0xff) << 16)
#define PDB_CH0S_CF_INSERT(_v, _n)                   (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define PDB_CH0S_CF_EXTRACT(_v)                      (((_v) >> 16) & 0xff)

    uint32_t             CH0DLY0;                                       // Channel n Delay 0 register
                                                                        // PDB Channel Delay
#define PDB_CH0DLY0_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY0_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY0_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH0DLY1;                                       // Channel n Delay 1 register
                                                                        // PDB Channel Delay
#define PDB_CH0DLY1_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY1_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY1_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH0DLY2;                                       // Channel n Delay 2 register
                                                                        // PDB Channel Delay
#define PDB_CH0DLY2_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY2_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY2_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH0DLY3;                                       // Channel n Delay 3 register
                                                                        // PDB Channel Delay
#define PDB_CH0DLY3_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY3_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY3_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH0DLY4;                                       // Channel n Delay 4 register
                                                                        // PDB Channel Delay
#define PDB_CH0DLY4_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY4_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY4_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH0DLY5;                                       // Channel n Delay 5 register
                                                                        // PDB Channel Delay
#define PDB_CH0DLY5_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY5_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY5_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH0DLY6;                                       // Channel n Delay 6 register
                                                                        // PDB Channel Delay
#define PDB_CH0DLY6_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY6_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY6_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH0DLY7;                                       // Channel n Delay 7 register
                                                                        // PDB Channel Delay
#define PDB_CH0DLY7_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY7_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH0DLY7_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH1C1;                                         // Channel n Control register 1
                                                                        // PDB Channel Pre-Trigger Enable
#define PDB_CH1C1_EN(_n)                         (((uint32_t)(_n) & 0xff) << 0)
#define PDB_CH1C1_EN_INSERT(_v, _n)                  (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define PDB_CH1C1_EN_EXTRACT(_v)                     (((_v) >> 0) & 0xff)
#define   PDB_CH1C1_EN_0                         (uint32_t)0x0          // PDB channel's corresponding pre-trigger disabled.
#define   PDB_CH1C1_EN_1                         (uint32_t)0x1          // PDB channel's corresponding pre-trigger enabled.
                                                                        // PDB Channel Pre-Trigger Output Select
#define PDB_CH1C1_TOS(_n)                        (((uint32_t)(_n) & 0xff) << 8)
#define PDB_CH1C1_TOS_INSERT(_v, _n)                 (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define PDB_CH1C1_TOS_EXTRACT(_v)                    (((_v) >> 8) & 0xff)
#define   PDB_CH1C1_TOS_0                        (uint32_t)0x0          // PDB channel's corresponding pre-trigger is in bypassed mode. The pre-trigger asserts one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
#define   PDB_CH1C1_TOS_1                        (uint32_t)0x1          // PDB channel's corresponding pre-trigger asserts when the counter reaches the channel delay register and one peripheral clock cycle after a rising edge is detected on selected trigger input source or software trigger is selected and SWTRIG is written with 1.
                                                                        // PDB Channel Pre-Trigger Back-to-Back Operation Enable
#define PDB_CH1C1_BB(_n)                         (((uint32_t)(_n) & 0xff) << 16)
#define PDB_CH1C1_BB_INSERT(_v, _n)                  (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define PDB_CH1C1_BB_EXTRACT(_v)                     (((_v) >> 16) & 0xff)
#define   PDB_CH1C1_BB_0                         (uint32_t)0x0          // PDB channel's corresponding pre-trigger back-to-back operation disabled.
#define   PDB_CH1C1_BB_1                         (uint32_t)0x1          // PDB channel's corresponding pre-trigger back-to-back operation enabled.

    uint32_t             CH1S;                                          // Channel n Status register
                                                                        // PDB Channel Sequence Error Flags
#define PDB_CH1S_ERR(_n)                         (((uint32_t)(_n) & 0xff) << 0)
#define PDB_CH1S_ERR_INSERT(_v, _n)                  (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define PDB_CH1S_ERR_EXTRACT(_v)                     (((_v) >> 0) & 0xff)
#define   PDB_CH1S_ERR_0                         (uint32_t)0x0          // Sequence error not detected on PDB channel's corresponding pre-trigger.
#define   PDB_CH1S_ERR_1                         (uint32_t)0x1          // Sequence error detected on PDB channel's corresponding pre-trigger. ADCn block can be triggered for a conversion by one pre-trigger from PDB channel n. When one conversion, which is triggered by one of the pre-triggers from PDB channel n, is in progress, new trigger from PDB channel's corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set. Writing 0's to clear the sequence error flags.
                                                                        // PDB Channel Flags
#define PDB_CH1S_CF(_n)                          (((uint32_t)(_n) & 0xff) << 16)
#define PDB_CH1S_CF_INSERT(_v, _n)                   (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define PDB_CH1S_CF_EXTRACT(_v)                      (((_v) >> 16) & 0xff)

    uint32_t             CH1DLY0;                                       // Channel n Delay 0 register
                                                                        // PDB Channel Delay
#define PDB_CH1DLY0_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY0_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY0_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH1DLY1;                                       // Channel n Delay 1 register
                                                                        // PDB Channel Delay
#define PDB_CH1DLY1_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY1_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY1_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH1DLY2;                                       // Channel n Delay 2 register
                                                                        // PDB Channel Delay
#define PDB_CH1DLY2_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY2_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY2_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH1DLY3;                                       // Channel n Delay 3 register
                                                                        // PDB Channel Delay
#define PDB_CH1DLY3_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY3_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY3_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH1DLY4;                                       // Channel n Delay 4 register
                                                                        // PDB Channel Delay
#define PDB_CH1DLY4_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY4_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY4_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH1DLY5;                                       // Channel n Delay 5 register
                                                                        // PDB Channel Delay
#define PDB_CH1DLY5_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY5_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY5_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH1DLY6;                                       // Channel n Delay 6 register
                                                                        // PDB Channel Delay
#define PDB_CH1DLY6_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY6_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY6_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint32_t             CH1DLY7;                                       // Channel n Delay 7 register
                                                                        // PDB Channel Delay
#define PDB_CH1DLY7_DLY(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY7_DLY_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_CH1DLY7_DLY_EXTRACT(_v)                  (((_v) >> 0) & 0xffff)

    uint8_t _res0[304];
    uint32_t             POEN;                                          // Pulse-Out n Enable register
                                                                        // PDB Pulse-Out Enable
#define PDB_POEN_POEN(_n)                        (((uint32_t)(_n) & 0xff) << 0)
#define PDB_POEN_POEN_INSERT(_v, _n)                 (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define PDB_POEN_POEN_EXTRACT(_v)                    (((_v) >> 0) & 0xff)
#define   PDB_POEN_POEN_0                        (uint32_t)0x0          // PDB Pulse-Out disabled
#define   PDB_POEN_POEN_1                        (uint32_t)0x1          // PDB Pulse-Out enabled

    uint32_t             PODLY;                                         // Pulse-Out n Delay register
                                                                        // PDB Pulse-Out Delay 2
#define PDB_PODLY_DLY2(_n)                       (((uint32_t)(_n) & 0xffff) << 0)
#define PDB_PODLY_DLY2_INSERT(_v, _n)                (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define PDB_PODLY_DLY2_EXTRACT(_v)                   (((_v) >> 0) & 0xffff)
                                                                        // PDB Pulse-Out Delay 1
#define PDB_PODLY_DLY1(_n)                       (((uint32_t)(_n) & 0xffff) << 16)
#define PDB_PODLY_DLY1_INSERT(_v, _n)                (((_v) & ~0xffff0000) | ((uint32_t)(_n) & 0xffff) << 16)
#define PDB_PODLY_DLY1_EXTRACT(_v)                   (((_v) >> 16) & 0xffff)

    uint16_t             DLY2;                                          // PDB0_DLY2 register.
    uint16_t             DLY1;                                          // PDB0_DLY1 register.
} PDB_regs_t;
                                                                        // --------------------
                                                                        // Cyclic Redundancy Check
typedef struct                                                          // --------------------
{
    uint32_t             DATA;                                          // CRC Data register
                                                                        // CRC Low Lower Byte
#define CRC_DATA_LL(_n)                          (((uint32_t)(_n) & 0xff) << 0)
#define CRC_DATA_LL_INSERT(_v, _n)                   (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CRC_DATA_LL_EXTRACT(_v)                      (((_v) >> 0) & 0xff)
                                                                        // CRC Low Upper Byte
#define CRC_DATA_LU(_n)                          (((uint32_t)(_n) & 0xff) << 8)
#define CRC_DATA_LU_INSERT(_v, _n)                   (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define CRC_DATA_LU_EXTRACT(_v)                      (((_v) >> 8) & 0xff)
                                                                        // CRC High Lower Byte
#define CRC_DATA_HL(_n)                          (((uint32_t)(_n) & 0xff) << 16)
#define CRC_DATA_HL_INSERT(_v, _n)                   (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CRC_DATA_HL_EXTRACT(_v)                      (((_v) >> 16) & 0xff)
                                                                        // CRC High Upper Byte
#define CRC_DATA_HU(_n)                          (((uint32_t)(_n) & 0xff) << 24)
#define CRC_DATA_HU_INSERT(_v, _n)                   (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define CRC_DATA_HU_EXTRACT(_v)                      (((_v) >> 24) & 0xff)

    uint16_t             DATAL;                                         // CRC_DATAL register.
    uint8_t              DATALL;                                        // CRC_DATALL register.
    uint8_t              DATALU;                                        // CRC_DATALU register.
    uint16_t             DATAH;                                         // CRC_DATAH register.
    uint8_t              DATAHL;                                        // CRC_DATAHL register.
    uint8_t              DATAHU;                                        // CRC_DATAHU register.
    uint32_t             GPOLY;                                         // CRC Polynomial register
                                                                        // Low Polynominal Half-word
#define CRC_GPOLY_LOW(_n)                        (((uint32_t)(_n) & 0xffff) << 0)
#define CRC_GPOLY_LOW_INSERT(_v, _n)                 (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define CRC_GPOLY_LOW_EXTRACT(_v)                    (((_v) >> 0) & 0xffff)
                                                                        // High Polynominal Half-word
#define CRC_GPOLY_HIGH(_n)                       (((uint32_t)(_n) & 0xffff) << 16)
#define CRC_GPOLY_HIGH_INSERT(_v, _n)                (((_v) & ~0xffff0000) | ((uint32_t)(_n) & 0xffff) << 16)
#define CRC_GPOLY_HIGH_EXTRACT(_v)                   (((_v) >> 16) & 0xffff)

    uint32_t             CTRL;                                          // CRC Control register
#define CRC_CTRL_TCRC                            ((uint32_t)1 << 24)    // TCRC
#define   CRC_CTRL_TCRC_0                        (uint32_t)0x0          // 16-bit CRC protocol.
#define   CRC_CTRL_TCRC_1                        (uint32_t)0x1          // 32-bit CRC protocol.
#define CRC_CTRL_WAS                             ((uint32_t)1 << 25)    // Write CRC Data Register As Seed
#define   CRC_CTRL_WAS_0                         (uint32_t)0x0          // Writes to the CRC data register are data values.
#define   CRC_CTRL_WAS_1                         (uint32_t)0x1          // Writes to the CRC data register are seed values.
#define CRC_CTRL_FXOR                            ((uint32_t)1 << 26)    // Complement Read Of CRC Data Register
#define   CRC_CTRL_FXOR_0                        (uint32_t)0x0          // No XOR on reading.
#define   CRC_CTRL_FXOR_1                        (uint32_t)0x1          // Invert or complement the read value of the CRC Data register.
                                                                        // Type Of Transpose For Read
#define CRC_CTRL_TOTR(_n)                        (((uint32_t)(_n) & 0x3) << 28)
#define CRC_CTRL_TOTR_INSERT(_v, _n)                 (((_v) & ~0x30000000) | ((uint32_t)(_n) & 0x3) << 28)
#define CRC_CTRL_TOTR_EXTRACT(_v)                    (((_v) >> 28) & 0x3)
#define   CRC_CTRL_TOTR_00                       (uint32_t)0x0          // No transposition.
#define   CRC_CTRL_TOTR_01                       (uint32_t)0x1          // Bits in bytes are transposed; bytes are not transposed.
#define   CRC_CTRL_TOTR_10                       (uint32_t)0x2          // Both bits in bytes and bytes are transposed.
#define   CRC_CTRL_TOTR_11                       (uint32_t)0x3          // Only bytes are transposed; no bits in a byte are transposed.
                                                                        // Type Of Transpose For Writes
#define CRC_CTRL_TOT(_n)                         (((uint32_t)(_n) & 0x3) << 30)
#define CRC_CTRL_TOT_INSERT(_v, _n)                  (((_v) & ~0xc0000000) | ((uint32_t)(_n) & 0x3) << 30)
#define CRC_CTRL_TOT_EXTRACT(_v)                     (((_v) >> 30) & 0x3)
#define   CRC_CTRL_TOT_00                        (uint32_t)0x0          // No transposition.
#define   CRC_CTRL_TOT_01                        (uint32_t)0x1          // Bits in bytes are transposed; bytes are not transposed.
#define   CRC_CTRL_TOT_10                        (uint32_t)0x2          // Both bits in bytes and bytes are transposed.
#define   CRC_CTRL_TOT_11                        (uint32_t)0x3          // Only bytes are transposed; no bits in a byte are transposed.

} CRC_regs_t;
                                                                        // --------------------
                                                                        // Low Power Periodic Interrupt Timer (LPIT)
typedef struct                                                          // --------------------
{
    const uint32_t       VERID;                                         // Version ID Register
                                                                        // Feature Number
#define LPIT0_VERID_FEATURE_EXTRACT(_v)              (((_v) >> 0) & 0xffff)
                                                                        // Minor Version Number
#define LPIT0_VERID_MINOR_EXTRACT(_v)                (((_v) >> 16) & 0xff)
                                                                        // Major Version Number
#define LPIT0_VERID_MAJOR_EXTRACT(_v)                (((_v) >> 24) & 0xff)

    const uint32_t       PARAM;                                         // Parameter Register
                                                                        // Number of Timer Channels
#define LPIT0_PARAM_CHANNEL_EXTRACT(_v)              (((_v) >> 0) & 0xff)
                                                                        // Number of External Trigger Inputs
#define LPIT0_PARAM_EXT_TRIG_EXTRACT(_v)             (((_v) >> 8) & 0xff)

    uint32_t             MCR;                                           // Module Control Register
#define LPIT0_MCR_M_CEN                          ((uint32_t)1 << 0)     // Module Clock Enable
#define   LPIT0_MCR_M_CEN_0                      (uint32_t)0x0          // Peripheral clock to timers is disabled
#define   LPIT0_MCR_M_CEN_1                      (uint32_t)0x1          // Peripheral clock to timers is enabled
#define LPIT0_MCR_SW_RST                         ((uint32_t)1 << 1)     // Software Reset Bit
#define   LPIT0_MCR_SW_RST_0                     (uint32_t)0x0          // Timer channels and registers are not reset
#define   LPIT0_MCR_SW_RST_1                     (uint32_t)0x1          // Timer channels and registers are reset
#define LPIT0_MCR_DOZE_EN                        ((uint32_t)1 << 2)     // DOZE Mode Enable Bit
#define   LPIT0_MCR_DOZE_EN_0                    (uint32_t)0x0          // Timer channels are stopped in DOZE mode
#define   LPIT0_MCR_DOZE_EN_1                    (uint32_t)0x1          // Timer channels continue to run in DOZE mode
#define LPIT0_MCR_DBG_EN                         ((uint32_t)1 << 3)     // Debug Enable Bit
#define   LPIT0_MCR_DBG_EN_0                     (uint32_t)0x0          // Timer channels are stopped in Debug mode
#define   LPIT0_MCR_DBG_EN_1                     (uint32_t)0x1          // Timer channels continue to run in Debug mode

    uint32_t             MSR;                                           // Module Status Register
#define LPIT0_MSR_TIF0                           ((uint32_t)1 << 0)     // Channel 0 Timer Interrupt Flag
#define   LPIT0_MSR_TIF0_0                       (uint32_t)0x0          // Timer has not timed out
#define   LPIT0_MSR_TIF0_1                       (uint32_t)0x1          // Timeout has occurred
#define LPIT0_MSR_TIF1                           ((uint32_t)1 << 1)     // Channel 1 Timer Interrupt Flag
#define   LPIT0_MSR_TIF1_0                       (uint32_t)0x0          // Timer has not timed out
#define   LPIT0_MSR_TIF1_1                       (uint32_t)0x1          // Timeout has occurred
#define LPIT0_MSR_TIF2                           ((uint32_t)1 << 2)     // Channel 2 Timer Interrupt Flag
#define   LPIT0_MSR_TIF2_0                       (uint32_t)0x0          // Timer has not timed out
#define   LPIT0_MSR_TIF2_1                       (uint32_t)0x1          // Timeout has occurred
#define LPIT0_MSR_TIF3                           ((uint32_t)1 << 3)     // Channel 3 Timer Interrupt Flag
#define   LPIT0_MSR_TIF3_0                       (uint32_t)0x0          // Timer has not timed out
#define   LPIT0_MSR_TIF3_1                       (uint32_t)0x1          // Timeout has occurred

    uint32_t             MIER;                                          // Module Interrupt Enable Register
#define LPIT0_MIER_TIE0                          ((uint32_t)1 << 0)     // Channel 0 Timer Interrupt Enable
#define   LPIT0_MIER_TIE0_0                      (uint32_t)0x0          // Interrupt generation is disabled
#define   LPIT0_MIER_TIE0_1                      (uint32_t)0x1          // Interrupt generation is enabled
#define LPIT0_MIER_TIE1                          ((uint32_t)1 << 1)     // Channel 1 Timer Interrupt Enable
#define   LPIT0_MIER_TIE1_0                      (uint32_t)0x0          // Interrupt generation is disabled
#define   LPIT0_MIER_TIE1_1                      (uint32_t)0x1          // Interrupt generation is enabled
#define LPIT0_MIER_TIE2                          ((uint32_t)1 << 2)     // Channel 2 Timer Interrupt Enable
#define   LPIT0_MIER_TIE2_0                      (uint32_t)0x0          // Interrupt generation is disabled
#define   LPIT0_MIER_TIE2_1                      (uint32_t)0x1          // Interrupt generation is enabled
#define LPIT0_MIER_TIE3                          ((uint32_t)1 << 3)     // Channel 3 Timer Interrupt Enable
#define   LPIT0_MIER_TIE3_0                      (uint32_t)0x0          // Interrupt generation is disabled
#define   LPIT0_MIER_TIE3_1                      (uint32_t)0x1          // Interrupt generation is enabled

    uint32_t             SETTEN;                                        // Set Timer Enable Register
#define LPIT0_SETTEN_SET_T_EN_0                  ((uint32_t)1 << 0)     // Set Timer 0 Enable
#define   LPIT0_SETTEN_SET_T_EN_0_0              (uint32_t)0x0          // No effect
#define   LPIT0_SETTEN_SET_T_EN_0_1              (uint32_t)0x1          // Enables the Timer Channel 0
#define LPIT0_SETTEN_SET_T_EN_1                  ((uint32_t)1 << 1)     // Set Timer 1 Enable
#define   LPIT0_SETTEN_SET_T_EN_1_0              (uint32_t)0x0          // No Effect
#define   LPIT0_SETTEN_SET_T_EN_1_1              (uint32_t)0x1          // Enables the Timer Channel 1
#define LPIT0_SETTEN_SET_T_EN_2                  ((uint32_t)1 << 2)     // Set Timer 2 Enable
#define   LPIT0_SETTEN_SET_T_EN_2_0              (uint32_t)0x0          // No Effect
#define   LPIT0_SETTEN_SET_T_EN_2_1              (uint32_t)0x1          // Enables the Timer Channel 2
#define LPIT0_SETTEN_SET_T_EN_3                  ((uint32_t)1 << 3)     // Set Timer 3 Enable
#define   LPIT0_SETTEN_SET_T_EN_3_0              (uint32_t)0x0          // No effect
#define   LPIT0_SETTEN_SET_T_EN_3_1              (uint32_t)0x1          // Enables the Timer Channel 3

    uint32_t             CLRTEN;                                        // Clear Timer Enable Register
#define LPIT0_CLRTEN_CLR_T_EN_0                  ((uint32_t)1 << 0)     // Clear Timer 0 Enable
#define   LPIT0_CLRTEN_CLR_T_EN_0_0              (uint32_t)0x0          // No action
#define   LPIT0_CLRTEN_CLR_T_EN_0_1              (uint32_t)0x1          // Clear T_EN bit for Timer Channel 0
#define LPIT0_CLRTEN_CLR_T_EN_1                  ((uint32_t)1 << 1)     // Clear Timer 1 Enable
#define   LPIT0_CLRTEN_CLR_T_EN_1_0              (uint32_t)0x0          // No Action
#define   LPIT0_CLRTEN_CLR_T_EN_1_1              (uint32_t)0x1          // Clear T_EN bit for Timer Channel 1
#define LPIT0_CLRTEN_CLR_T_EN_2                  ((uint32_t)1 << 2)     // Clear Timer 2 Enable
#define   LPIT0_CLRTEN_CLR_T_EN_2_0              (uint32_t)0x0          // No Action
#define   LPIT0_CLRTEN_CLR_T_EN_2_1              (uint32_t)0x1          // Clear T_EN bit for Timer Channel 2
#define LPIT0_CLRTEN_CLR_T_EN_3                  ((uint32_t)1 << 3)     // Clear Timer 3 Enable
#define   LPIT0_CLRTEN_CLR_T_EN_3_0              (uint32_t)0x0          // No Action
#define   LPIT0_CLRTEN_CLR_T_EN_3_1              (uint32_t)0x1          // Clear T_EN bit for Timer Channel 3

    uint8_t _res0[4];
    uint32_t             TVAL0;                                         // Timer Value Register
    const uint32_t       CVAL0;                                         // Current Timer Value
    uint32_t             TCTRL0;                                        // Timer Control Register
#define LPIT0_TCTRL0_T_EN                        ((uint32_t)1 << 0)     // Timer Enable
#define   LPIT0_TCTRL0_T_EN_0                    (uint32_t)0x0          // Timer Channel is disabled
#define   LPIT0_TCTRL0_T_EN_1                    (uint32_t)0x1          // Timer Channel is enabled
#define LPIT0_TCTRL0_CHAIN                       ((uint32_t)1 << 1)     // Chain Channel
#define   LPIT0_TCTRL0_CHAIN_0                   (uint32_t)0x0          // Channel Chaining is disabled. Channel Timer runs independently.
#define   LPIT0_TCTRL0_CHAIN_1                   (uint32_t)0x1          // Channel Chaining is enabled. Timer decrements on previous channel's timeout
                                                                        // Timer Operation Mode
#define LPIT0_TCTRL0_MODE(_n)                    (((uint32_t)(_n) & 0x3) << 2)
#define LPIT0_TCTRL0_MODE_INSERT(_v, _n)             (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define LPIT0_TCTRL0_MODE_EXTRACT(_v)                (((_v) >> 2) & 0x3)
#define   LPIT0_TCTRL0_MODE_0                    (uint32_t)0x0          // 32-bit Periodic Counter
#define   LPIT0_TCTRL0_MODE_1                    (uint32_t)0x1          // Dual 16-bit Periodic Counter
#define   LPIT0_TCTRL0_MODE_10                   (uint32_t)0x2          // 32-bit Trigger Accumulator
#define   LPIT0_TCTRL0_MODE_11                   (uint32_t)0x3          // 32-bit Trigger Input Capture
#define LPIT0_TCTRL0_TSOT                        ((uint32_t)1 << 16)    // Timer Start On Trigger
#define   LPIT0_TCTRL0_TSOT_0                    (uint32_t)0x0          // Timer starts to decrement immediately based on restart condition (controlled by TSOI bit)
#define   LPIT0_TCTRL0_TSOT_1                    (uint32_t)0x1          // Timer starts to decrement when rising edge on selected trigger is detected
#define LPIT0_TCTRL0_TSOI                        ((uint32_t)1 << 17)    // Timer Stop On Interrupt
#define   LPIT0_TCTRL0_TSOI_0                    (uint32_t)0x0          // The channel timer does not stop after timeout.
#define   LPIT0_TCTRL0_TSOI_1                    (uint32_t)0x1          // The channel timer will stop after a timeout, and the channel timer will restart based on TSOT. When TSOT = 0, the channel timer will restart after a rising edge on the T_EN bit is detected (which means that the timer channel is disabled and then enabled); when TSOT = 1, the channel timer will restart after a rising edge on the selected trigger is detected.
#define LPIT0_TCTRL0_TROT                        ((uint32_t)1 << 18)    // Timer Reload On Trigger
#define   LPIT0_TCTRL0_TROT_0                    (uint32_t)0x0          // Timer will not reload on selected trigger
#define   LPIT0_TCTRL0_TROT_1                    (uint32_t)0x1          // Timer will reload on selected trigger
#define LPIT0_TCTRL0_TRG_SRC                     ((uint32_t)1 << 23)    // Trigger Source
#define   LPIT0_TCTRL0_TRG_SRC_0                 (uint32_t)0x0          // Trigger source selected in external
#define   LPIT0_TCTRL0_TRG_SRC_1                 (uint32_t)0x1          // Trigger source selected is the internal trigger
                                                                        // Trigger Select
#define LPIT0_TCTRL0_TRG_SEL(_n)                 (((uint32_t)(_n) & 0xf) << 24)
#define LPIT0_TCTRL0_TRG_SEL_INSERT(_v, _n)          (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define LPIT0_TCTRL0_TRG_SEL_EXTRACT(_v)             (((_v) >> 24) & 0xf)

    uint8_t _res1[4];
    uint32_t             TVAL1;                                         // Timer Value Register
    const uint32_t       CVAL1;                                         // Current Timer Value
    uint32_t             TCTRL1;                                        // Timer Control Register
#define LPIT0_TCTRL1_T_EN                        ((uint32_t)1 << 0)     // Timer Enable
#define   LPIT0_TCTRL1_T_EN_0                    (uint32_t)0x0          // Timer Channel is disabled
#define   LPIT0_TCTRL1_T_EN_1                    (uint32_t)0x1          // Timer Channel is enabled
#define LPIT0_TCTRL1_CHAIN                       ((uint32_t)1 << 1)     // Chain Channel
#define   LPIT0_TCTRL1_CHAIN_0                   (uint32_t)0x0          // Channel Chaining is disabled. Channel Timer runs independently.
#define   LPIT0_TCTRL1_CHAIN_1                   (uint32_t)0x1          // Channel Chaining is enabled. Timer decrements on previous channel's timeout
                                                                        // Timer Operation Mode
#define LPIT0_TCTRL1_MODE(_n)                    (((uint32_t)(_n) & 0x3) << 2)
#define LPIT0_TCTRL1_MODE_INSERT(_v, _n)             (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define LPIT0_TCTRL1_MODE_EXTRACT(_v)                (((_v) >> 2) & 0x3)
#define   LPIT0_TCTRL1_MODE_0                    (uint32_t)0x0          // 32-bit Periodic Counter
#define   LPIT0_TCTRL1_MODE_1                    (uint32_t)0x1          // Dual 16-bit Periodic Counter
#define   LPIT0_TCTRL1_MODE_10                   (uint32_t)0x2          // 32-bit Trigger Accumulator
#define   LPIT0_TCTRL1_MODE_11                   (uint32_t)0x3          // 32-bit Trigger Input Capture
#define LPIT0_TCTRL1_TSOT                        ((uint32_t)1 << 16)    // Timer Start On Trigger
#define   LPIT0_TCTRL1_TSOT_0                    (uint32_t)0x0          // Timer starts to decrement immediately based on restart condition (controlled by TSOI bit)
#define   LPIT0_TCTRL1_TSOT_1                    (uint32_t)0x1          // Timer starts to decrement when rising edge on selected trigger is detected
#define LPIT0_TCTRL1_TSOI                        ((uint32_t)1 << 17)    // Timer Stop On Interrupt
#define   LPIT0_TCTRL1_TSOI_0                    (uint32_t)0x0          // The channel timer does not stop after timeout.
#define   LPIT0_TCTRL1_TSOI_1                    (uint32_t)0x1          // The channel timer will stop after a timeout, and the channel timer will restart based on TSOT. When TSOT = 0, the channel timer will restart after a rising edge on the T_EN bit is detected (which means that the timer channel is disabled and then enabled); when TSOT = 1, the channel timer will restart after a rising edge on the selected trigger is detected.
#define LPIT0_TCTRL1_TROT                        ((uint32_t)1 << 18)    // Timer Reload On Trigger
#define   LPIT0_TCTRL1_TROT_0                    (uint32_t)0x0          // Timer will not reload on selected trigger
#define   LPIT0_TCTRL1_TROT_1                    (uint32_t)0x1          // Timer will reload on selected trigger
#define LPIT0_TCTRL1_TRG_SRC                     ((uint32_t)1 << 23)    // Trigger Source
#define   LPIT0_TCTRL1_TRG_SRC_0                 (uint32_t)0x0          // Trigger source selected in external
#define   LPIT0_TCTRL1_TRG_SRC_1                 (uint32_t)0x1          // Trigger source selected is the internal trigger
                                                                        // Trigger Select
#define LPIT0_TCTRL1_TRG_SEL(_n)                 (((uint32_t)(_n) & 0xf) << 24)
#define LPIT0_TCTRL1_TRG_SEL_INSERT(_v, _n)          (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define LPIT0_TCTRL1_TRG_SEL_EXTRACT(_v)             (((_v) >> 24) & 0xf)

    uint8_t _res2[4];
    uint32_t             TVAL2;                                         // Timer Value Register
    const uint32_t       CVAL2;                                         // Current Timer Value
    uint32_t             TCTRL2;                                        // Timer Control Register
#define LPIT0_TCTRL2_T_EN                        ((uint32_t)1 << 0)     // Timer Enable
#define   LPIT0_TCTRL2_T_EN_0                    (uint32_t)0x0          // Timer Channel is disabled
#define   LPIT0_TCTRL2_T_EN_1                    (uint32_t)0x1          // Timer Channel is enabled
#define LPIT0_TCTRL2_CHAIN                       ((uint32_t)1 << 1)     // Chain Channel
#define   LPIT0_TCTRL2_CHAIN_0                   (uint32_t)0x0          // Channel Chaining is disabled. Channel Timer runs independently.
#define   LPIT0_TCTRL2_CHAIN_1                   (uint32_t)0x1          // Channel Chaining is enabled. Timer decrements on previous channel's timeout
                                                                        // Timer Operation Mode
#define LPIT0_TCTRL2_MODE(_n)                    (((uint32_t)(_n) & 0x3) << 2)
#define LPIT0_TCTRL2_MODE_INSERT(_v, _n)             (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define LPIT0_TCTRL2_MODE_EXTRACT(_v)                (((_v) >> 2) & 0x3)
#define   LPIT0_TCTRL2_MODE_0                    (uint32_t)0x0          // 32-bit Periodic Counter
#define   LPIT0_TCTRL2_MODE_1                    (uint32_t)0x1          // Dual 16-bit Periodic Counter
#define   LPIT0_TCTRL2_MODE_10                   (uint32_t)0x2          // 32-bit Trigger Accumulator
#define   LPIT0_TCTRL2_MODE_11                   (uint32_t)0x3          // 32-bit Trigger Input Capture
#define LPIT0_TCTRL2_TSOT                        ((uint32_t)1 << 16)    // Timer Start On Trigger
#define   LPIT0_TCTRL2_TSOT_0                    (uint32_t)0x0          // Timer starts to decrement immediately based on restart condition (controlled by TSOI bit)
#define   LPIT0_TCTRL2_TSOT_1                    (uint32_t)0x1          // Timer starts to decrement when rising edge on selected trigger is detected
#define LPIT0_TCTRL2_TSOI                        ((uint32_t)1 << 17)    // Timer Stop On Interrupt
#define   LPIT0_TCTRL2_TSOI_0                    (uint32_t)0x0          // The channel timer does not stop after timeout.
#define   LPIT0_TCTRL2_TSOI_1                    (uint32_t)0x1          // The channel timer will stop after a timeout, and the channel timer will restart based on TSOT. When TSOT = 0, the channel timer will restart after a rising edge on the T_EN bit is detected (which means that the timer channel is disabled and then enabled); when TSOT = 1, the channel timer will restart after a rising edge on the selected trigger is detected.
#define LPIT0_TCTRL2_TROT                        ((uint32_t)1 << 18)    // Timer Reload On Trigger
#define   LPIT0_TCTRL2_TROT_0                    (uint32_t)0x0          // Timer will not reload on selected trigger
#define   LPIT0_TCTRL2_TROT_1                    (uint32_t)0x1          // Timer will reload on selected trigger
#define LPIT0_TCTRL2_TRG_SRC                     ((uint32_t)1 << 23)    // Trigger Source
#define   LPIT0_TCTRL2_TRG_SRC_0                 (uint32_t)0x0          // Trigger source selected in external
#define   LPIT0_TCTRL2_TRG_SRC_1                 (uint32_t)0x1          // Trigger source selected is the internal trigger
                                                                        // Trigger Select
#define LPIT0_TCTRL2_TRG_SEL(_n)                 (((uint32_t)(_n) & 0xf) << 24)
#define LPIT0_TCTRL2_TRG_SEL_INSERT(_v, _n)          (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define LPIT0_TCTRL2_TRG_SEL_EXTRACT(_v)             (((_v) >> 24) & 0xf)

    uint8_t _res3[4];
    uint32_t             TVAL3;                                         // Timer Value Register
    const uint32_t       CVAL3;                                         // Current Timer Value
    uint32_t             TCTRL3;                                        // Timer Control Register
#define LPIT0_TCTRL3_T_EN                        ((uint32_t)1 << 0)     // Timer Enable
#define   LPIT0_TCTRL3_T_EN_0                    (uint32_t)0x0          // Timer Channel is disabled
#define   LPIT0_TCTRL3_T_EN_1                    (uint32_t)0x1          // Timer Channel is enabled
#define LPIT0_TCTRL3_CHAIN                       ((uint32_t)1 << 1)     // Chain Channel
#define   LPIT0_TCTRL3_CHAIN_0                   (uint32_t)0x0          // Channel Chaining is disabled. Channel Timer runs independently.
#define   LPIT0_TCTRL3_CHAIN_1                   (uint32_t)0x1          // Channel Chaining is enabled. Timer decrements on previous channel's timeout
                                                                        // Timer Operation Mode
#define LPIT0_TCTRL3_MODE(_n)                    (((uint32_t)(_n) & 0x3) << 2)
#define LPIT0_TCTRL3_MODE_INSERT(_v, _n)             (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define LPIT0_TCTRL3_MODE_EXTRACT(_v)                (((_v) >> 2) & 0x3)
#define   LPIT0_TCTRL3_MODE_0                    (uint32_t)0x0          // 32-bit Periodic Counter
#define   LPIT0_TCTRL3_MODE_1                    (uint32_t)0x1          // Dual 16-bit Periodic Counter
#define   LPIT0_TCTRL3_MODE_10                   (uint32_t)0x2          // 32-bit Trigger Accumulator
#define   LPIT0_TCTRL3_MODE_11                   (uint32_t)0x3          // 32-bit Trigger Input Capture
#define LPIT0_TCTRL3_TSOT                        ((uint32_t)1 << 16)    // Timer Start On Trigger
#define   LPIT0_TCTRL3_TSOT_0                    (uint32_t)0x0          // Timer starts to decrement immediately based on restart condition (controlled by TSOI bit)
#define   LPIT0_TCTRL3_TSOT_1                    (uint32_t)0x1          // Timer starts to decrement when rising edge on selected trigger is detected
#define LPIT0_TCTRL3_TSOI                        ((uint32_t)1 << 17)    // Timer Stop On Interrupt
#define   LPIT0_TCTRL3_TSOI_0                    (uint32_t)0x0          // The channel timer does not stop after timeout.
#define   LPIT0_TCTRL3_TSOI_1                    (uint32_t)0x1          // The channel timer will stop after a timeout, and the channel timer will restart based on TSOT. When TSOT = 0, the channel timer will restart after a rising edge on the T_EN bit is detected (which means that the timer channel is disabled and then enabled); when TSOT = 1, the channel timer will restart after a rising edge on the selected trigger is detected.
#define LPIT0_TCTRL3_TROT                        ((uint32_t)1 << 18)    // Timer Reload On Trigger
#define   LPIT0_TCTRL3_TROT_0                    (uint32_t)0x0          // Timer will not reload on selected trigger
#define   LPIT0_TCTRL3_TROT_1                    (uint32_t)0x1          // Timer will reload on selected trigger
#define LPIT0_TCTRL3_TRG_SRC                     ((uint32_t)1 << 23)    // Trigger Source
#define   LPIT0_TCTRL3_TRG_SRC_0                 (uint32_t)0x0          // Trigger source selected in external
#define   LPIT0_TCTRL3_TRG_SRC_1                 (uint32_t)0x1          // Trigger source selected is the internal trigger
                                                                        // Trigger Select
#define LPIT0_TCTRL3_TRG_SEL(_n)                 (((uint32_t)(_n) & 0xf) << 24)
#define LPIT0_TCTRL3_TRG_SEL_INSERT(_v, _n)          (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define LPIT0_TCTRL3_TRG_SEL_EXTRACT(_v)             (((_v) >> 24) & 0xf)

} LPIT0_regs_t;
                                                                        // --------------------
                                                                        // Secure Real Time Clock
typedef struct                                                          // --------------------
{
    uint32_t             TSR;                                           // RTC Time Seconds Register
    uint32_t             TPR;                                           // RTC Time Prescaler Register
                                                                        // Time Prescaler Register
#define RTC_TPR_TPR(_n)                          (((uint32_t)(_n) & 0xffff) << 0)
#define RTC_TPR_TPR_INSERT(_v, _n)                   (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define RTC_TPR_TPR_EXTRACT(_v)                      (((_v) >> 0) & 0xffff)

    uint32_t             TAR;                                           // RTC Time Alarm Register
    uint32_t             TCR;                                           // RTC Time Compensation Register
                                                                        // Time Compensation Register
#define RTC_TCR_TCR(_n)                          (((uint32_t)(_n) & 0xff) << 0)
#define RTC_TCR_TCR_INSERT(_v, _n)                   (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define RTC_TCR_TCR_EXTRACT(_v)                      (((_v) >> 0) & 0xff)
#define   RTC_TCR_TCR_10000000                   (uint32_t)0x80         // Time Prescaler Register overflows every 32896 clock cycles.
#define   RTC_TCR_TCR_10000001                   (uint32_t)0x81         // Time Prescaler Register overflows every 32895 clock cycles.
#define   RTC_TCR_TCR_11111111                   (uint32_t)0xff         // Time Prescaler Register overflows every 32769 clock cycles.
#define   RTC_TCR_TCR_00000000                   (uint32_t)0x0          // Time Prescaler Register overflows every 32768 clock cycles.
#define   RTC_TCR_TCR_00000001                   (uint32_t)0x1          // Time Prescaler Register overflows every 32767 clock cycles.
#define   RTC_TCR_TCR_01111110                   (uint32_t)0x7e         // Time Prescaler Register overflows every 32642 clock cycles.
#define   RTC_TCR_TCR_01111111                   (uint32_t)0x7f         // Time Prescaler Register overflows every 32641 clock cycles.
                                                                        // Compensation Interval Register
#define RTC_TCR_CIR(_n)                          (((uint32_t)(_n) & 0xff) << 8)
#define RTC_TCR_CIR_INSERT(_v, _n)                   (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define RTC_TCR_CIR_EXTRACT(_v)                      (((_v) >> 8) & 0xff)
                                                                        // Time Compensation Value
#define RTC_TCR_TCV(_n)                          (((uint32_t)(_n) & 0xff) << 16)
#define RTC_TCR_TCV_INSERT(_v, _n)                   (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define RTC_TCR_TCV_EXTRACT(_v)                      (((_v) >> 16) & 0xff)
                                                                        // Compensation Interval Counter
#define RTC_TCR_CIC(_n)                          (((uint32_t)(_n) & 0xff) << 24)
#define RTC_TCR_CIC_INSERT(_v, _n)                   (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define RTC_TCR_CIC_EXTRACT(_v)                      (((_v) >> 24) & 0xff)

    uint32_t             CR;                                            // RTC Control Register
#define RTC_CR_SWR                               ((uint32_t)1 << 0)     // Software Reset
#define   RTC_CR_SWR_0                           (uint32_t)0x0          // No effect.
#define RTC_CR_SUP                               ((uint32_t)1 << 2)     // Supervisor Access
#define   RTC_CR_SUP_0                           (uint32_t)0x0          // Non-supervisor mode write accesses are not supported and generate a bus error.
#define   RTC_CR_SUP_1                           (uint32_t)0x1          // Non-supervisor mode write accesses are supported.
#define RTC_CR_UM                                ((uint32_t)1 << 3)     // Update Mode
#define   RTC_CR_UM_0                            (uint32_t)0x0          // Registers cannot be written when locked.
#define   RTC_CR_UM_1                            (uint32_t)0x1          // Registers can be written when locked under limited conditions.
#define RTC_CR_CPS                               ((uint32_t)1 << 5)     // Clock Pin Select
#define   RTC_CR_CPS_0                           (uint32_t)0x0          // The prescaler output clock (as configured by TSIC) is output on RTC_CLKOUT.
#define   RTC_CR_CPS_1                           (uint32_t)0x1          // The RTC 32.768 kHz clock is output on RTC_CLKOUT, provided it is output to other peripherals.
#define RTC_CR_LPOS                              ((uint32_t)1 << 7)     // LPO Select
#define   RTC_CR_LPOS_0                          (uint32_t)0x0          // RTC prescaler increments using 32.768 kHz clock.
#define   RTC_CR_LPOS_1                          (uint32_t)0x1          // RTC prescaler increments using 1 kHz LPO, bits [4:0] of the prescaler are ignored.
#define RTC_CR_CLKO                              ((uint32_t)1 << 9)     // Clock Output
#define   RTC_CR_CLKO_0                          (uint32_t)0x0          // The 32 kHz clock is output to other peripherals.
#define   RTC_CR_CLKO_1                          (uint32_t)0x1          // The 32 kHz clock is not output to other peripherals.
#define RTC_CR_CPE                               ((uint32_t)1 << 24)    // Clock Pin Enable
#define   RTC_CR_CPE_0                           (uint32_t)0x0          // The RTC_CLKOUT function is disabled.
#define   RTC_CR_CPE_1                           (uint32_t)0x1          // Enable RTC_CLKOUT function.

    uint32_t             SR;                                            // RTC Status Register
#define RTC_SR_TIF                               ((uint32_t)1 << 0)     // Time Invalid Flag
#define   RTC_SR_TIF_0                           (uint32_t)0x0          // Time is valid.
#define   RTC_SR_TIF_1                           (uint32_t)0x1          // Time is invalid and time counter is read as zero.
#define RTC_SR_TOF                               ((uint32_t)1 << 1)     // Time Overflow Flag
#define   RTC_SR_TOF_0                           (uint32_t)0x0          // Time overflow has not occurred.
#define   RTC_SR_TOF_1                           (uint32_t)0x1          // Time overflow has occurred and time counter is read as zero.
#define RTC_SR_TAF                               ((uint32_t)1 << 2)     // Time Alarm Flag
#define   RTC_SR_TAF_0                           (uint32_t)0x0          // Time alarm has not occurred.
#define   RTC_SR_TAF_1                           (uint32_t)0x1          // Time alarm has occurred.
#define RTC_SR_TCE                               ((uint32_t)1 << 4)     // Time Counter Enable
#define   RTC_SR_TCE_0                           (uint32_t)0x0          // Time counter is disabled.
#define   RTC_SR_TCE_1                           (uint32_t)0x1          // Time counter is enabled.

    uint32_t             LR;                                            // RTC Lock Register
#define RTC_LR_TCL                               ((uint32_t)1 << 3)     // Time Compensation Lock
#define   RTC_LR_TCL_0                           (uint32_t)0x0          // Time Compensation Register is locked and writes are ignored.
#define   RTC_LR_TCL_1                           (uint32_t)0x1          // Time Compensation Register is not locked and writes complete as normal.
#define RTC_LR_CRL                               ((uint32_t)1 << 4)     // Control Register Lock
#define   RTC_LR_CRL_0                           (uint32_t)0x0          // Control Register is locked and writes are ignored.
#define   RTC_LR_CRL_1                           (uint32_t)0x1          // Control Register is not locked and writes complete as normal.
#define RTC_LR_SRL                               ((uint32_t)1 << 5)     // Status Register Lock
#define   RTC_LR_SRL_0                           (uint32_t)0x0          // Status Register is locked and writes are ignored.
#define   RTC_LR_SRL_1                           (uint32_t)0x1          // Status Register is not locked and writes complete as normal.
#define RTC_LR_LRL                               ((uint32_t)1 << 6)     // Lock Register Lock
#define   RTC_LR_LRL_0                           (uint32_t)0x0          // Lock Register is locked and writes are ignored.
#define   RTC_LR_LRL_1                           (uint32_t)0x1          // Lock Register is not locked and writes complete as normal.

    uint32_t             IER;                                           // RTC Interrupt Enable Register
#define RTC_IER_TIIE                             ((uint32_t)1 << 0)     // Time Invalid Interrupt Enable
#define   RTC_IER_TIIE_0                         (uint32_t)0x0          // Time invalid flag does not generate an interrupt.
#define   RTC_IER_TIIE_1                         (uint32_t)0x1          // Time invalid flag does generate an interrupt.
#define RTC_IER_TOIE                             ((uint32_t)1 << 1)     // Time Overflow Interrupt Enable
#define   RTC_IER_TOIE_0                         (uint32_t)0x0          // Time overflow flag does not generate an interrupt.
#define   RTC_IER_TOIE_1                         (uint32_t)0x1          // Time overflow flag does generate an interrupt.
#define RTC_IER_TAIE                             ((uint32_t)1 << 2)     // Time Alarm Interrupt Enable
#define   RTC_IER_TAIE_0                         (uint32_t)0x0          // Time alarm flag does not generate an interrupt.
#define   RTC_IER_TAIE_1                         (uint32_t)0x1          // Time alarm flag does generate an interrupt.
#define RTC_IER_TSIE                             ((uint32_t)1 << 4)     // Time Seconds Interrupt Enable
#define   RTC_IER_TSIE_0                         (uint32_t)0x0          // Seconds interrupt is disabled.
#define   RTC_IER_TSIE_1                         (uint32_t)0x1          // Seconds interrupt is enabled.
                                                                        // Timer Seconds Interrupt Configuration
#define RTC_IER_TSIC(_n)                         (((uint32_t)(_n) & 0x7) << 16)
#define RTC_IER_TSIC_INSERT(_v, _n)                  (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define RTC_IER_TSIC_EXTRACT(_v)                     (((_v) >> 16) & 0x7)
#define   RTC_IER_TSIC_000                       (uint32_t)0x0          // 1 Hz.
#define   RTC_IER_TSIC_001                       (uint32_t)0x1          // 2 Hz.
#define   RTC_IER_TSIC_010                       (uint32_t)0x2          // 4 Hz.
#define   RTC_IER_TSIC_011                       (uint32_t)0x3          // 8 Hz.
#define   RTC_IER_TSIC_100                       (uint32_t)0x4          // 16 Hz.
#define   RTC_IER_TSIC_101                       (uint32_t)0x5          // 32 Hz.
#define   RTC_IER_TSIC_110                       (uint32_t)0x6          // 64 Hz.
#define   RTC_IER_TSIC_111                       (uint32_t)0x7          // 128 Hz.

} RTC_regs_t;
                                                                        // --------------------
                                                                        // Low Power Timer
typedef struct                                                          // --------------------
{
    uint32_t             CSR;                                           // Low Power Timer Control Status Register
#define LPTMR0_CSR_TEN                           ((uint32_t)1 << 0)     // Timer Enable
#define   LPTMR0_CSR_TEN_0                       (uint32_t)0x0          // LPTMR is disabled and internal logic is reset.
#define   LPTMR0_CSR_TEN_1                       (uint32_t)0x1          // LPTMR is enabled.
#define LPTMR0_CSR_TMS                           ((uint32_t)1 << 1)     // Timer Mode Select
#define   LPTMR0_CSR_TMS_0                       (uint32_t)0x0          // Time Counter mode.
#define   LPTMR0_CSR_TMS_1                       (uint32_t)0x1          // Pulse Counter mode.
#define LPTMR0_CSR_TFC                           ((uint32_t)1 << 2)     // Timer Free-Running Counter
#define   LPTMR0_CSR_TFC_0                       (uint32_t)0x0          // CNR is reset whenever TCF is set.
#define   LPTMR0_CSR_TFC_1                       (uint32_t)0x1          // CNR is reset on overflow.
#define LPTMR0_CSR_TPP                           ((uint32_t)1 << 3)     // Timer Pin Polarity
#define   LPTMR0_CSR_TPP_0                       (uint32_t)0x0          // Pulse Counter input source is active-high, and the CNR will increment on the rising-edge.
#define   LPTMR0_CSR_TPP_1                       (uint32_t)0x1          // Pulse Counter input source is active-low, and the CNR will increment on the falling-edge.
                                                                        // Timer Pin Select
#define LPTMR0_CSR_TPS(_n)                       (((uint32_t)(_n) & 0x3) << 4)
#define LPTMR0_CSR_TPS_INSERT(_v, _n)                (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define LPTMR0_CSR_TPS_EXTRACT(_v)                   (((_v) >> 4) & 0x3)
#define   LPTMR0_CSR_TPS_00                      (uint32_t)0x0          // Pulse counter input 0 is selected.
#define   LPTMR0_CSR_TPS_01                      (uint32_t)0x1          // Pulse counter input 1 is selected.
#define   LPTMR0_CSR_TPS_10                      (uint32_t)0x2          // Pulse counter input 2 is selected.
#define   LPTMR0_CSR_TPS_11                      (uint32_t)0x3          // Pulse counter input 3 is selected.
#define LPTMR0_CSR_TIE                           ((uint32_t)1 << 6)     // Timer Interrupt Enable
#define   LPTMR0_CSR_TIE_0                       (uint32_t)0x0          // Timer interrupt disabled.
#define   LPTMR0_CSR_TIE_1                       (uint32_t)0x1          // Timer interrupt enabled.
#define LPTMR0_CSR_TCF                           ((uint32_t)1 << 7)     // Timer Compare Flag
#define   LPTMR0_CSR_TCF_0                       (uint32_t)0x0          // The value of CNR is not equal to CMR and increments.
#define   LPTMR0_CSR_TCF_1                       (uint32_t)0x1          // The value of CNR is equal to CMR and increments.
#define LPTMR0_CSR_TDRE                          ((uint32_t)1 << 8)     // Timer DMA Request Enable
#define   LPTMR0_CSR_TDRE_0                      (uint32_t)0x0          // Timer DMA Request disabled.
#define   LPTMR0_CSR_TDRE_1                      (uint32_t)0x1          // Timer DMA Request enabled.

    uint32_t             PSR;                                           // Low Power Timer Prescale Register
                                                                        // Prescaler Clock Select
#define LPTMR0_PSR_PCS(_n)                       (((uint32_t)(_n) & 0x3) << 0)
#define LPTMR0_PSR_PCS_INSERT(_v, _n)                (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define LPTMR0_PSR_PCS_EXTRACT(_v)                   (((_v) >> 0) & 0x3)
#define   LPTMR0_PSR_PCS_00                      (uint32_t)0x0          // Prescaler/glitch filter clock 0 selected.
#define   LPTMR0_PSR_PCS_01                      (uint32_t)0x1          // Prescaler/glitch filter clock 1 selected.
#define   LPTMR0_PSR_PCS_10                      (uint32_t)0x2          // Prescaler/glitch filter clock 2 selected.
#define   LPTMR0_PSR_PCS_11                      (uint32_t)0x3          // Prescaler/glitch filter clock 3 selected.
#define LPTMR0_PSR_PBYP                          ((uint32_t)1 << 2)     // Prescaler Bypass
#define   LPTMR0_PSR_PBYP_0                      (uint32_t)0x0          // Prescaler/glitch filter is enabled.
#define   LPTMR0_PSR_PBYP_1                      (uint32_t)0x1          // Prescaler/glitch filter is bypassed.
                                                                        // Prescale Value
#define LPTMR0_PSR_PRESCALE(_n)                  (((uint32_t)(_n) & 0xf) << 3)
#define LPTMR0_PSR_PRESCALE_INSERT(_v, _n)           (((_v) & ~0x78) | ((uint32_t)(_n) & 0xf) << 3)
#define LPTMR0_PSR_PRESCALE_EXTRACT(_v)              (((_v) >> 3) & 0xf)
#define   LPTMR0_PSR_PRESCALE_0000               (uint32_t)0x0          // Prescaler divides the prescaler clock by 2; glitch filter does not support this configuration.
#define   LPTMR0_PSR_PRESCALE_0001               (uint32_t)0x1          // Prescaler divides the prescaler clock by 4; glitch filter recognizes change on input pin after 2 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_0010               (uint32_t)0x2          // Prescaler divides the prescaler clock by 8; glitch filter recognizes change on input pin after 4 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_0011               (uint32_t)0x3          // Prescaler divides the prescaler clock by 16; glitch filter recognizes change on input pin after 8 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_0100               (uint32_t)0x4          // Prescaler divides the prescaler clock by 32; glitch filter recognizes change on input pin after 16 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_0101               (uint32_t)0x5          // Prescaler divides the prescaler clock by 64; glitch filter recognizes change on input pin after 32 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_0110               (uint32_t)0x6          // Prescaler divides the prescaler clock by 128; glitch filter recognizes change on input pin after 64 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_0111               (uint32_t)0x7          // Prescaler divides the prescaler clock by 256; glitch filter recognizes change on input pin after 128 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_1000               (uint32_t)0x8          // Prescaler divides the prescaler clock by 512; glitch filter recognizes change on input pin after 256 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_1001               (uint32_t)0x9          // Prescaler divides the prescaler clock by 1024; glitch filter recognizes change on input pin after 512 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_1010               (uint32_t)0xa          // Prescaler divides the prescaler clock by 2048; glitch filter recognizes change on input pin after 1024 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_1011               (uint32_t)0xb          // Prescaler divides the prescaler clock by 4096; glitch filter recognizes change on input pin after 2048 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_1100               (uint32_t)0xc          // Prescaler divides the prescaler clock by 8192; glitch filter recognizes change on input pin after 4096 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_1101               (uint32_t)0xd          // Prescaler divides the prescaler clock by 16,384; glitch filter recognizes change on input pin after 8192 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_1110               (uint32_t)0xe          // Prescaler divides the prescaler clock by 32,768; glitch filter recognizes change on input pin after 16,384 rising clock edges.
#define   LPTMR0_PSR_PRESCALE_1111               (uint32_t)0xf          // Prescaler divides the prescaler clock by 65,536; glitch filter recognizes change on input pin after 32,768 rising clock edges.

    uint32_t             CMR;                                           // Low Power Timer Compare Register
                                                                        // Compare Value
#define LPTMR0_CMR_COMPARE(_n)                   (((uint32_t)(_n) & 0xffff) << 0)
#define LPTMR0_CMR_COMPARE_INSERT(_v, _n)            (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define LPTMR0_CMR_COMPARE_EXTRACT(_v)               (((_v) >> 0) & 0xffff)

    uint32_t             CNR;                                           // Low Power Timer Counter Register
                                                                        // Counter Value
#define LPTMR0_CNR_COUNTER(_n)                   (((uint32_t)(_n) & 0xffff) << 0)
#define LPTMR0_CNR_COUNTER_INSERT(_v, _n)            (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define LPTMR0_CNR_COUNTER_EXTRACT(_v)               (((_v) >> 0) & 0xffff)

} LPTMR0_regs_t;
                                                                        // --------------------
                                                                        // System Integration Module
typedef struct                                                          // --------------------
{
    uint8_t _res0[4];
    uint32_t             CHIPCTL;                                       // Chip Control register
                                                                        // ADC interleave channel enable
#define SIM_CHIPCTL_ADC_INTERLEAVE_EN(_n)        (((uint32_t)(_n) & 0xf) << 0)
#define SIM_CHIPCTL_ADC_INTERLEAVE_EN_INSERT(_v, _n) (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define SIM_CHIPCTL_ADC_INTERLEAVE_EN_EXTRACT(_v)    (((_v) >> 0) & 0xf)
#define   SIM_CHIPCTL_ADC_INTERLEAVE_EN_0000     (uint32_t)0x0          // Interleaving disabled. No channel pair interleaved. Interleaved channels are individually connected to pins. PTC0 is connected to ADC0_SE8. PTC1 is connected to ADC0_SE9. PTB15 is connected to ADC1_SE14. PTB16 is connected to ADC1_SE15. PTB0 is connected to ADC0_SE4. PTB1 is connected to ADC0_SE5. PTB13 is connected to ADC1_SE8. PTB14 is connected to ADC1_SE9.
#define   SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx     (uint32_t)0x8          // PTB14 to ADC1_SE9 and ADC0_SE9
#define   SIM_CHIPCTL_ADC_INTERLEAVE_EN_x1xx     (uint32_t)0x4          // PTB13 to ADC1_SE8 and ADC0_SE8
#define   SIM_CHIPCTL_ADC_INTERLEAVE_EN_xx1x     (uint32_t)0x2          // PTB1 to ADC0_SE5 and ADC1_SE15
#define   SIM_CHIPCTL_ADC_INTERLEAVE_EN_xxx1     (uint32_t)0x1          // PTB0 to ADC0_SE4 and ADC1_SE14
                                                                        // CLKOUT Select
#define SIM_CHIPCTL_CLKOUTSEL(_n)                (((uint32_t)(_n) & 0xf) << 4)
#define SIM_CHIPCTL_CLKOUTSEL_INSERT(_v, _n)         (((_v) & ~0xf0) | ((uint32_t)(_n) & 0xf) << 4)
#define SIM_CHIPCTL_CLKOUTSEL_EXTRACT(_v)            (((_v) >> 4) & 0xf)
#define   SIM_CHIPCTL_CLKOUTSEL_0000             (uint32_t)0x0          // SCG CLKOUT
#define   SIM_CHIPCTL_CLKOUTSEL_0010             (uint32_t)0x2          // SOSC DIV2 CLK
#define   SIM_CHIPCTL_CLKOUTSEL_0100             (uint32_t)0x4          // SIRC DIV2 CLK
#define   SIM_CHIPCTL_CLKOUTSEL_0101             (uint32_t)0x5          // For S32K148: QSPI SFIF_CLK_HYP: Divide by 2 clock (configured through SCLKCONFIG[5]) for HyperRAM going to sfif clock to QSPI; For others: Reserved
#define   SIM_CHIPCTL_CLKOUTSEL_0110             (uint32_t)0x6          // FIRC DIV2 CLK
#define   SIM_CHIPCTL_CLKOUTSEL_0111             (uint32_t)0x7          // HCLK
#define   SIM_CHIPCTL_CLKOUTSEL_1000             (uint32_t)0x8          // SPLL DIV2 CLK
#define   SIM_CHIPCTL_CLKOUTSEL_1001             (uint32_t)0x9          // BUS_CLK
#define   SIM_CHIPCTL_CLKOUTSEL_1010             (uint32_t)0xa          // LPO128K_CLK
#define   SIM_CHIPCTL_CLKOUTSEL_1011             (uint32_t)0xb          // For S32K148: QSPI IPG_CLK; For others: Reserved
#define   SIM_CHIPCTL_CLKOUTSEL_1100             (uint32_t)0xc          // LPO_CLK as selected by SIM_LPOCLKS[LPOCLKSEL]
#define   SIM_CHIPCTL_CLKOUTSEL_1101             (uint32_t)0xd          // For S32K148: QSPI IPG_CLK_SFIF; For others: Reserved
#define   SIM_CHIPCTL_CLKOUTSEL_1110             (uint32_t)0xe          // RTC_CLK as selected by SIM_LPOCLKS[RTCCLKSEL]
#define   SIM_CHIPCTL_CLKOUTSEL_1111             (uint32_t)0xf          // For S32K148: QSPI IPG_CLK_2XSFIF; For others: Reserved
                                                                        // CLKOUT Divide Ratio
#define SIM_CHIPCTL_CLKOUTDIV(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define SIM_CHIPCTL_CLKOUTDIV_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define SIM_CHIPCTL_CLKOUTDIV_EXTRACT(_v)            (((_v) >> 8) & 0x7)
#define   SIM_CHIPCTL_CLKOUTDIV_000              (uint32_t)0x0          // Divide by 1
#define   SIM_CHIPCTL_CLKOUTDIV_001              (uint32_t)0x1          // Divide by 2
#define   SIM_CHIPCTL_CLKOUTDIV_010              (uint32_t)0x2          // Divide by 3
#define   SIM_CHIPCTL_CLKOUTDIV_011              (uint32_t)0x3          // Divide by 4
#define   SIM_CHIPCTL_CLKOUTDIV_100              (uint32_t)0x4          // Divide by 5
#define   SIM_CHIPCTL_CLKOUTDIV_101              (uint32_t)0x5          // Divide by 6
#define   SIM_CHIPCTL_CLKOUTDIV_110              (uint32_t)0x6          // Divide by 7
#define   SIM_CHIPCTL_CLKOUTDIV_111              (uint32_t)0x7          // Divide by 8
#define SIM_CHIPCTL_CLKOUTEN                     ((uint32_t)1 << 11)    // CLKOUT enable
#define   SIM_CHIPCTL_CLKOUTEN_0                 (uint32_t)0x0          // Clockout disable
#define   SIM_CHIPCTL_CLKOUTEN_1                 (uint32_t)0x1          // Clockout enable
#define SIM_CHIPCTL_TRACECLK_SEL                 ((uint32_t)1 << 12)    // Debug trace clock select
#define   SIM_CHIPCTL_TRACECLK_SEL_0             (uint32_t)0x0          // Core clock
#define   SIM_CHIPCTL_TRACECLK_SEL_1             (uint32_t)0x1          // Platform clock
#define SIM_CHIPCTL_PDB_BB_SEL                   ((uint32_t)1 << 13)    // PDB back-to-back select
#define   SIM_CHIPCTL_PDB_BB_SEL_0               (uint32_t)0x0          // PDB0 channel 0 back-to-back operation with ADC0 COCO[7:0] and PDB1 channel 0 back-to-back operation with ADC1 COCO[7:0]
#define   SIM_CHIPCTL_PDB_BB_SEL_1               (uint32_t)0x1          // Channel 0 of PDB0 and PDB1 back-to-back operation with COCO[7:0] of ADC0 and ADC1.
                                                                        // ADC_SUPPLY
#define SIM_CHIPCTL_ADC_SUPPLY(_n)               (((uint32_t)(_n) & 0x7) << 16)
#define SIM_CHIPCTL_ADC_SUPPLY_INSERT(_v, _n)        (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define SIM_CHIPCTL_ADC_SUPPLY_EXTRACT(_v)           (((_v) >> 16) & 0x7)
#define   SIM_CHIPCTL_ADC_SUPPLY_000             (uint32_t)0x0          // 5 V input VDD supply (VDD)
#define   SIM_CHIPCTL_ADC_SUPPLY_001             (uint32_t)0x1          // 5 V input analog supply (VDDA)
#define   SIM_CHIPCTL_ADC_SUPPLY_010             (uint32_t)0x2          // ADC Reference Supply (VREFH)
#define   SIM_CHIPCTL_ADC_SUPPLY_011             (uint32_t)0x3          // 3.3 V Oscillator Regulator Output (VDD_3V)
#define   SIM_CHIPCTL_ADC_SUPPLY_100             (uint32_t)0x4          // 3.3 V flash regulator output (VDD_flash_3V)
#define   SIM_CHIPCTL_ADC_SUPPLY_101             (uint32_t)0x5          // 1.2 V core regulator output (VDD_LV)
#define SIM_CHIPCTL_ADC_SUPPLYEN                 ((uint32_t)1 << 19)    // ADC_SUPPLYEN
#define   SIM_CHIPCTL_ADC_SUPPLYEN_0             (uint32_t)0x0          // Disable internal supply monitoring
#define   SIM_CHIPCTL_ADC_SUPPLYEN_1             (uint32_t)0x1          // Enable internal supply monitoring
#define SIM_CHIPCTL_SRAMU_RETEN                  ((uint32_t)1 << 20)    // SRAMU_RETEN
#define   SIM_CHIPCTL_SRAMU_RETEN_0              (uint32_t)0x0          // SRAMU contents are retained across resets
#define   SIM_CHIPCTL_SRAMU_RETEN_1              (uint32_t)0x1          // No SRAMU retention
#define SIM_CHIPCTL_SRAML_RETEN                  ((uint32_t)1 << 21)    // SRAML_RETEN
#define   SIM_CHIPCTL_SRAML_RETEN_0              (uint32_t)0x0          // SRAML contents are retained across resets
#define   SIM_CHIPCTL_SRAML_RETEN_1              (uint32_t)0x1          // No SRAML retention

    uint8_t _res1[4];
    uint32_t             FTMOPT0;                                       // FTM Option Register 0
                                                                        // FTM0 Fault X Select
#define SIM_FTMOPT0_FTM0FLTxSEL(_n)              (((uint32_t)(_n) & 0x7) << 0)
#define SIM_FTMOPT0_FTM0FLTxSEL_INSERT(_v, _n)       (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define SIM_FTMOPT0_FTM0FLTxSEL_EXTRACT(_v)          (((_v) >> 0) & 0x7)
#define   SIM_FTMOPT0_FTM0FLTxSEL_000            (uint32_t)0x0          // FTM0_FLTx pin
#define   SIM_FTMOPT0_FTM0FLTxSEL_001            (uint32_t)0x1          // TRGMUX_FTM0 out
                                                                        // FTM1 Fault X Select
#define SIM_FTMOPT0_FTM1FLTxSEL(_n)              (((uint32_t)(_n) & 0x7) << 4)
#define SIM_FTMOPT0_FTM1FLTxSEL_INSERT(_v, _n)       (((_v) & ~0x70) | ((uint32_t)(_n) & 0x7) << 4)
#define SIM_FTMOPT0_FTM1FLTxSEL_EXTRACT(_v)          (((_v) >> 4) & 0x7)
#define   SIM_FTMOPT0_FTM1FLTxSEL_000            (uint32_t)0x0          // FTM1_FLTx pin
#define   SIM_FTMOPT0_FTM1FLTxSEL_001            (uint32_t)0x1          // TRGMUX_FTM1 out
                                                                        // FTM2 Fault X Select
#define SIM_FTMOPT0_FTM2FLTxSEL(_n)              (((uint32_t)(_n) & 0x7) << 8)
#define SIM_FTMOPT0_FTM2FLTxSEL_INSERT(_v, _n)       (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define SIM_FTMOPT0_FTM2FLTxSEL_EXTRACT(_v)          (((_v) >> 8) & 0x7)
#define   SIM_FTMOPT0_FTM2FLTxSEL_000            (uint32_t)0x0          // FTM2_FLTx pin
#define   SIM_FTMOPT0_FTM2FLTxSEL_001            (uint32_t)0x1          // TRGMUX_FTM2 out
                                                                        // FTM3 Fault X Select
#define SIM_FTMOPT0_FTM3FLTxSEL(_n)              (((uint32_t)(_n) & 0x7) << 12)
#define SIM_FTMOPT0_FTM3FLTxSEL_INSERT(_v, _n)       (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define SIM_FTMOPT0_FTM3FLTxSEL_EXTRACT(_v)          (((_v) >> 12) & 0x7)
#define   SIM_FTMOPT0_FTM3FLTxSEL_000            (uint32_t)0x0          // FTM3_FLTx pin
#define   SIM_FTMOPT0_FTM3FLTxSEL_001            (uint32_t)0x1          // TRGMUX_FTM3 out
                                                                        // FTM0 External Clock Pin Select
#define SIM_FTMOPT0_FTM0CLKSEL(_n)               (((uint32_t)(_n) & 0x3) << 24)
#define SIM_FTMOPT0_FTM0CLKSEL_INSERT(_v, _n)        (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define SIM_FTMOPT0_FTM0CLKSEL_EXTRACT(_v)           (((_v) >> 24) & 0x3)
#define   SIM_FTMOPT0_FTM0CLKSEL_00              (uint32_t)0x0          // FTM0 external clock driven by TCLK0 pin.
#define   SIM_FTMOPT0_FTM0CLKSEL_01              (uint32_t)0x1          // FTM0 external clock driven by TCLK1 pin.
#define   SIM_FTMOPT0_FTM0CLKSEL_10              (uint32_t)0x2          // FTM0 external clock driven by TCLK2 pin.
#define   SIM_FTMOPT0_FTM0CLKSEL_11              (uint32_t)0x3          // No clock input
                                                                        // FTM1 External Clock Pin Select
#define SIM_FTMOPT0_FTM1CLKSEL(_n)               (((uint32_t)(_n) & 0x3) << 26)
#define SIM_FTMOPT0_FTM1CLKSEL_INSERT(_v, _n)        (((_v) & ~0xc000000) | ((uint32_t)(_n) & 0x3) << 26)
#define SIM_FTMOPT0_FTM1CLKSEL_EXTRACT(_v)           (((_v) >> 26) & 0x3)
#define   SIM_FTMOPT0_FTM1CLKSEL_00              (uint32_t)0x0          // FTM1 external clock driven by TCLK0 pin.
#define   SIM_FTMOPT0_FTM1CLKSEL_01              (uint32_t)0x1          // FTM1 external clock driven by TCLK1 pin.
#define   SIM_FTMOPT0_FTM1CLKSEL_10              (uint32_t)0x2          // FTM1 external clock driven by TCLK2 pin.
#define   SIM_FTMOPT0_FTM1CLKSEL_11              (uint32_t)0x3          // No clock input
                                                                        // FTM2 External Clock Pin Select
#define SIM_FTMOPT0_FTM2CLKSEL(_n)               (((uint32_t)(_n) & 0x3) << 28)
#define SIM_FTMOPT0_FTM2CLKSEL_INSERT(_v, _n)        (((_v) & ~0x30000000) | ((uint32_t)(_n) & 0x3) << 28)
#define SIM_FTMOPT0_FTM2CLKSEL_EXTRACT(_v)           (((_v) >> 28) & 0x3)
#define   SIM_FTMOPT0_FTM2CLKSEL_00              (uint32_t)0x0          // FTM2 external clock driven by TCLK0 pin.
#define   SIM_FTMOPT0_FTM2CLKSEL_01              (uint32_t)0x1          // FTM2 external clock driven by TCLK1 pin.
#define   SIM_FTMOPT0_FTM2CLKSEL_10              (uint32_t)0x2          // FTM2 external clock driven by TCLK2 pin.
#define   SIM_FTMOPT0_FTM2CLKSEL_11              (uint32_t)0x3          // No clock input
                                                                        // FTM3 External Clock Pin Select
#define SIM_FTMOPT0_FTM3CLKSEL(_n)               (((uint32_t)(_n) & 0x3) << 30)
#define SIM_FTMOPT0_FTM3CLKSEL_INSERT(_v, _n)        (((_v) & ~0xc0000000) | ((uint32_t)(_n) & 0x3) << 30)
#define SIM_FTMOPT0_FTM3CLKSEL_EXTRACT(_v)           (((_v) >> 30) & 0x3)
#define   SIM_FTMOPT0_FTM3CLKSEL_00              (uint32_t)0x0          // FTM3 external clock driven by TCLK0 pin.
#define   SIM_FTMOPT0_FTM3CLKSEL_01              (uint32_t)0x1          // FTM3 external clock driven by TCLK1 pin.
#define   SIM_FTMOPT0_FTM3CLKSEL_10              (uint32_t)0x2          // FTM3 external clock driven by TCLK2 pin.
#define   SIM_FTMOPT0_FTM3CLKSEL_11              (uint32_t)0x3          // No clock input

    uint32_t             LPOCLKS;                                       // LPO Clock Select Register
#define SIM_LPOCLKS_LPO1KCLKEN                   ((uint32_t)1 << 0)     // 1 kHz LPO_CLK enable
#define   SIM_LPOCLKS_LPO1KCLKEN_0               (uint32_t)0x0          // Disable 1 kHz LPO_CLK output
#define   SIM_LPOCLKS_LPO1KCLKEN_1               (uint32_t)0x1          // Enable 1 kHz LPO_CLK output
#define SIM_LPOCLKS_LPO32KCLKEN                  ((uint32_t)1 << 1)     // 32 kHz LPO_CLK enable
#define   SIM_LPOCLKS_LPO32KCLKEN_0              (uint32_t)0x0          // Disable 32 kHz LPO_CLK output
#define   SIM_LPOCLKS_LPO32KCLKEN_1              (uint32_t)0x1          // Enable 32 kHz LPO_CLK output
                                                                        // LPO clock source select
#define SIM_LPOCLKS_LPOCLKSEL(_n)                (((uint32_t)(_n) & 0x3) << 2)
#define SIM_LPOCLKS_LPOCLKSEL_INSERT(_v, _n)         (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define SIM_LPOCLKS_LPOCLKSEL_EXTRACT(_v)            (((_v) >> 2) & 0x3)
#define   SIM_LPOCLKS_LPOCLKSEL_00               (uint32_t)0x0          // 128 kHz LPO_CLK
#define   SIM_LPOCLKS_LPOCLKSEL_01               (uint32_t)0x1          // No clock
#define   SIM_LPOCLKS_LPOCLKSEL_10               (uint32_t)0x2          // 32 kHz LPO_CLK which is derived from the 128 kHz LPO_CLK
#define   SIM_LPOCLKS_LPOCLKSEL_11               (uint32_t)0x3          // 1 kHz LPO_CLK which is derived from the 128 kHz LPO_CLK
                                                                        // 32 kHz clock source select
#define SIM_LPOCLKS_RTCCLKSEL(_n)                (((uint32_t)(_n) & 0x3) << 4)
#define SIM_LPOCLKS_RTCCLKSEL_INSERT(_v, _n)         (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define SIM_LPOCLKS_RTCCLKSEL_EXTRACT(_v)            (((_v) >> 4) & 0x3)
#define   SIM_LPOCLKS_RTCCLKSEL_00               (uint32_t)0x0          // SOSCDIV1_CLK
#define   SIM_LPOCLKS_RTCCLKSEL_01               (uint32_t)0x1          // 32 kHz LPO_CLK
#define   SIM_LPOCLKS_RTCCLKSEL_10               (uint32_t)0x2          // RTC_CLKIN clock
#define   SIM_LPOCLKS_RTCCLKSEL_11               (uint32_t)0x3          // FIRCDIV1_CLK

    uint8_t _res2[4];
    uint32_t             ADCOPT;                                        // ADC Options Register
#define SIM_ADCOPT_ADC0TRGSEL                    ((uint32_t)1 << 0)     // ADC0 trigger source select
#define   SIM_ADCOPT_ADC0TRGSEL_0                (uint32_t)0x0          // PDB output
#define   SIM_ADCOPT_ADC0TRGSEL_1                (uint32_t)0x1          // TRGMUX output
                                                                        // ADC0 software pretrigger sources
#define SIM_ADCOPT_ADC0SWPRETRG(_n)              (((uint32_t)(_n) & 0x7) << 1)
#define SIM_ADCOPT_ADC0SWPRETRG_INSERT(_v, _n)       (((_v) & ~0xe) | ((uint32_t)(_n) & 0x7) << 1)
#define SIM_ADCOPT_ADC0SWPRETRG_EXTRACT(_v)          (((_v) >> 1) & 0x7)
#define   SIM_ADCOPT_ADC0SWPRETRG_000            (uint32_t)0x0          // Software pretrigger disabled
#define   SIM_ADCOPT_ADC0SWPRETRG_001            (uint32_t)0x1          // Reserved (do not use)
#define   SIM_ADCOPT_ADC0SWPRETRG_010            (uint32_t)0x2          // Reserved (do not use)
#define   SIM_ADCOPT_ADC0SWPRETRG_011            (uint32_t)0x3          // Reserved (do not use)
#define   SIM_ADCOPT_ADC0SWPRETRG_100            (uint32_t)0x4          // Software pretrigger 0
#define   SIM_ADCOPT_ADC0SWPRETRG_101            (uint32_t)0x5          // Software pretrigger 1
#define   SIM_ADCOPT_ADC0SWPRETRG_110            (uint32_t)0x6          // Software pretrigger 2
#define   SIM_ADCOPT_ADC0SWPRETRG_111            (uint32_t)0x7          // Software pretrigger 3
                                                                        // ADC0 pretrigger source select
#define SIM_ADCOPT_ADC0PRETRGSEL(_n)             (((uint32_t)(_n) & 0x3) << 4)
#define SIM_ADCOPT_ADC0PRETRGSEL_INSERT(_v, _n)      (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define SIM_ADCOPT_ADC0PRETRGSEL_EXTRACT(_v)         (((_v) >> 4) & 0x3)
#define   SIM_ADCOPT_ADC0PRETRGSEL_00            (uint32_t)0x0          // PDB pretrigger (default)
#define   SIM_ADCOPT_ADC0PRETRGSEL_01            (uint32_t)0x1          // TRGMUX pretrigger
#define   SIM_ADCOPT_ADC0PRETRGSEL_10            (uint32_t)0x2          // Software pretrigger
#define SIM_ADCOPT_ADC1TRGSEL                    ((uint32_t)1 << 8)     // ADC1 trigger source select
#define   SIM_ADCOPT_ADC1TRGSEL_0                (uint32_t)0x0          // PDB output
#define   SIM_ADCOPT_ADC1TRGSEL_1                (uint32_t)0x1          // TRGMUX output
                                                                        // ADC1 software pretrigger sources
#define SIM_ADCOPT_ADC1SWPRETRG(_n)              (((uint32_t)(_n) & 0x7) << 9)
#define SIM_ADCOPT_ADC1SWPRETRG_INSERT(_v, _n)       (((_v) & ~0xe00) | ((uint32_t)(_n) & 0x7) << 9)
#define SIM_ADCOPT_ADC1SWPRETRG_EXTRACT(_v)          (((_v) >> 9) & 0x7)
#define   SIM_ADCOPT_ADC1SWPRETRG_000            (uint32_t)0x0          // Software pretrigger disabled
#define   SIM_ADCOPT_ADC1SWPRETRG_001            (uint32_t)0x1          // Reserved (do not use)
#define   SIM_ADCOPT_ADC1SWPRETRG_010            (uint32_t)0x2          // Reserved (do not use)
#define   SIM_ADCOPT_ADC1SWPRETRG_011            (uint32_t)0x3          // Reserved (do not use)
#define   SIM_ADCOPT_ADC1SWPRETRG_100            (uint32_t)0x4          // Software pretrigger 0
#define   SIM_ADCOPT_ADC1SWPRETRG_101            (uint32_t)0x5          // Software pretrigger 1
#define   SIM_ADCOPT_ADC1SWPRETRG_110            (uint32_t)0x6          // Software pretrigger 2
#define   SIM_ADCOPT_ADC1SWPRETRG_111            (uint32_t)0x7          // Software pretrigger 3
                                                                        // ADC1 pretrigger source select
#define SIM_ADCOPT_ADC1PRETRGSEL(_n)             (((uint32_t)(_n) & 0x3) << 12)
#define SIM_ADCOPT_ADC1PRETRGSEL_INSERT(_v, _n)      (((_v) & ~0x3000) | ((uint32_t)(_n) & 0x3) << 12)
#define SIM_ADCOPT_ADC1PRETRGSEL_EXTRACT(_v)         (((_v) >> 12) & 0x3)
#define   SIM_ADCOPT_ADC1PRETRGSEL_00            (uint32_t)0x0          // PDB pretrigger (default)
#define   SIM_ADCOPT_ADC1PRETRGSEL_01            (uint32_t)0x1          // TRGMUX pretrigger
#define   SIM_ADCOPT_ADC1PRETRGSEL_10            (uint32_t)0x2          // Software pretrigger

    uint32_t             FTMOPT1;                                       // FTM Option Register 1
#define SIM_FTMOPT1_FTM0SYNCBIT                  ((uint32_t)1 << 0)     // FTM0 Sync Bit
#define SIM_FTMOPT1_FTM1SYNCBIT                  ((uint32_t)1 << 1)     // FTM1 Sync Bit
#define SIM_FTMOPT1_FTM2SYNCBIT                  ((uint32_t)1 << 2)     // FTM2 Sync Bit
#define SIM_FTMOPT1_FTM3SYNCBIT                  ((uint32_t)1 << 3)     // FTM3 Sync Bit
                                                                        // FTM1 CH0 Select
#define SIM_FTMOPT1_FTM1CH0SEL(_n)               (((uint32_t)(_n) & 0x3) << 4)
#define SIM_FTMOPT1_FTM1CH0SEL_INSERT(_v, _n)        (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define SIM_FTMOPT1_FTM1CH0SEL_EXTRACT(_v)           (((_v) >> 4) & 0x3)
#define   SIM_FTMOPT1_FTM1CH0SEL_00              (uint32_t)0x0          // FTM1_CH0 input
#define   SIM_FTMOPT1_FTM1CH0SEL_01              (uint32_t)0x1          // CMP0 output
                                                                        // FTM2 CH0 Select
#define SIM_FTMOPT1_FTM2CH0SEL(_n)               (((uint32_t)(_n) & 0x3) << 6)
#define SIM_FTMOPT1_FTM2CH0SEL_INSERT(_v, _n)        (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define SIM_FTMOPT1_FTM2CH0SEL_EXTRACT(_v)           (((_v) >> 6) & 0x3)
#define   SIM_FTMOPT1_FTM2CH0SEL_00              (uint32_t)0x0          // FTM2_CH0 input
#define   SIM_FTMOPT1_FTM2CH0SEL_01              (uint32_t)0x1          // CMP0 output
#define SIM_FTMOPT1_FTM2CH1SEL                   ((uint32_t)1 << 8)     // FTM2 CH1 Select
#define   SIM_FTMOPT1_FTM2CH1SEL_0               (uint32_t)0x0          // FTM2_CH1 input
#define   SIM_FTMOPT1_FTM2CH1SEL_1               (uint32_t)0x1          // exclusive OR of FTM2_CH0,FTM2_CH1,and FTM1_CH1
#define SIM_FTMOPT1_FTMGLDOK                     ((uint32_t)1 << 15)    // FTM global load enable
#define   SIM_FTMOPT1_FTMGLDOK_0                 (uint32_t)0x0          // FTM Global load mechanism disabled.
#define   SIM_FTMOPT1_FTMGLDOK_1                 (uint32_t)0x1          // FTM Global load mechanism enabled
                                                                        // FTM0 channel modulation select with FTM1_CH1
#define SIM_FTMOPT1_FTM0_OUTSEL(_n)              (((uint32_t)(_n) & 0xff) << 16)
#define SIM_FTMOPT1_FTM0_OUTSEL_INSERT(_v, _n)       (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define SIM_FTMOPT1_FTM0_OUTSEL_EXTRACT(_v)          (((_v) >> 16) & 0xff)
#define   SIM_FTMOPT1_FTM0_OUTSEL_00000000       (uint32_t)0x0          // No modulation with FTM1_CH1
#define   SIM_FTMOPT1_FTM0_OUTSEL_00000001       (uint32_t)0x1          // Modulation with FTM1_CH1
                                                                        // FTM3 channel modulation select with FTM2_CH1
#define SIM_FTMOPT1_FTM3_OUTSEL(_n)              (((uint32_t)(_n) & 0xff) << 24)
#define SIM_FTMOPT1_FTM3_OUTSEL_INSERT(_v, _n)       (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define SIM_FTMOPT1_FTM3_OUTSEL_EXTRACT(_v)          (((_v) >> 24) & 0xff)
#define   SIM_FTMOPT1_FTM3_OUTSEL_00000000       (uint32_t)0x0          // No modulation with FTM2_CH1
#define   SIM_FTMOPT1_FTM3_OUTSEL_00000001       (uint32_t)0x1          // Modulation with FTM2_CH1

    uint32_t             MISCTRL0;                                      // Miscellaneous control register 0
#define SIM_MISCTRL0_STOP1_MONITOR               ((uint32_t)1 << 9)     // STOP1 monitor bit
#define   SIM_MISCTRL0_STOP1_MONITOR_0           (uint32_t)0x0          // Bus clock enabled or STOP1 entry aborted
#define   SIM_MISCTRL0_STOP1_MONITOR_1           (uint32_t)0x1          // STOP1 entry successful
#define SIM_MISCTRL0_STOP2_MONITOR               ((uint32_t)1 << 10)    // STOP2 monitor bit
#define   SIM_MISCTRL0_STOP2_MONITOR_0           (uint32_t)0x0          // System clock enabled or STOP2 entry aborted
#define   SIM_MISCTRL0_STOP2_MONITOR_1           (uint32_t)0x1          // STOP2 entry successful
#define SIM_MISCTRL0_FTM0_OBE_CTRL               ((uint32_t)1 << 16)    // FTM0 OBE CTRL bit
#define   SIM_MISCTRL0_FTM0_OBE_CTRL_0           (uint32_t)0x0          // The FTM channel output is put to safe state when the FTM counter is enabled and the FTM channel output is enabled by Fault Control (FTM_MODE[FAULTM]!=2'b00 and FTM_FLTCTRL[FSTATE]=1'b0) and PWM is enabled (FTM_SC[PWMENn] = 1'b1). Otherwise the channel output is tristated.
#define   SIM_MISCTRL0_FTM0_OBE_CTRL_1           (uint32_t)0x1          // The FTM channel output state is retained when the channel is in output mode. The output channel is tristated when the channel is in input capture [DECAPEN=1'b0, COMBINE=1'b0, MSnB:MSnA=2'b00] or dual edge capture mode [DECAPEN=1'b1].
#define SIM_MISCTRL0_FTM1_OBE_CTRL               ((uint32_t)1 << 17)    // FTM1 OBE CTRL bit
#define   SIM_MISCTRL0_FTM1_OBE_CTRL_0           (uint32_t)0x0          // The FTM channel output is put to safe state when the FTM counter is enabled and the FTM channel output is enabled by Fault Control (FTM_MODE[FAULTM]!=2'b00 and FTM_FLTCTRL[FSTATE]=1'b0) and PWM is enabled (FTM_SC[PWMENn] = 1'b1). Otherwise the channel output is tristated.
#define   SIM_MISCTRL0_FTM1_OBE_CTRL_1           (uint32_t)0x1          // The FTM channel output state is retained when the channel is in output mode. The output channel is tristated when the channel is in input capture [DECAPEN=1'b0, COMBINE=1'b0, MSnB:MSnA=2'b00] or dual edge capture mode [DECAPEN=1'b1].
#define SIM_MISCTRL0_FTM2_OBE_CTRL               ((uint32_t)1 << 18)    // FTM2 OBE CTRL bit
#define   SIM_MISCTRL0_FTM2_OBE_CTRL_0           (uint32_t)0x0          // The FTM channel output is put to safe state when the FTM counter is enabled and the FTM channel output is enabled by Fault Control (FTM_MODE[FAULTM]!=2'b00 and FTM_FLTCTRL[FSTATE]=1'b0) and PWM is enabled (FTM_SC[PWMENn] = 1'b1). Otherwise the channel output is tristated.
#define   SIM_MISCTRL0_FTM2_OBE_CTRL_1           (uint32_t)0x1          // The FTM channel output state is retained when the channel is in output mode. The output channel is tristated when the channel is in input capture [DECAPEN=1'b0, COMBINE=1'b0, MSnB:MSnA=2'b00] or dual edge capture mode [DECAPEN=1'b1].
#define SIM_MISCTRL0_FTM3_OBE_CTRL               ((uint32_t)1 << 19)    // FTM3 OBE CTRL bit
#define   SIM_MISCTRL0_FTM3_OBE_CTRL_0           (uint32_t)0x0          // The FTM channel output is put to safe state when the FTM counter is enabled and the FTM channel output is enabled by Fault Control (FTM_MODE[FAULTM]!=2'b00 and FTM_FLTCTRL[FSTATE]=1'b0) and PWM is enabled (FTM_SC[PWMENn] = 1'b1). Otherwise the channel output is tristated.
#define   SIM_MISCTRL0_FTM3_OBE_CTRL_1           (uint32_t)0x1          // The FTM channel output state is retained when the channel is in output mode. The output channel is tristated when the channel is in input capture [DECAPEN=1'b0, COMBINE=1'b0, MSnB:MSnA=2'b00] or dual edge capture mode [DECAPEN=1'b1].

    const uint32_t       SDID;                                          // System Device Identification Register
                                                                        // Features
#define SIM_SDID_FEATURES_EXTRACT(_v)                (((_v) >> 0) & 0xff)
                                                                        // Package
#define SIM_SDID_PACKAGE_EXTRACT(_v)                 (((_v) >> 8) & 0xf)
#define   SIM_SDID_PACKAGE_0010                  (uint32_t)0x2          // 48 LQFP
#define   SIM_SDID_PACKAGE_0011                  (uint32_t)0x3          // 64 LQFP
#define   SIM_SDID_PACKAGE_0100                  (uint32_t)0x4          // 100 LQFP
#define   SIM_SDID_PACKAGE_0110                  (uint32_t)0x6          // 144 LQFP
#define   SIM_SDID_PACKAGE_0111                  (uint32_t)0x7          // 176 LQFP
#define   SIM_SDID_PACKAGE_1000                  (uint32_t)0x8          // 100 MAP BGA
                                                                        // Device revision number
#define SIM_SDID_REVID_EXTRACT(_v)                   (((_v) >> 12) & 0xf)
                                                                        // RAM size
#define SIM_SDID_RAMSIZE_EXTRACT(_v)                 (((_v) >> 16) & 0xf)
#define   SIM_SDID_RAMSIZE_1011                  (uint32_t)0xb          // 192 KB (S32K148), 96 KB (S32K146), Reserved (others)
#define   SIM_SDID_RAMSIZE_1101                  (uint32_t)0xd          // 48 KB (S32K144), Reserved (others)
#define   SIM_SDID_RAMSIZE_1111                  (uint32_t)0xf          // 256 KB (S32K148), 128 KB (S32K146), 64 KB (S32K144), 32 KB (S32K142), 25 KB (S32K118), 17 KB (S32K116)
                                                                        // Derivate
#define SIM_SDID_DERIVATE_EXTRACT(_v)                (((_v) >> 20) & 0xf)
                                                                        // Subseries
#define SIM_SDID_SUBSERIES_EXTRACT(_v)               (((_v) >> 24) & 0xf)
                                                                        // S32K product series generation
#define SIM_SDID_GENERATION_EXTRACT(_v)              (((_v) >> 28) & 0xf)

    uint8_t _res3[24];
    uint32_t             PLATCGC;                                       // Platform Clock Gating Control Register
#define SIM_PLATCGC_CGCMSCM                      ((uint32_t)1 << 0)     // MSCM Clock Gating Control
#define   SIM_PLATCGC_CGCMSCM_0                  (uint32_t)0x0          // Clock disabled
#define   SIM_PLATCGC_CGCMSCM_1                  (uint32_t)0x1          // Clock enabled
#define SIM_PLATCGC_CGCMPU                       ((uint32_t)1 << 1)     // MPU Clock Gating Control
#define   SIM_PLATCGC_CGCMPU_0                   (uint32_t)0x0          // Clock disabled
#define   SIM_PLATCGC_CGCMPU_1                   (uint32_t)0x1          // Clock enabled
#define SIM_PLATCGC_CGCDMA                       ((uint32_t)1 << 2)     // DMA Clock Gating Control
#define   SIM_PLATCGC_CGCDMA_0                   (uint32_t)0x0          // Clock disabled
#define   SIM_PLATCGC_CGCDMA_1                   (uint32_t)0x1          // Clock enabled
#define SIM_PLATCGC_CGCERM                       ((uint32_t)1 << 3)     // ERM Clock Gating Control
#define   SIM_PLATCGC_CGCERM_0                   (uint32_t)0x0          // Clock disabled
#define   SIM_PLATCGC_CGCERM_1                   (uint32_t)0x1          // Clock enabled
#define SIM_PLATCGC_CGCEIM                       ((uint32_t)1 << 4)     // EIM Clock Gating Control
#define   SIM_PLATCGC_CGCEIM_0                   (uint32_t)0x0          // Clock disabled
#define   SIM_PLATCGC_CGCEIM_1                   (uint32_t)0x1          // Clock enabled

    uint8_t _res4[8];
    uint32_t             FCFG1;                                         // Flash Configuration Register 1
                                                                        // FlexNVM partition
#define SIM_FCFG1_DEPART(_n)                     (((uint32_t)(_n) & 0xf) << 12)
#define SIM_FCFG1_DEPART_INSERT(_v, _n)              (((_v) & ~0xf000) | ((uint32_t)(_n) & 0xf) << 12)
#define SIM_FCFG1_DEPART_EXTRACT(_v)                 (((_v) >> 12) & 0xf)
                                                                        // EEE SRAM SIZE
#define SIM_FCFG1_EEERAMSIZE(_n)                 (((uint32_t)(_n) & 0xf) << 16)
#define SIM_FCFG1_EEERAMSIZE_INSERT(_v, _n)          (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define SIM_FCFG1_EEERAMSIZE_EXTRACT(_v)             (((_v) >> 16) & 0xf)
#define   SIM_FCFG1_EEERAMSIZE_0010              (uint32_t)0x2          // 4 KB
#define   SIM_FCFG1_EEERAMSIZE_0011              (uint32_t)0x3          // 2 KB
#define   SIM_FCFG1_EEERAMSIZE_0100              (uint32_t)0x4          // 1 KB
#define   SIM_FCFG1_EEERAMSIZE_0101              (uint32_t)0x5          // 512 Bytes
#define   SIM_FCFG1_EEERAMSIZE_0110              (uint32_t)0x6          // 256 Bytes
#define   SIM_FCFG1_EEERAMSIZE_0111              (uint32_t)0x7          // 128 Bytes
#define   SIM_FCFG1_EEERAMSIZE_1000              (uint32_t)0x8          // 64 Bytes
#define   SIM_FCFG1_EEERAMSIZE_1001              (uint32_t)0x9          // 32 Bytes
#define   SIM_FCFG1_EEERAMSIZE_1111              (uint32_t)0xf          // 0 Bytes

    uint8_t _res5[4];
    const uint32_t       UIDH;                                          // Unique Identification Register High
    const uint32_t       UIDMH;                                         // Unique Identification Register Mid-High
    const uint32_t       UIDML;                                         // Unique Identification Register Mid Low
    const uint32_t       UIDL;                                          // Unique Identification Register Low
    uint8_t _res6[4];
    uint32_t             CLKDIV4;                                       // System Clock Divider Register 4
#define SIM_CLKDIV4_TRACEFRAC                    ((uint32_t)1 << 0)     // Trace Clock Divider fraction To configure TRACEDIV and TRACEFRAC, you must first clear TRACEDIVEN to disable the trace clock divide function.
                                                                        // Trace Clock Divider value To configure TRACEDIV, you must first disable TRACEDIVEN, then enable it after setting TRACEDIV.
#define SIM_CLKDIV4_TRACEDIV(_n)                 (((uint32_t)(_n) & 0x7) << 1)
#define SIM_CLKDIV4_TRACEDIV_INSERT(_v, _n)          (((_v) & ~0xe) | ((uint32_t)(_n) & 0x7) << 1)
#define SIM_CLKDIV4_TRACEDIV_EXTRACT(_v)             (((_v) >> 1) & 0x7)
#define SIM_CLKDIV4_TRACEDIVEN                   ((uint32_t)1 << 28)    // Debug Trace Divider control
#define   SIM_CLKDIV4_TRACEDIVEN_0               (uint32_t)0x0          // Debug trace divider disabled
#define   SIM_CLKDIV4_TRACEDIVEN_1               (uint32_t)0x1          // Debug trace divider enabled

    uint32_t             MISCTRL1;                                      // Miscellaneous Control register 1
#define SIM_MISCTRL1_SW_TRG                      ((uint32_t)1 << 0)     // Software trigger to TRGMUX. Writing to this bit generates software trigger to peripherals through TRGMUX (Refer to Figure: Trigger interconnectivity).

} SIM_regs_t;
                                                                        // --------------------
                                                                        // Pin Control and Interrupts
typedef struct                                                          // --------------------
{
    uint32_t             PCR0;                                          // Pin Control Register n
#define PORT_PCR0_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR0_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR0_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR0_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR0_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR0_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR0_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR0_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR0_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR0_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR0_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR0_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR0_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR0_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR0_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR0_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR0_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR0_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR0_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR0_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR0_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR0_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR0_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR0_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR0_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR0_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR0_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR0_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR0_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR0_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR0_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR0_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR0_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR0_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR0_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR1;                                          // Pin Control Register n
#define PORT_PCR1_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR1_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR1_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR1_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR1_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR1_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR1_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR1_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR1_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR1_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR1_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR1_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR1_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR1_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR1_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR1_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR1_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR1_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR1_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR1_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR1_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR1_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR1_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR1_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR1_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR1_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR1_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR1_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR1_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR1_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR1_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR1_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR1_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR1_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR1_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR2;                                          // Pin Control Register n
#define PORT_PCR2_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR2_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR2_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR2_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR2_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR2_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR2_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR2_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR2_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR2_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR2_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR2_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR2_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR2_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR2_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR2_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR2_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR2_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR2_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR2_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR2_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR2_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR2_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR2_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR2_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR2_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR2_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR2_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR2_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR2_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR2_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR2_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR2_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR2_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR2_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR3;                                          // Pin Control Register n
#define PORT_PCR3_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR3_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR3_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR3_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR3_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR3_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR3_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR3_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR3_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR3_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR3_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR3_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR3_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR3_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR3_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR3_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR3_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR3_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR3_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR3_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR3_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR3_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR3_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR3_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR3_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR3_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR3_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR3_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR3_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR3_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR3_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR3_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR3_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR3_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR3_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR4;                                          // Pin Control Register n
#define PORT_PCR4_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR4_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR4_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR4_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR4_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR4_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR4_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR4_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR4_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR4_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR4_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR4_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR4_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR4_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR4_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR4_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR4_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR4_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR4_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR4_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR4_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR4_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR4_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR4_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR4_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR4_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR4_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR4_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR4_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR4_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR4_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR4_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR4_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR4_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR4_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR5;                                          // Pin Control Register n
#define PORT_PCR5_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR5_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR5_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR5_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR5_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR5_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
#define PORT_PCR5_PFE                            ((uint32_t)1 << 4)     // Passive Filter Enable
#define   PORT_PCR5_PFE_0                        (uint32_t)0x0          // Passive input filter is disabled on the corresponding pin.
#define   PORT_PCR5_PFE_1                        (uint32_t)0x1          // Passive input filter is enabled on the corresponding pin, if the pin is configured as a digital input. Refer to the device data sheet for filter characteristics.
                                                                        // Pin Mux Control
#define PORT_PCR5_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR5_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR5_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR5_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR5_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR5_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR5_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR5_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR5_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR5_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR5_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR5_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR5_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR5_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR5_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR5_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR5_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR5_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR5_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR5_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR5_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR5_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR5_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR5_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR5_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR5_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR5_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR5_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR5_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR6;                                          // Pin Control Register n
#define PORT_PCR6_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR6_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR6_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR6_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR6_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR6_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR6_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR6_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR6_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR6_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR6_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR6_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR6_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR6_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR6_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR6_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR6_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR6_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR6_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR6_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR6_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR6_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR6_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR6_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR6_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR6_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR6_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR6_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR6_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR6_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR6_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR6_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR6_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR6_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR6_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR7;                                          // Pin Control Register n
#define PORT_PCR7_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR7_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR7_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR7_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR7_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR7_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR7_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR7_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR7_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR7_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR7_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR7_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR7_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR7_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR7_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR7_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR7_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR7_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR7_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR7_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR7_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR7_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR7_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR7_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR7_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR7_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR7_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR7_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR7_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR7_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR7_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR7_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR7_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR7_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR7_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR8;                                          // Pin Control Register n
#define PORT_PCR8_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR8_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR8_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR8_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR8_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR8_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR8_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR8_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR8_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR8_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR8_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR8_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR8_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR8_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR8_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR8_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR8_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR8_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR8_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR8_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR8_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR8_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR8_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR8_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR8_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR8_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR8_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR8_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR8_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR8_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR8_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR8_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR8_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR8_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR8_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR9;                                          // Pin Control Register n
#define PORT_PCR9_PS                             ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR9_PS_0                         (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR9_PS_1                         (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR9_PE                             ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR9_PE_0                         (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR9_PE_1                         (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR9_MUX(_n)                        (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR9_MUX_INSERT(_v, _n)                 (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR9_MUX_EXTRACT(_v)                    (((_v) >> 8) & 0x7)
#define   PORT_PCR9_MUX_000                      (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR9_MUX_001                      (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR9_MUX_010                      (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR9_MUX_011                      (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR9_MUX_100                      (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR9_MUX_101                      (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR9_MUX_110                      (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR9_MUX_111                      (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR9_LK                             ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR9_LK_0                         (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR9_LK_1                         (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR9_IRQC(_n)                       (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR9_IRQC_INSERT(_v, _n)                (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR9_IRQC_EXTRACT(_v)                   (((_v) >> 16) & 0xf)
#define   PORT_PCR9_IRQC_0000                    (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR9_IRQC_0001                    (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR9_IRQC_0010                    (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR9_IRQC_0011                    (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR9_IRQC_1000                    (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR9_IRQC_1001                    (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR9_IRQC_1010                    (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR9_IRQC_1011                    (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR9_IRQC_1100                    (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR9_ISF                            ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR9_ISF_0                        (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR9_ISF_1                        (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR10;                                         // Pin Control Register n
#define PORT_PCR10_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR10_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR10_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR10_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR10_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR10_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
#define PORT_PCR10_DSE                           ((uint32_t)1 << 6)     // Drive Strength Enable
#define   PORT_PCR10_DSE_0                       (uint32_t)0x0          // Low drive strength is configured on the corresponding pin, if pin is configured as a digital output.
#define   PORT_PCR10_DSE_1                       (uint32_t)0x1          // High drive strength is configured on the corresponding pin, if pin is configured as a digital output.
                                                                        // Pin Mux Control
#define PORT_PCR10_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR10_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR10_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR10_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR10_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR10_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR10_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR10_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR10_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR10_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR10_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR10_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR10_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR10_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR10_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR10_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR10_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR10_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR10_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR10_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR10_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR10_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR10_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR10_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR10_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR10_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR10_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR10_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR10_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR11;                                         // Pin Control Register n
#define PORT_PCR11_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR11_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR11_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR11_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR11_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR11_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR11_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR11_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR11_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR11_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR11_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR11_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR11_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR11_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR11_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR11_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR11_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR11_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR11_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR11_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR11_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR11_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR11_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR11_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR11_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR11_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR11_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR11_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR11_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR11_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR11_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR11_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR11_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR11_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR11_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR12;                                         // Pin Control Register n
#define PORT_PCR12_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR12_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR12_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR12_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR12_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR12_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR12_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR12_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR12_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR12_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR12_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR12_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR12_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR12_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR12_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR12_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR12_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR12_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR12_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR12_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR12_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR12_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR12_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR12_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR12_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR12_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR12_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR12_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR12_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR12_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR12_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR12_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR12_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR12_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR12_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR13;                                         // Pin Control Register n
#define PORT_PCR13_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR13_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR13_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR13_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR13_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR13_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR13_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR13_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR13_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR13_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR13_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR13_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR13_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR13_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR13_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR13_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR13_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR13_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR13_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR13_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR13_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR13_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR13_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR13_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR13_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR13_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR13_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR13_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR13_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR13_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR13_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR13_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR13_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR13_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR13_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR14;                                         // Pin Control Register n
#define PORT_PCR14_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR14_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR14_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR14_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR14_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR14_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR14_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR14_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR14_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR14_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR14_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR14_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR14_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR14_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR14_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR14_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR14_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR14_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR14_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR14_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR14_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR14_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR14_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR14_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR14_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR14_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR14_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR14_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR14_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR14_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR14_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR14_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR14_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR14_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR14_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR15;                                         // Pin Control Register n
#define PORT_PCR15_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR15_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR15_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR15_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR15_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR15_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR15_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR15_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR15_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR15_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR15_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR15_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR15_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR15_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR15_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR15_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR15_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR15_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR15_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR15_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR15_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR15_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR15_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR15_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR15_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR15_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR15_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR15_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR15_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR15_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR15_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR15_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR15_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR15_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR15_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR16;                                         // Pin Control Register n
#define PORT_PCR16_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR16_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR16_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR16_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR16_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR16_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR16_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR16_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR16_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR16_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR16_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR16_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR16_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR16_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR16_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR16_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR16_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR16_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR16_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR16_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR16_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR16_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR16_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR16_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR16_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR16_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR16_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR16_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR16_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR16_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR16_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR16_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR16_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR16_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR16_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR17;                                         // Pin Control Register n
#define PORT_PCR17_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR17_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR17_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR17_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR17_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR17_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR17_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR17_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR17_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR17_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR17_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR17_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR17_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR17_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR17_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR17_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR17_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR17_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR17_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR17_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR17_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR17_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR17_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR17_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR17_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR17_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR17_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR17_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR17_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR17_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR17_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR17_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR17_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR17_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR17_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR18;                                         // Pin Control Register n
#define PORT_PCR18_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR18_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR18_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR18_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR18_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR18_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR18_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR18_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR18_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR18_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR18_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR18_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR18_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR18_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR18_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR18_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR18_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR18_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR18_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR18_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR18_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR18_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR18_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR18_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR18_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR18_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR18_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR18_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR18_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR18_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR18_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR18_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR18_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR18_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR18_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR19;                                         // Pin Control Register n
#define PORT_PCR19_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR19_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR19_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR19_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR19_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR19_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR19_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR19_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR19_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR19_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR19_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR19_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR19_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR19_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR19_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR19_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR19_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR19_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR19_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR19_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR19_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR19_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR19_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR19_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR19_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR19_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR19_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR19_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR19_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR19_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR19_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR19_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR19_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR19_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR19_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR20;                                         // Pin Control Register n
#define PORT_PCR20_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR20_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR20_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR20_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR20_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR20_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR20_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR20_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR20_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR20_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR20_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR20_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR20_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR20_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR20_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR20_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR20_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR20_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR20_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR20_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR20_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR20_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR20_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR20_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR20_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR20_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR20_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR20_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR20_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR20_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR20_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR20_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR20_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR20_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR20_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR21;                                         // Pin Control Register n
#define PORT_PCR21_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR21_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR21_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR21_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR21_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR21_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR21_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR21_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR21_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR21_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR21_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR21_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR21_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR21_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR21_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR21_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR21_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR21_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR21_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR21_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR21_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR21_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR21_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR21_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR21_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR21_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR21_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR21_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR21_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR21_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR21_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR21_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR21_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR21_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR21_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR22;                                         // Pin Control Register n
#define PORT_PCR22_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR22_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR22_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR22_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR22_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR22_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR22_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR22_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR22_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR22_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR22_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR22_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR22_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR22_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR22_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR22_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR22_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR22_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR22_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR22_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR22_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR22_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR22_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR22_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR22_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR22_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR22_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR22_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR22_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR22_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR22_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR22_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR22_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR22_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR22_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR23;                                         // Pin Control Register n
#define PORT_PCR23_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR23_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR23_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR23_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR23_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR23_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR23_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR23_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR23_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR23_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR23_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR23_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR23_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR23_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR23_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR23_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR23_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR23_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR23_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR23_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR23_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR23_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR23_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR23_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR23_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR23_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR23_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR23_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR23_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR23_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR23_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR23_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR23_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR23_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR23_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR24;                                         // Pin Control Register n
#define PORT_PCR24_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR24_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR24_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR24_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR24_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR24_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR24_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR24_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR24_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR24_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR24_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR24_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR24_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR24_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR24_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR24_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR24_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR24_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR24_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR24_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR24_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR24_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR24_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR24_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR24_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR24_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR24_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR24_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR24_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR24_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR24_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR24_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR24_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR24_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR24_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR25;                                         // Pin Control Register n
#define PORT_PCR25_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR25_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR25_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR25_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR25_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR25_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR25_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR25_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR25_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR25_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR25_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR25_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR25_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR25_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR25_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR25_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR25_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR25_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR25_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR25_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR25_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR25_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR25_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR25_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR25_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR25_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR25_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR25_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR25_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR25_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR25_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR25_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR25_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR25_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR25_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR26;                                         // Pin Control Register n
#define PORT_PCR26_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR26_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR26_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR26_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR26_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR26_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR26_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR26_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR26_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR26_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR26_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR26_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR26_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR26_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR26_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR26_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR26_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR26_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR26_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR26_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR26_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR26_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR26_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR26_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR26_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR26_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR26_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR26_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR26_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR26_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR26_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR26_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR26_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR26_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR26_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR27;                                         // Pin Control Register n
#define PORT_PCR27_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR27_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR27_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR27_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR27_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR27_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR27_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR27_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR27_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR27_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR27_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR27_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR27_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR27_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR27_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR27_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR27_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR27_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR27_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR27_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR27_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR27_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR27_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR27_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR27_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR27_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR27_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR27_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR27_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR27_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR27_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR27_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR27_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR27_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR27_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR28;                                         // Pin Control Register n
#define PORT_PCR28_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR28_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR28_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR28_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR28_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR28_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR28_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR28_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR28_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR28_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR28_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR28_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR28_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR28_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR28_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR28_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR28_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR28_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR28_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR28_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR28_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR28_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR28_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR28_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR28_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR28_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR28_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR28_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR28_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR28_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR28_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR28_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR28_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR28_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR28_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR29;                                         // Pin Control Register n
#define PORT_PCR29_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR29_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR29_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR29_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR29_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR29_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR29_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR29_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR29_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR29_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR29_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR29_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR29_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR29_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR29_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR29_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR29_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR29_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR29_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR29_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR29_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR29_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR29_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR29_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR29_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR29_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR29_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR29_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR29_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR29_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR29_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR29_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR29_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR29_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR29_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR30;                                         // Pin Control Register n
#define PORT_PCR30_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR30_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR30_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR30_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR30_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR30_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR30_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR30_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR30_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR30_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR30_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR30_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR30_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR30_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR30_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR30_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR30_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR30_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR30_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR30_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR30_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR30_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR30_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR30_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR30_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR30_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR30_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR30_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR30_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR30_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR30_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR30_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR30_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR30_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR30_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             PCR31;                                         // Pin Control Register n
#define PORT_PCR31_PS                            ((uint32_t)1 << 0)     // Pull Select
#define   PORT_PCR31_PS_0                        (uint32_t)0x0          // Internal pulldown resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define   PORT_PCR31_PS_1                        (uint32_t)0x1          // Internal pullup resistor is enabled on the corresponding pin, if the corresponding PE field is set.
#define PORT_PCR31_PE                            ((uint32_t)1 << 1)     // Pull Enable
#define   PORT_PCR31_PE_0                        (uint32_t)0x0          // Internal pullup or pulldown resistor is not enabled on the corresponding pin.
#define   PORT_PCR31_PE_1                        (uint32_t)0x1          // Internal pullup or pulldown resistor is enabled on the corresponding pin, if the pin is configured as a digital input.
                                                                        // Pin Mux Control
#define PORT_PCR31_MUX(_n)                       (((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR31_MUX_INSERT(_v, _n)                (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define PORT_PCR31_MUX_EXTRACT(_v)                   (((_v) >> 8) & 0x7)
#define   PORT_PCR31_MUX_000                     (uint32_t)0x0          // Pin disabled (Alternative 0) (analog).
#define   PORT_PCR31_MUX_001                     (uint32_t)0x1          // Alternative 1 (GPIO).
#define   PORT_PCR31_MUX_010                     (uint32_t)0x2          // Alternative 2 (chip-specific).
#define   PORT_PCR31_MUX_011                     (uint32_t)0x3          // Alternative 3 (chip-specific).
#define   PORT_PCR31_MUX_100                     (uint32_t)0x4          // Alternative 4 (chip-specific).
#define   PORT_PCR31_MUX_101                     (uint32_t)0x5          // Alternative 5 (chip-specific).
#define   PORT_PCR31_MUX_110                     (uint32_t)0x6          // Alternative 6 (chip-specific).
#define   PORT_PCR31_MUX_111                     (uint32_t)0x7          // Alternative 7 (chip-specific).
#define PORT_PCR31_LK                            ((uint32_t)1 << 15)    // Lock Register
#define   PORT_PCR31_LK_0                        (uint32_t)0x0          // Pin Control Register fields [15:0] are not locked.
#define   PORT_PCR31_LK_1                        (uint32_t)0x1          // Pin Control Register fields [15:0] are locked and cannot be updated until the next system reset.
                                                                        // Interrupt Configuration
#define PORT_PCR31_IRQC(_n)                      (((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR31_IRQC_INSERT(_v, _n)               (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define PORT_PCR31_IRQC_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   PORT_PCR31_IRQC_0000                   (uint32_t)0x0          // Interrupt Status Flag (ISF) is disabled.
#define   PORT_PCR31_IRQC_0001                   (uint32_t)0x1          // ISF flag and DMA request on rising edge.
#define   PORT_PCR31_IRQC_0010                   (uint32_t)0x2          // ISF flag and DMA request on falling edge.
#define   PORT_PCR31_IRQC_0011                   (uint32_t)0x3          // ISF flag and DMA request on either edge.
#define   PORT_PCR31_IRQC_1000                   (uint32_t)0x8          // ISF flag and Interrupt when logic 0.
#define   PORT_PCR31_IRQC_1001                   (uint32_t)0x9          // ISF flag and Interrupt on rising-edge.
#define   PORT_PCR31_IRQC_1010                   (uint32_t)0xa          // ISF flag and Interrupt on falling-edge.
#define   PORT_PCR31_IRQC_1011                   (uint32_t)0xb          // ISF flag and Interrupt on either edge.
#define   PORT_PCR31_IRQC_1100                   (uint32_t)0xc          // ISF flag and Interrupt when logic 1.
#define PORT_PCR31_ISF                           ((uint32_t)1 << 24)    // Interrupt Status Flag
#define   PORT_PCR31_ISF_0                       (uint32_t)0x0          // Configured interrupt is not detected.
#define   PORT_PCR31_ISF_1                       (uint32_t)0x1          // Configured interrupt is detected. If the pin is configured to generate a DMA request, then the corresponding flag will be cleared automatically at the completion of the requested DMA transfer. Otherwise, the flag remains set until a logic 1 is written to the flag. If the pin is configured for a level sensitive interrupt and the pin remains asserted, then the flag is set again immediately after it is cleared.

    uint32_t             GPCLR;                                         // Global Pin Control Low Register
                                                                        // Global Pin Write Data
#define PORT_GPCLR_GPWD(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PORT_GPCLR_GPWD_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
                                                                        // Global Pin Write Enable
#define PORT_GPCLR_GPWE(_n)                      (((uint32_t)(_n) & 0xffff) << 16)
#define PORT_GPCLR_GPWE_INSERT(_v, _n)               (((_v) & ~0xffff0000) | ((uint32_t)(_n) & 0xffff) << 16)
#define   PORT_GPCLR_GPWE_0                      (uint32_t)0x0          // Corresponding Pin Control Register is not updated with the value in GPWD.
#define   PORT_GPCLR_GPWE_1                      (uint32_t)0x1          // Corresponding Pin Control Register is updated with the value in GPWD.

    uint32_t             GPCHR;                                         // Global Pin Control High Register
                                                                        // Global Pin Write Data
#define PORT_GPCHR_GPWD(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PORT_GPCHR_GPWD_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
                                                                        // Global Pin Write Enable
#define PORT_GPCHR_GPWE(_n)                      (((uint32_t)(_n) & 0xffff) << 16)
#define PORT_GPCHR_GPWE_INSERT(_v, _n)               (((_v) & ~0xffff0000) | ((uint32_t)(_n) & 0xffff) << 16)
#define   PORT_GPCHR_GPWE_0                      (uint32_t)0x0          // Corresponding Pin Control Register is not updated with the value in GPWD.
#define   PORT_GPCHR_GPWE_1                      (uint32_t)0x1          // Corresponding Pin Control Register is updated with the value in GPWD.

    uint32_t             GICLR;                                         // Global Interrupt Control Low Register
                                                                        // Global Interrupt Write Enable
#define PORT_GICLR_GIWE(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PORT_GICLR_GIWE_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define   PORT_GICLR_GIWE_0                      (uint32_t)0x0          // Corresponding Pin Control Register is not updated with the value in GPWD.
#define   PORT_GICLR_GIWE_1                      (uint32_t)0x1          // Corresponding Pin Control Register is updated with the value in GPWD.
                                                                        // Global Interrupt Write Data
#define PORT_GICLR_GIWD(_n)                      (((uint32_t)(_n) & 0xffff) << 16)
#define PORT_GICLR_GIWD_INSERT(_v, _n)               (((_v) & ~0xffff0000) | ((uint32_t)(_n) & 0xffff) << 16)

    uint32_t             GICHR;                                         // Global Interrupt Control High Register
                                                                        // Global Interrupt Write Enable
#define PORT_GICHR_GIWE(_n)                      (((uint32_t)(_n) & 0xffff) << 0)
#define PORT_GICHR_GIWE_INSERT(_v, _n)               (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define   PORT_GICHR_GIWE_0                      (uint32_t)0x0          // Corresponding Pin Control Register is not updated with the value in GPWD.
#define   PORT_GICHR_GIWE_1                      (uint32_t)0x1          // Corresponding Pin Control Register is updated with the value in GPWD.
                                                                        // Global Interrupt Write Data
#define PORT_GICHR_GIWD(_n)                      (((uint32_t)(_n) & 0xffff) << 16)
#define PORT_GICHR_GIWD_INSERT(_v, _n)               (((_v) & ~0xffff0000) | ((uint32_t)(_n) & 0xffff) << 16)

    uint8_t _res0[16];
    uint32_t             ISFR;                                          // Interrupt Status Flag Register
    uint8_t _res1[28];
    uint32_t             DFER;                                          // Digital Filter Enable Register
    uint32_t             DFCR;                                          // Digital Filter Clock Register
#define PORT_DFCR_CS                             ((uint32_t)1 << 0)     // Clock Source
#define   PORT_DFCR_CS_0                         (uint32_t)0x0          // Digital filters are clocked by the bus clock.
#define   PORT_DFCR_CS_1                         (uint32_t)0x1          // Digital filters are clocked by the LPO clock.

    uint32_t             DFWR;                                          // Digital Filter Width Register
                                                                        // Filter Length
#define PORT_DFWR_FILT(_n)                       (((uint32_t)(_n) & 0x1f) << 0)
#define PORT_DFWR_FILT_INSERT(_v, _n)                (((_v) & ~0x1f) | ((uint32_t)(_n) & 0x1f) << 0)
#define PORT_DFWR_FILT_EXTRACT(_v)                   (((_v) >> 0) & 0x1f)

} PORT_regs_t;
                                                                        // --------------------
                                                                        // Watchdog timer
typedef struct                                                          // --------------------
{
    uint32_t             CS;                                            // Watchdog Control and Status Register
#define WDOG_CS_STOP                             ((uint32_t)1 << 0)     // Stop Enable
#define   WDOG_CS_STOP_0                         (uint32_t)0x0          // Watchdog disabled in chip stop mode.
#define   WDOG_CS_STOP_1                         (uint32_t)0x1          // Watchdog enabled in chip stop mode.
#define WDOG_CS_WAIT                             ((uint32_t)1 << 1)     // Wait Enable
#define   WDOG_CS_WAIT_0                         (uint32_t)0x0          // Watchdog disabled in chip wait mode.
#define   WDOG_CS_WAIT_1                         (uint32_t)0x1          // Watchdog enabled in chip wait mode.
#define WDOG_CS_DBG                              ((uint32_t)1 << 2)     // Debug Enable
#define   WDOG_CS_DBG_0                          (uint32_t)0x0          // Watchdog disabled in chip debug mode.
#define   WDOG_CS_DBG_1                          (uint32_t)0x1          // Watchdog enabled in chip debug mode.
                                                                        // Watchdog Test
#define WDOG_CS_TST(_n)                          (((uint32_t)(_n) & 0x3) << 3)
#define WDOG_CS_TST_INSERT(_v, _n)                   (((_v) & ~0x18) | ((uint32_t)(_n) & 0x3) << 3)
#define WDOG_CS_TST_EXTRACT(_v)                      (((_v) >> 3) & 0x3)
#define   WDOG_CS_TST_00                         (uint32_t)0x0          // Watchdog test mode disabled.
#define   WDOG_CS_TST_01                         (uint32_t)0x1          // Watchdog user mode enabled. (Watchdog test mode disabled.) After testing the watchdog, software should use this setting to indicate that the watchdog is functioning normally in user mode.
#define   WDOG_CS_TST_10                         (uint32_t)0x2          // Watchdog test mode enabled, only the low byte is used. CNT[CNTLOW] is compared with TOVAL[TOVALLOW].
#define   WDOG_CS_TST_11                         (uint32_t)0x3          // Watchdog test mode enabled, only the high byte is used. CNT[CNTHIGH] is compared with TOVAL[TOVALHIGH].
#define WDOG_CS_UPDATE                           ((uint32_t)1 << 5)     // Allow updates
#define   WDOG_CS_UPDATE_0                       (uint32_t)0x0          // Updates not allowed. After the initial configuration, the watchdog cannot be later modified without forcing a reset.
#define   WDOG_CS_UPDATE_1                       (uint32_t)0x1          // Updates allowed. Software can modify the watchdog configuration registers within 8'd128 bus clocks after performing the unlock write sequence.
#define WDOG_CS_INT                              ((uint32_t)1 << 6)     // Watchdog Interrupt
#define   WDOG_CS_INT_0                          (uint32_t)0x0          // Watchdog interrupts are disabled. Watchdog resets are not delayed.
#define   WDOG_CS_INT_1                          (uint32_t)0x1          // Watchdog interrupts are enabled. Watchdog resets are delayed by 8'd128 bus clocks from the interrupt vector fetch.
#define WDOG_CS_EN                               ((uint32_t)1 << 7)     // Watchdog Enable
#define   WDOG_CS_EN_0                           (uint32_t)0x0          // Watchdog disabled.
#define   WDOG_CS_EN_1                           (uint32_t)0x1          // Watchdog enabled.
                                                                        // Watchdog Clock
#define WDOG_CS_CLK(_n)                          (((uint32_t)(_n) & 0x3) << 8)
#define WDOG_CS_CLK_INSERT(_v, _n)                   (((_v) & ~0x300) | ((uint32_t)(_n) & 0x3) << 8)
#define WDOG_CS_CLK_EXTRACT(_v)                      (((_v) >> 8) & 0x3)
#define   WDOG_CS_CLK_00                         (uint32_t)0x0          // Bus clock
#define   WDOG_CS_CLK_01                         (uint32_t)0x1          // LPO clock
#define   WDOG_CS_CLK_10                         (uint32_t)0x2          // INTCLK (internal clock)
#define   WDOG_CS_CLK_11                         (uint32_t)0x3          // ERCLK (external reference clock)
#define WDOG_CS_RCS                              ((uint32_t)1 << 10)    // Reconfiguration Success
#define   WDOG_CS_RCS_0                          (uint32_t)0x0          // Reconfiguring WDOG.
#define   WDOG_CS_RCS_1                          (uint32_t)0x1          // Reconfiguration is successful.
#define WDOG_CS_ULK                              ((uint32_t)1 << 11)    // Unlock status
#define   WDOG_CS_ULK_0                          (uint32_t)0x0          // WDOG is locked.
#define   WDOG_CS_ULK_1                          (uint32_t)0x1          // WDOG is unlocked.
#define WDOG_CS_PRES                             ((uint32_t)1 << 12)    // Watchdog prescaler
#define   WDOG_CS_PRES_0                         (uint32_t)0x0          // 256 prescaler disabled.
#define   WDOG_CS_PRES_1                         (uint32_t)0x1          // 256 prescaler enabled.
#define WDOG_CS_CMD32EN                          ((uint32_t)1 << 13)    // Enables or disables WDOG support for 32-bit (otherwise 16-bit or 8-bit) refresh/unlock command write words
#define   WDOG_CS_CMD32EN_0                      (uint32_t)0x0          // Disables support for 32-bit refresh/unlock command write words. Only 16-bit or 8-bit is supported.
#define   WDOG_CS_CMD32EN_1                      (uint32_t)0x1          // Enables support for 32-bit refresh/unlock command write words. 16-bit or 8-bit is NOT supported.
#define WDOG_CS_FLG                              ((uint32_t)1 << 14)    // Watchdog Interrupt Flag
#define   WDOG_CS_FLG_0                          (uint32_t)0x0          // No interrupt occurred.
#define   WDOG_CS_FLG_1                          (uint32_t)0x1          // An interrupt occurred.
#define WDOG_CS_WIN                              ((uint32_t)1 << 15)    // Watchdog Window
#define   WDOG_CS_WIN_0                          (uint32_t)0x0          // Window mode disabled.
#define   WDOG_CS_WIN_1                          (uint32_t)0x1          // Window mode enabled.

    uint32_t             CNT;                                           // Watchdog Counter Register
                                                                        // Low byte of the Watchdog Counter
#define WDOG_CNT_CNTLOW(_n)                      (((uint32_t)(_n) & 0xff) << 0)
#define WDOG_CNT_CNTLOW_INSERT(_v, _n)               (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define WDOG_CNT_CNTLOW_EXTRACT(_v)                  (((_v) >> 0) & 0xff)
                                                                        // High byte of the Watchdog Counter
#define WDOG_CNT_CNTHIGH(_n)                     (((uint32_t)(_n) & 0xff) << 8)
#define WDOG_CNT_CNTHIGH_INSERT(_v, _n)              (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define WDOG_CNT_CNTHIGH_EXTRACT(_v)                 (((_v) >> 8) & 0xff)

    uint32_t             TOVAL;                                         // Watchdog Timeout Value Register
                                                                        // Low byte of the timeout value
#define WDOG_TOVAL_TOVALLOW(_n)                  (((uint32_t)(_n) & 0xff) << 0)
#define WDOG_TOVAL_TOVALLOW_INSERT(_v, _n)           (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define WDOG_TOVAL_TOVALLOW_EXTRACT(_v)              (((_v) >> 0) & 0xff)
                                                                        // High byte of the timeout value
#define WDOG_TOVAL_TOVALHIGH(_n)                 (((uint32_t)(_n) & 0xff) << 8)
#define WDOG_TOVAL_TOVALHIGH_INSERT(_v, _n)          (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define WDOG_TOVAL_TOVALHIGH_EXTRACT(_v)             (((_v) >> 8) & 0xff)

    uint32_t             WIN;                                           // Watchdog Window Register
                                                                        // Low byte of Watchdog Window
#define WDOG_WIN_WINLOW(_n)                      (((uint32_t)(_n) & 0xff) << 0)
#define WDOG_WIN_WINLOW_INSERT(_v, _n)               (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define WDOG_WIN_WINLOW_EXTRACT(_v)                  (((_v) >> 0) & 0xff)
                                                                        // High byte of Watchdog Window
#define WDOG_WIN_WINHIGH(_n)                     (((uint32_t)(_n) & 0xff) << 8)
#define WDOG_WIN_WINHIGH_INSERT(_v, _n)              (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define WDOG_WIN_WINHIGH_EXTRACT(_v)                 (((_v) >> 8) & 0xff)

} WDOG_regs_t;
                                                                        // --------------------
                                                                        // The FLEXIO Memory Map/Register Definition can be found here.
typedef struct                                                          // --------------------
{
    const uint32_t       VERID;                                         // Version ID Register
                                                                        // Feature Specification Number
#define FLEXIO_VERID_FEATURE_EXTRACT(_v)             (((_v) >> 0) & 0xffff)
#define   FLEXIO_VERID_FEATURE_0000000000000000  (uint32_t)0x0          // Standard features implemented.
#define   FLEXIO_VERID_FEATURE_0000000000000001  (uint32_t)0x1          // Supports state, logic and parallel modes.
                                                                        // Minor Version Number
#define FLEXIO_VERID_MINOR_EXTRACT(_v)               (((_v) >> 16) & 0xff)
                                                                        // Major Version Number
#define FLEXIO_VERID_MAJOR_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    const uint32_t       PARAM;                                         // Parameter Register
                                                                        // Shifter Number
#define FLEXIO_PARAM_SHIFTER_EXTRACT(_v)             (((_v) >> 0) & 0xff)
                                                                        // Timer Number
#define FLEXIO_PARAM_TIMER_EXTRACT(_v)               (((_v) >> 8) & 0xff)
                                                                        // Pin Number
#define FLEXIO_PARAM_PIN_EXTRACT(_v)                 (((_v) >> 16) & 0xff)
                                                                        // Trigger Number
#define FLEXIO_PARAM_TRIGGER_EXTRACT(_v)             (((_v) >> 24) & 0xff)

    uint32_t             CTRL;                                          // FlexIO Control Register
#define FLEXIO_CTRL_FLEXEN                       ((uint32_t)1 << 0)     // FlexIO Enable
#define   FLEXIO_CTRL_FLEXEN_0                   (uint32_t)0x0          // FlexIO module is disabled.
#define   FLEXIO_CTRL_FLEXEN_1                   (uint32_t)0x1          // FlexIO module is enabled.
#define FLEXIO_CTRL_SWRST                        ((uint32_t)1 << 1)     // Software Reset
#define   FLEXIO_CTRL_SWRST_0                    (uint32_t)0x0          // Software reset is disabled
#define   FLEXIO_CTRL_SWRST_1                    (uint32_t)0x1          // Software reset is enabled, all FlexIO registers except the Control Register are reset.
#define FLEXIO_CTRL_FASTACC                      ((uint32_t)1 << 2)     // Fast Access
#define   FLEXIO_CTRL_FASTACC_0                  (uint32_t)0x0          // Configures for normal register accesses to FlexIO
#define   FLEXIO_CTRL_FASTACC_1                  (uint32_t)0x1          // Configures for fast register accesses to FlexIO
#define FLEXIO_CTRL_DBGE                         ((uint32_t)1 << 30)    // Debug Enable
#define   FLEXIO_CTRL_DBGE_0                     (uint32_t)0x0          // FlexIO is disabled in debug modes.
#define   FLEXIO_CTRL_DBGE_1                     (uint32_t)0x1          // FlexIO is enabled in debug modes
#define FLEXIO_CTRL_DOZEN                        ((uint32_t)1 << 31)    // Doze Enable
#define   FLEXIO_CTRL_DOZEN_0                    (uint32_t)0x0          // FlexIO enabled in Doze modes.
#define   FLEXIO_CTRL_DOZEN_1                    (uint32_t)0x1          // FlexIO disabled in Doze modes.

    const uint32_t       PIN;                                           // Pin State Register
                                                                        // Pin Data Input
#define FLEXIO_PIN_PDI_EXTRACT(_v)                   (((_v) >> 0) & 0xff)

    uint32_t             SHIFTSTAT;                                     // Shifter Status Register
                                                                        // Shifter Status Flag
#define FLEXIO_SHIFTSTAT_SSF(_n)                 (((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTSTAT_SSF_INSERT(_v, _n)          (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTSTAT_SSF_EXTRACT(_v)             (((_v) >> 0) & 0xf)

    uint32_t             SHIFTERR;                                      // Shifter Error Register
                                                                        // Shifter Error Flags
#define FLEXIO_SHIFTERR_SEF(_n)                  (((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTERR_SEF_INSERT(_v, _n)           (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTERR_SEF_EXTRACT(_v)              (((_v) >> 0) & 0xf)

    uint32_t             TIMSTAT;                                       // Timer Status Register
                                                                        // Timer Status Flags
#define FLEXIO_TIMSTAT_TSF(_n)                   (((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_TIMSTAT_TSF_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_TIMSTAT_TSF_EXTRACT(_v)               (((_v) >> 0) & 0xf)

    uint8_t _res0[4];
    uint32_t             SHIFTSIEN;                                     // Shifter Status Interrupt Enable
                                                                        // Shifter Status Interrupt Enable
#define FLEXIO_SHIFTSIEN_SSIE(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTSIEN_SSIE_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTSIEN_SSIE_EXTRACT(_v)            (((_v) >> 0) & 0xf)

    uint32_t             SHIFTEIEN;                                     // Shifter Error Interrupt Enable
                                                                        // Shifter Error Interrupt Enable
#define FLEXIO_SHIFTEIEN_SEIE(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTEIEN_SEIE_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTEIEN_SEIE_EXTRACT(_v)            (((_v) >> 0) & 0xf)

    uint32_t             TIMIEN;                                        // Timer Interrupt Enable Register
                                                                        // Timer Status Interrupt Enable
#define FLEXIO_TIMIEN_TEIE(_n)                   (((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_TIMIEN_TEIE_INSERT(_v, _n)            (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_TIMIEN_TEIE_EXTRACT(_v)               (((_v) >> 0) & 0xf)

    uint8_t _res1[4];
    uint32_t             SHIFTSDEN;                                     // Shifter Status DMA Enable
                                                                        // Shifter Status DMA Enable
#define FLEXIO_SHIFTSDEN_SSDE(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTSDEN_SSDE_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define FLEXIO_SHIFTSDEN_SSDE_EXTRACT(_v)            (((_v) >> 0) & 0xf)

    uint8_t _res2[76];
    uint32_t             SHIFTCTL0;                                     // Shifter Control N Register
                                                                        // Shifter Mode
#define FLEXIO_SHIFTCTL0_SMOD(_n)                (((uint32_t)(_n) & 0x7) << 0)
#define FLEXIO_SHIFTCTL0_SMOD_INSERT(_v, _n)         (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define FLEXIO_SHIFTCTL0_SMOD_EXTRACT(_v)            (((_v) >> 0) & 0x7)
#define   FLEXIO_SHIFTCTL0_SMOD_0                (uint32_t)0x0          // Disabled.
#define   FLEXIO_SHIFTCTL0_SMOD_1                (uint32_t)0x1          // Receive mode. Captures the current Shifter content into the SHIFTBUF on expiration of the Timer.
#define   FLEXIO_SHIFTCTL0_SMOD_10               (uint32_t)0x2          // Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of the Timer.
#define   FLEXIO_SHIFTCTL0_SMOD_100              (uint32_t)0x4          // Match Store mode. Shifter data is compared to SHIFTBUF content on expiration of the Timer.
#define   FLEXIO_SHIFTCTL0_SMOD_101              (uint32_t)0x5          // Match Continuous mode. Shifter data is continuously compared to SHIFTBUF contents.
#define FLEXIO_SHIFTCTL0_PINPOL                  ((uint32_t)1 << 7)     // Shifter Pin Polarity
#define   FLEXIO_SHIFTCTL0_PINPOL_0              (uint32_t)0x0          // Pin is active high
#define   FLEXIO_SHIFTCTL0_PINPOL_1              (uint32_t)0x1          // Pin is active low
                                                                        // Shifter Pin Select
#define FLEXIO_SHIFTCTL0_PINSEL(_n)              (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_SHIFTCTL0_PINSEL_INSERT(_v, _n)       (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_SHIFTCTL0_PINSEL_EXTRACT(_v)          (((_v) >> 8) & 0x7)
                                                                        // Shifter Pin Configuration
#define FLEXIO_SHIFTCTL0_PINCFG(_n)              (((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_SHIFTCTL0_PINCFG_INSERT(_v, _n)       (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_SHIFTCTL0_PINCFG_EXTRACT(_v)          (((_v) >> 16) & 0x3)
#define   FLEXIO_SHIFTCTL0_PINCFG_0              (uint32_t)0x0          // Shifter pin output disabled
#define   FLEXIO_SHIFTCTL0_PINCFG_1              (uint32_t)0x1          // Shifter pin open drain or bidirectional output enable
#define   FLEXIO_SHIFTCTL0_PINCFG_10             (uint32_t)0x2          // Shifter pin bidirectional output data
#define   FLEXIO_SHIFTCTL0_PINCFG_11             (uint32_t)0x3          // Shifter pin output
#define FLEXIO_SHIFTCTL0_TIMPOL                  ((uint32_t)1 << 23)    // Timer Polarity
#define   FLEXIO_SHIFTCTL0_TIMPOL_0              (uint32_t)0x0          // Shift on posedge of Shift clock
#define   FLEXIO_SHIFTCTL0_TIMPOL_1              (uint32_t)0x1          // Shift on negedge of Shift clock
                                                                        // Timer Select
#define FLEXIO_SHIFTCTL0_TIMSEL(_n)              (((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_SHIFTCTL0_TIMSEL_INSERT(_v, _n)       (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_SHIFTCTL0_TIMSEL_EXTRACT(_v)          (((_v) >> 24) & 0x3)

    uint32_t             SHIFTCTL1;                                     // Shifter Control N Register
                                                                        // Shifter Mode
#define FLEXIO_SHIFTCTL1_SMOD(_n)                (((uint32_t)(_n) & 0x7) << 0)
#define FLEXIO_SHIFTCTL1_SMOD_INSERT(_v, _n)         (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define FLEXIO_SHIFTCTL1_SMOD_EXTRACT(_v)            (((_v) >> 0) & 0x7)
#define   FLEXIO_SHIFTCTL1_SMOD_0                (uint32_t)0x0          // Disabled.
#define   FLEXIO_SHIFTCTL1_SMOD_1                (uint32_t)0x1          // Receive mode. Captures the current Shifter content into the SHIFTBUF on expiration of the Timer.
#define   FLEXIO_SHIFTCTL1_SMOD_10               (uint32_t)0x2          // Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of the Timer.
#define   FLEXIO_SHIFTCTL1_SMOD_100              (uint32_t)0x4          // Match Store mode. Shifter data is compared to SHIFTBUF content on expiration of the Timer.
#define   FLEXIO_SHIFTCTL1_SMOD_101              (uint32_t)0x5          // Match Continuous mode. Shifter data is continuously compared to SHIFTBUF contents.
#define FLEXIO_SHIFTCTL1_PINPOL                  ((uint32_t)1 << 7)     // Shifter Pin Polarity
#define   FLEXIO_SHIFTCTL1_PINPOL_0              (uint32_t)0x0          // Pin is active high
#define   FLEXIO_SHIFTCTL1_PINPOL_1              (uint32_t)0x1          // Pin is active low
                                                                        // Shifter Pin Select
#define FLEXIO_SHIFTCTL1_PINSEL(_n)              (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_SHIFTCTL1_PINSEL_INSERT(_v, _n)       (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_SHIFTCTL1_PINSEL_EXTRACT(_v)          (((_v) >> 8) & 0x7)
                                                                        // Shifter Pin Configuration
#define FLEXIO_SHIFTCTL1_PINCFG(_n)              (((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_SHIFTCTL1_PINCFG_INSERT(_v, _n)       (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_SHIFTCTL1_PINCFG_EXTRACT(_v)          (((_v) >> 16) & 0x3)
#define   FLEXIO_SHIFTCTL1_PINCFG_0              (uint32_t)0x0          // Shifter pin output disabled
#define   FLEXIO_SHIFTCTL1_PINCFG_1              (uint32_t)0x1          // Shifter pin open drain or bidirectional output enable
#define   FLEXIO_SHIFTCTL1_PINCFG_10             (uint32_t)0x2          // Shifter pin bidirectional output data
#define   FLEXIO_SHIFTCTL1_PINCFG_11             (uint32_t)0x3          // Shifter pin output
#define FLEXIO_SHIFTCTL1_TIMPOL                  ((uint32_t)1 << 23)    // Timer Polarity
#define   FLEXIO_SHIFTCTL1_TIMPOL_0              (uint32_t)0x0          // Shift on posedge of Shift clock
#define   FLEXIO_SHIFTCTL1_TIMPOL_1              (uint32_t)0x1          // Shift on negedge of Shift clock
                                                                        // Timer Select
#define FLEXIO_SHIFTCTL1_TIMSEL(_n)              (((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_SHIFTCTL1_TIMSEL_INSERT(_v, _n)       (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_SHIFTCTL1_TIMSEL_EXTRACT(_v)          (((_v) >> 24) & 0x3)

    uint32_t             SHIFTCTL2;                                     // Shifter Control N Register
                                                                        // Shifter Mode
#define FLEXIO_SHIFTCTL2_SMOD(_n)                (((uint32_t)(_n) & 0x7) << 0)
#define FLEXIO_SHIFTCTL2_SMOD_INSERT(_v, _n)         (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define FLEXIO_SHIFTCTL2_SMOD_EXTRACT(_v)            (((_v) >> 0) & 0x7)
#define   FLEXIO_SHIFTCTL2_SMOD_0                (uint32_t)0x0          // Disabled.
#define   FLEXIO_SHIFTCTL2_SMOD_1                (uint32_t)0x1          // Receive mode. Captures the current Shifter content into the SHIFTBUF on expiration of the Timer.
#define   FLEXIO_SHIFTCTL2_SMOD_10               (uint32_t)0x2          // Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of the Timer.
#define   FLEXIO_SHIFTCTL2_SMOD_100              (uint32_t)0x4          // Match Store mode. Shifter data is compared to SHIFTBUF content on expiration of the Timer.
#define   FLEXIO_SHIFTCTL2_SMOD_101              (uint32_t)0x5          // Match Continuous mode. Shifter data is continuously compared to SHIFTBUF contents.
#define FLEXIO_SHIFTCTL2_PINPOL                  ((uint32_t)1 << 7)     // Shifter Pin Polarity
#define   FLEXIO_SHIFTCTL2_PINPOL_0              (uint32_t)0x0          // Pin is active high
#define   FLEXIO_SHIFTCTL2_PINPOL_1              (uint32_t)0x1          // Pin is active low
                                                                        // Shifter Pin Select
#define FLEXIO_SHIFTCTL2_PINSEL(_n)              (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_SHIFTCTL2_PINSEL_INSERT(_v, _n)       (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_SHIFTCTL2_PINSEL_EXTRACT(_v)          (((_v) >> 8) & 0x7)
                                                                        // Shifter Pin Configuration
#define FLEXIO_SHIFTCTL2_PINCFG(_n)              (((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_SHIFTCTL2_PINCFG_INSERT(_v, _n)       (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_SHIFTCTL2_PINCFG_EXTRACT(_v)          (((_v) >> 16) & 0x3)
#define   FLEXIO_SHIFTCTL2_PINCFG_0              (uint32_t)0x0          // Shifter pin output disabled
#define   FLEXIO_SHIFTCTL2_PINCFG_1              (uint32_t)0x1          // Shifter pin open drain or bidirectional output enable
#define   FLEXIO_SHIFTCTL2_PINCFG_10             (uint32_t)0x2          // Shifter pin bidirectional output data
#define   FLEXIO_SHIFTCTL2_PINCFG_11             (uint32_t)0x3          // Shifter pin output
#define FLEXIO_SHIFTCTL2_TIMPOL                  ((uint32_t)1 << 23)    // Timer Polarity
#define   FLEXIO_SHIFTCTL2_TIMPOL_0              (uint32_t)0x0          // Shift on posedge of Shift clock
#define   FLEXIO_SHIFTCTL2_TIMPOL_1              (uint32_t)0x1          // Shift on negedge of Shift clock
                                                                        // Timer Select
#define FLEXIO_SHIFTCTL2_TIMSEL(_n)              (((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_SHIFTCTL2_TIMSEL_INSERT(_v, _n)       (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_SHIFTCTL2_TIMSEL_EXTRACT(_v)          (((_v) >> 24) & 0x3)

    uint32_t             SHIFTCTL3;                                     // Shifter Control N Register
                                                                        // Shifter Mode
#define FLEXIO_SHIFTCTL3_SMOD(_n)                (((uint32_t)(_n) & 0x7) << 0)
#define FLEXIO_SHIFTCTL3_SMOD_INSERT(_v, _n)         (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define FLEXIO_SHIFTCTL3_SMOD_EXTRACT(_v)            (((_v) >> 0) & 0x7)
#define   FLEXIO_SHIFTCTL3_SMOD_0                (uint32_t)0x0          // Disabled.
#define   FLEXIO_SHIFTCTL3_SMOD_1                (uint32_t)0x1          // Receive mode. Captures the current Shifter content into the SHIFTBUF on expiration of the Timer.
#define   FLEXIO_SHIFTCTL3_SMOD_10               (uint32_t)0x2          // Transmit mode. Load SHIFTBUF contents into the Shifter on expiration of the Timer.
#define   FLEXIO_SHIFTCTL3_SMOD_100              (uint32_t)0x4          // Match Store mode. Shifter data is compared to SHIFTBUF content on expiration of the Timer.
#define   FLEXIO_SHIFTCTL3_SMOD_101              (uint32_t)0x5          // Match Continuous mode. Shifter data is continuously compared to SHIFTBUF contents.
#define FLEXIO_SHIFTCTL3_PINPOL                  ((uint32_t)1 << 7)     // Shifter Pin Polarity
#define   FLEXIO_SHIFTCTL3_PINPOL_0              (uint32_t)0x0          // Pin is active high
#define   FLEXIO_SHIFTCTL3_PINPOL_1              (uint32_t)0x1          // Pin is active low
                                                                        // Shifter Pin Select
#define FLEXIO_SHIFTCTL3_PINSEL(_n)              (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_SHIFTCTL3_PINSEL_INSERT(_v, _n)       (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_SHIFTCTL3_PINSEL_EXTRACT(_v)          (((_v) >> 8) & 0x7)
                                                                        // Shifter Pin Configuration
#define FLEXIO_SHIFTCTL3_PINCFG(_n)              (((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_SHIFTCTL3_PINCFG_INSERT(_v, _n)       (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_SHIFTCTL3_PINCFG_EXTRACT(_v)          (((_v) >> 16) & 0x3)
#define   FLEXIO_SHIFTCTL3_PINCFG_0              (uint32_t)0x0          // Shifter pin output disabled
#define   FLEXIO_SHIFTCTL3_PINCFG_1              (uint32_t)0x1          // Shifter pin open drain or bidirectional output enable
#define   FLEXIO_SHIFTCTL3_PINCFG_10             (uint32_t)0x2          // Shifter pin bidirectional output data
#define   FLEXIO_SHIFTCTL3_PINCFG_11             (uint32_t)0x3          // Shifter pin output
#define FLEXIO_SHIFTCTL3_TIMPOL                  ((uint32_t)1 << 23)    // Timer Polarity
#define   FLEXIO_SHIFTCTL3_TIMPOL_0              (uint32_t)0x0          // Shift on posedge of Shift clock
#define   FLEXIO_SHIFTCTL3_TIMPOL_1              (uint32_t)0x1          // Shift on negedge of Shift clock
                                                                        // Timer Select
#define FLEXIO_SHIFTCTL3_TIMSEL(_n)              (((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_SHIFTCTL3_TIMSEL_INSERT(_v, _n)       (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_SHIFTCTL3_TIMSEL_EXTRACT(_v)          (((_v) >> 24) & 0x3)

    uint8_t _res3[112];
    uint32_t             SHIFTCFG0;                                     // Shifter Configuration N Register
                                                                        // Shifter Start bit
#define FLEXIO_SHIFTCFG0_SSTART(_n)              (((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_SHIFTCFG0_SSTART_INSERT(_v, _n)       (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_SHIFTCFG0_SSTART_EXTRACT(_v)          (((_v) >> 0) & 0x3)
#define   FLEXIO_SHIFTCFG0_SSTART_0              (uint32_t)0x0          // Start bit disabled for transmitter/receiver/match store, transmitter loads data on enable
#define   FLEXIO_SHIFTCFG0_SSTART_1              (uint32_t)0x1          // Start bit disabled for transmitter/receiver/match store, transmitter loads data on first shift
#define   FLEXIO_SHIFTCFG0_SSTART_10             (uint32_t)0x2          // Transmitter outputs start bit value 0 before loading data on first shift, receiver/match store sets error flag if start bit is not 0
#define   FLEXIO_SHIFTCFG0_SSTART_11             (uint32_t)0x3          // Transmitter outputs start bit value 1 before loading data on first shift, receiver/match store sets error flag if start bit is not 1
                                                                        // Shifter Stop bit
#define FLEXIO_SHIFTCFG0_SSTOP(_n)               (((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_SHIFTCFG0_SSTOP_INSERT(_v, _n)        (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_SHIFTCFG0_SSTOP_EXTRACT(_v)           (((_v) >> 4) & 0x3)
#define   FLEXIO_SHIFTCFG0_SSTOP_0               (uint32_t)0x0          // Stop bit disabled for transmitter/receiver/match store
#define   FLEXIO_SHIFTCFG0_SSTOP_1               (uint32_t)0x1          // Reserved for transmitter/receiver/match store
#define   FLEXIO_SHIFTCFG0_SSTOP_10              (uint32_t)0x2          // Transmitter outputs stop bit value 0 on store, receiver/match store sets error flag if stop bit is not 0
#define   FLEXIO_SHIFTCFG0_SSTOP_11              (uint32_t)0x3          // Transmitter outputs stop bit value 1 on store, receiver/match store sets error flag if stop bit is not 1
#define FLEXIO_SHIFTCFG0_INSRC                   ((uint32_t)1 << 8)     // Input Source
#define   FLEXIO_SHIFTCFG0_INSRC_0               (uint32_t)0x0          // Pin
#define   FLEXIO_SHIFTCFG0_INSRC_1               (uint32_t)0x1          // Shifter N+1 Output

    uint32_t             SHIFTCFG1;                                     // Shifter Configuration N Register
                                                                        // Shifter Start bit
#define FLEXIO_SHIFTCFG1_SSTART(_n)              (((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_SHIFTCFG1_SSTART_INSERT(_v, _n)       (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_SHIFTCFG1_SSTART_EXTRACT(_v)          (((_v) >> 0) & 0x3)
#define   FLEXIO_SHIFTCFG1_SSTART_0              (uint32_t)0x0          // Start bit disabled for transmitter/receiver/match store, transmitter loads data on enable
#define   FLEXIO_SHIFTCFG1_SSTART_1              (uint32_t)0x1          // Start bit disabled for transmitter/receiver/match store, transmitter loads data on first shift
#define   FLEXIO_SHIFTCFG1_SSTART_10             (uint32_t)0x2          // Transmitter outputs start bit value 0 before loading data on first shift, receiver/match store sets error flag if start bit is not 0
#define   FLEXIO_SHIFTCFG1_SSTART_11             (uint32_t)0x3          // Transmitter outputs start bit value 1 before loading data on first shift, receiver/match store sets error flag if start bit is not 1
                                                                        // Shifter Stop bit
#define FLEXIO_SHIFTCFG1_SSTOP(_n)               (((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_SHIFTCFG1_SSTOP_INSERT(_v, _n)        (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_SHIFTCFG1_SSTOP_EXTRACT(_v)           (((_v) >> 4) & 0x3)
#define   FLEXIO_SHIFTCFG1_SSTOP_0               (uint32_t)0x0          // Stop bit disabled for transmitter/receiver/match store
#define   FLEXIO_SHIFTCFG1_SSTOP_1               (uint32_t)0x1          // Reserved for transmitter/receiver/match store
#define   FLEXIO_SHIFTCFG1_SSTOP_10              (uint32_t)0x2          // Transmitter outputs stop bit value 0 on store, receiver/match store sets error flag if stop bit is not 0
#define   FLEXIO_SHIFTCFG1_SSTOP_11              (uint32_t)0x3          // Transmitter outputs stop bit value 1 on store, receiver/match store sets error flag if stop bit is not 1
#define FLEXIO_SHIFTCFG1_INSRC                   ((uint32_t)1 << 8)     // Input Source
#define   FLEXIO_SHIFTCFG1_INSRC_0               (uint32_t)0x0          // Pin
#define   FLEXIO_SHIFTCFG1_INSRC_1               (uint32_t)0x1          // Shifter N+1 Output

    uint32_t             SHIFTCFG2;                                     // Shifter Configuration N Register
                                                                        // Shifter Start bit
#define FLEXIO_SHIFTCFG2_SSTART(_n)              (((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_SHIFTCFG2_SSTART_INSERT(_v, _n)       (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_SHIFTCFG2_SSTART_EXTRACT(_v)          (((_v) >> 0) & 0x3)
#define   FLEXIO_SHIFTCFG2_SSTART_0              (uint32_t)0x0          // Start bit disabled for transmitter/receiver/match store, transmitter loads data on enable
#define   FLEXIO_SHIFTCFG2_SSTART_1              (uint32_t)0x1          // Start bit disabled for transmitter/receiver/match store, transmitter loads data on first shift
#define   FLEXIO_SHIFTCFG2_SSTART_10             (uint32_t)0x2          // Transmitter outputs start bit value 0 before loading data on first shift, receiver/match store sets error flag if start bit is not 0
#define   FLEXIO_SHIFTCFG2_SSTART_11             (uint32_t)0x3          // Transmitter outputs start bit value 1 before loading data on first shift, receiver/match store sets error flag if start bit is not 1
                                                                        // Shifter Stop bit
#define FLEXIO_SHIFTCFG2_SSTOP(_n)               (((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_SHIFTCFG2_SSTOP_INSERT(_v, _n)        (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_SHIFTCFG2_SSTOP_EXTRACT(_v)           (((_v) >> 4) & 0x3)
#define   FLEXIO_SHIFTCFG2_SSTOP_0               (uint32_t)0x0          // Stop bit disabled for transmitter/receiver/match store
#define   FLEXIO_SHIFTCFG2_SSTOP_1               (uint32_t)0x1          // Reserved for transmitter/receiver/match store
#define   FLEXIO_SHIFTCFG2_SSTOP_10              (uint32_t)0x2          // Transmitter outputs stop bit value 0 on store, receiver/match store sets error flag if stop bit is not 0
#define   FLEXIO_SHIFTCFG2_SSTOP_11              (uint32_t)0x3          // Transmitter outputs stop bit value 1 on store, receiver/match store sets error flag if stop bit is not 1
#define FLEXIO_SHIFTCFG2_INSRC                   ((uint32_t)1 << 8)     // Input Source
#define   FLEXIO_SHIFTCFG2_INSRC_0               (uint32_t)0x0          // Pin
#define   FLEXIO_SHIFTCFG2_INSRC_1               (uint32_t)0x1          // Shifter N+1 Output

    uint32_t             SHIFTCFG3;                                     // Shifter Configuration N Register
                                                                        // Shifter Start bit
#define FLEXIO_SHIFTCFG3_SSTART(_n)              (((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_SHIFTCFG3_SSTART_INSERT(_v, _n)       (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_SHIFTCFG3_SSTART_EXTRACT(_v)          (((_v) >> 0) & 0x3)
#define   FLEXIO_SHIFTCFG3_SSTART_0              (uint32_t)0x0          // Start bit disabled for transmitter/receiver/match store, transmitter loads data on enable
#define   FLEXIO_SHIFTCFG3_SSTART_1              (uint32_t)0x1          // Start bit disabled for transmitter/receiver/match store, transmitter loads data on first shift
#define   FLEXIO_SHIFTCFG3_SSTART_10             (uint32_t)0x2          // Transmitter outputs start bit value 0 before loading data on first shift, receiver/match store sets error flag if start bit is not 0
#define   FLEXIO_SHIFTCFG3_SSTART_11             (uint32_t)0x3          // Transmitter outputs start bit value 1 before loading data on first shift, receiver/match store sets error flag if start bit is not 1
                                                                        // Shifter Stop bit
#define FLEXIO_SHIFTCFG3_SSTOP(_n)               (((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_SHIFTCFG3_SSTOP_INSERT(_v, _n)        (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_SHIFTCFG3_SSTOP_EXTRACT(_v)           (((_v) >> 4) & 0x3)
#define   FLEXIO_SHIFTCFG3_SSTOP_0               (uint32_t)0x0          // Stop bit disabled for transmitter/receiver/match store
#define   FLEXIO_SHIFTCFG3_SSTOP_1               (uint32_t)0x1          // Reserved for transmitter/receiver/match store
#define   FLEXIO_SHIFTCFG3_SSTOP_10              (uint32_t)0x2          // Transmitter outputs stop bit value 0 on store, receiver/match store sets error flag if stop bit is not 0
#define   FLEXIO_SHIFTCFG3_SSTOP_11              (uint32_t)0x3          // Transmitter outputs stop bit value 1 on store, receiver/match store sets error flag if stop bit is not 1
#define FLEXIO_SHIFTCFG3_INSRC                   ((uint32_t)1 << 8)     // Input Source
#define   FLEXIO_SHIFTCFG3_INSRC_0               (uint32_t)0x0          // Pin
#define   FLEXIO_SHIFTCFG3_INSRC_1               (uint32_t)0x1          // Shifter N+1 Output

    uint8_t _res4[240];
    uint32_t             SHIFTBUF0;                                     // Shifter Buffer N Register
    uint32_t             SHIFTBUF1;                                     // Shifter Buffer N Register
    uint32_t             SHIFTBUF2;                                     // Shifter Buffer N Register
    uint32_t             SHIFTBUF3;                                     // Shifter Buffer N Register
    uint8_t _res5[112];
    uint32_t             SHIFTBUFBIS0;                                  // Shifter Buffer N Bit Swapped Register
    uint32_t             SHIFTBUFBIS1;                                  // Shifter Buffer N Bit Swapped Register
    uint32_t             SHIFTBUFBIS2;                                  // Shifter Buffer N Bit Swapped Register
    uint32_t             SHIFTBUFBIS3;                                  // Shifter Buffer N Bit Swapped Register
    uint8_t _res6[112];
    uint32_t             SHIFTBUFBYS0;                                  // Shifter Buffer N Byte Swapped Register
    uint32_t             SHIFTBUFBYS1;                                  // Shifter Buffer N Byte Swapped Register
    uint32_t             SHIFTBUFBYS2;                                  // Shifter Buffer N Byte Swapped Register
    uint32_t             SHIFTBUFBYS3;                                  // Shifter Buffer N Byte Swapped Register
    uint8_t _res7[112];
    uint32_t             SHIFTBUFBBS0;                                  // Shifter Buffer N Bit Byte Swapped Register
    uint32_t             SHIFTBUFBBS1;                                  // Shifter Buffer N Bit Byte Swapped Register
    uint32_t             SHIFTBUFBBS2;                                  // Shifter Buffer N Bit Byte Swapped Register
    uint32_t             SHIFTBUFBBS3;                                  // Shifter Buffer N Bit Byte Swapped Register
    uint8_t _res8[112];
    uint32_t             TIMCTL0;                                       // Timer Control N Register
                                                                        // Timer Mode
#define FLEXIO_TIMCTL0_TIMOD(_n)                 (((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_TIMCTL0_TIMOD_INSERT(_v, _n)          (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_TIMCTL0_TIMOD_EXTRACT(_v)             (((_v) >> 0) & 0x3)
#define   FLEXIO_TIMCTL0_TIMOD_0                 (uint32_t)0x0          // Timer Disabled.
#define   FLEXIO_TIMCTL0_TIMOD_1                 (uint32_t)0x1          // Dual 8-bit counters baud/bit mode.
#define   FLEXIO_TIMCTL0_TIMOD_10                (uint32_t)0x2          // Dual 8-bit counters PWM mode.
#define   FLEXIO_TIMCTL0_TIMOD_11                (uint32_t)0x3          // Single 16-bit counter mode.
#define FLEXIO_TIMCTL0_PINPOL                    ((uint32_t)1 << 7)     // Timer Pin Polarity
#define   FLEXIO_TIMCTL0_PINPOL_0                (uint32_t)0x0          // Pin is active high
#define   FLEXIO_TIMCTL0_PINPOL_1                (uint32_t)0x1          // Pin is active low
                                                                        // Timer Pin Select
#define FLEXIO_TIMCTL0_PINSEL(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCTL0_PINSEL_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCTL0_PINSEL_EXTRACT(_v)            (((_v) >> 8) & 0x7)
                                                                        // Timer Pin Configuration
#define FLEXIO_TIMCTL0_PINCFG(_n)                (((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_TIMCTL0_PINCFG_INSERT(_v, _n)         (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_TIMCTL0_PINCFG_EXTRACT(_v)            (((_v) >> 16) & 0x3)
#define   FLEXIO_TIMCTL0_PINCFG_0                (uint32_t)0x0          // Timer pin output disabled
#define   FLEXIO_TIMCTL0_PINCFG_1                (uint32_t)0x1          // Timer pin open drain or bidirectional output enable
#define   FLEXIO_TIMCTL0_PINCFG_10               (uint32_t)0x2          // Timer pin bidirectional output data
#define   FLEXIO_TIMCTL0_PINCFG_11               (uint32_t)0x3          // Timer pin output
#define FLEXIO_TIMCTL0_TRGSRC                    ((uint32_t)1 << 22)    // Trigger Source
#define   FLEXIO_TIMCTL0_TRGSRC_0                (uint32_t)0x0          // External trigger selected
#define   FLEXIO_TIMCTL0_TRGSRC_1                (uint32_t)0x1          // Internal trigger selected
#define FLEXIO_TIMCTL0_TRGPOL                    ((uint32_t)1 << 23)    // Trigger Polarity
#define   FLEXIO_TIMCTL0_TRGPOL_0                (uint32_t)0x0          // Trigger active high
#define   FLEXIO_TIMCTL0_TRGPOL_1                (uint32_t)0x1          // Trigger active low
                                                                        // Trigger Select
#define FLEXIO_TIMCTL0_TRGSEL(_n)                (((uint32_t)(_n) & 0xf) << 24)
#define FLEXIO_TIMCTL0_TRGSEL_INSERT(_v, _n)         (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define FLEXIO_TIMCTL0_TRGSEL_EXTRACT(_v)            (((_v) >> 24) & 0xf)

    uint32_t             TIMCTL1;                                       // Timer Control N Register
                                                                        // Timer Mode
#define FLEXIO_TIMCTL1_TIMOD(_n)                 (((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_TIMCTL1_TIMOD_INSERT(_v, _n)          (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_TIMCTL1_TIMOD_EXTRACT(_v)             (((_v) >> 0) & 0x3)
#define   FLEXIO_TIMCTL1_TIMOD_0                 (uint32_t)0x0          // Timer Disabled.
#define   FLEXIO_TIMCTL1_TIMOD_1                 (uint32_t)0x1          // Dual 8-bit counters baud/bit mode.
#define   FLEXIO_TIMCTL1_TIMOD_10                (uint32_t)0x2          // Dual 8-bit counters PWM mode.
#define   FLEXIO_TIMCTL1_TIMOD_11                (uint32_t)0x3          // Single 16-bit counter mode.
#define FLEXIO_TIMCTL1_PINPOL                    ((uint32_t)1 << 7)     // Timer Pin Polarity
#define   FLEXIO_TIMCTL1_PINPOL_0                (uint32_t)0x0          // Pin is active high
#define   FLEXIO_TIMCTL1_PINPOL_1                (uint32_t)0x1          // Pin is active low
                                                                        // Timer Pin Select
#define FLEXIO_TIMCTL1_PINSEL(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCTL1_PINSEL_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCTL1_PINSEL_EXTRACT(_v)            (((_v) >> 8) & 0x7)
                                                                        // Timer Pin Configuration
#define FLEXIO_TIMCTL1_PINCFG(_n)                (((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_TIMCTL1_PINCFG_INSERT(_v, _n)         (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_TIMCTL1_PINCFG_EXTRACT(_v)            (((_v) >> 16) & 0x3)
#define   FLEXIO_TIMCTL1_PINCFG_0                (uint32_t)0x0          // Timer pin output disabled
#define   FLEXIO_TIMCTL1_PINCFG_1                (uint32_t)0x1          // Timer pin open drain or bidirectional output enable
#define   FLEXIO_TIMCTL1_PINCFG_10               (uint32_t)0x2          // Timer pin bidirectional output data
#define   FLEXIO_TIMCTL1_PINCFG_11               (uint32_t)0x3          // Timer pin output
#define FLEXIO_TIMCTL1_TRGSRC                    ((uint32_t)1 << 22)    // Trigger Source
#define   FLEXIO_TIMCTL1_TRGSRC_0                (uint32_t)0x0          // External trigger selected
#define   FLEXIO_TIMCTL1_TRGSRC_1                (uint32_t)0x1          // Internal trigger selected
#define FLEXIO_TIMCTL1_TRGPOL                    ((uint32_t)1 << 23)    // Trigger Polarity
#define   FLEXIO_TIMCTL1_TRGPOL_0                (uint32_t)0x0          // Trigger active high
#define   FLEXIO_TIMCTL1_TRGPOL_1                (uint32_t)0x1          // Trigger active low
                                                                        // Trigger Select
#define FLEXIO_TIMCTL1_TRGSEL(_n)                (((uint32_t)(_n) & 0xf) << 24)
#define FLEXIO_TIMCTL1_TRGSEL_INSERT(_v, _n)         (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define FLEXIO_TIMCTL1_TRGSEL_EXTRACT(_v)            (((_v) >> 24) & 0xf)

    uint32_t             TIMCTL2;                                       // Timer Control N Register
                                                                        // Timer Mode
#define FLEXIO_TIMCTL2_TIMOD(_n)                 (((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_TIMCTL2_TIMOD_INSERT(_v, _n)          (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_TIMCTL2_TIMOD_EXTRACT(_v)             (((_v) >> 0) & 0x3)
#define   FLEXIO_TIMCTL2_TIMOD_0                 (uint32_t)0x0          // Timer Disabled.
#define   FLEXIO_TIMCTL2_TIMOD_1                 (uint32_t)0x1          // Dual 8-bit counters baud/bit mode.
#define   FLEXIO_TIMCTL2_TIMOD_10                (uint32_t)0x2          // Dual 8-bit counters PWM mode.
#define   FLEXIO_TIMCTL2_TIMOD_11                (uint32_t)0x3          // Single 16-bit counter mode.
#define FLEXIO_TIMCTL2_PINPOL                    ((uint32_t)1 << 7)     // Timer Pin Polarity
#define   FLEXIO_TIMCTL2_PINPOL_0                (uint32_t)0x0          // Pin is active high
#define   FLEXIO_TIMCTL2_PINPOL_1                (uint32_t)0x1          // Pin is active low
                                                                        // Timer Pin Select
#define FLEXIO_TIMCTL2_PINSEL(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCTL2_PINSEL_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCTL2_PINSEL_EXTRACT(_v)            (((_v) >> 8) & 0x7)
                                                                        // Timer Pin Configuration
#define FLEXIO_TIMCTL2_PINCFG(_n)                (((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_TIMCTL2_PINCFG_INSERT(_v, _n)         (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_TIMCTL2_PINCFG_EXTRACT(_v)            (((_v) >> 16) & 0x3)
#define   FLEXIO_TIMCTL2_PINCFG_0                (uint32_t)0x0          // Timer pin output disabled
#define   FLEXIO_TIMCTL2_PINCFG_1                (uint32_t)0x1          // Timer pin open drain or bidirectional output enable
#define   FLEXIO_TIMCTL2_PINCFG_10               (uint32_t)0x2          // Timer pin bidirectional output data
#define   FLEXIO_TIMCTL2_PINCFG_11               (uint32_t)0x3          // Timer pin output
#define FLEXIO_TIMCTL2_TRGSRC                    ((uint32_t)1 << 22)    // Trigger Source
#define   FLEXIO_TIMCTL2_TRGSRC_0                (uint32_t)0x0          // External trigger selected
#define   FLEXIO_TIMCTL2_TRGSRC_1                (uint32_t)0x1          // Internal trigger selected
#define FLEXIO_TIMCTL2_TRGPOL                    ((uint32_t)1 << 23)    // Trigger Polarity
#define   FLEXIO_TIMCTL2_TRGPOL_0                (uint32_t)0x0          // Trigger active high
#define   FLEXIO_TIMCTL2_TRGPOL_1                (uint32_t)0x1          // Trigger active low
                                                                        // Trigger Select
#define FLEXIO_TIMCTL2_TRGSEL(_n)                (((uint32_t)(_n) & 0xf) << 24)
#define FLEXIO_TIMCTL2_TRGSEL_INSERT(_v, _n)         (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define FLEXIO_TIMCTL2_TRGSEL_EXTRACT(_v)            (((_v) >> 24) & 0xf)

    uint32_t             TIMCTL3;                                       // Timer Control N Register
                                                                        // Timer Mode
#define FLEXIO_TIMCTL3_TIMOD(_n)                 (((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_TIMCTL3_TIMOD_INSERT(_v, _n)          (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define FLEXIO_TIMCTL3_TIMOD_EXTRACT(_v)             (((_v) >> 0) & 0x3)
#define   FLEXIO_TIMCTL3_TIMOD_0                 (uint32_t)0x0          // Timer Disabled.
#define   FLEXIO_TIMCTL3_TIMOD_1                 (uint32_t)0x1          // Dual 8-bit counters baud/bit mode.
#define   FLEXIO_TIMCTL3_TIMOD_10                (uint32_t)0x2          // Dual 8-bit counters PWM mode.
#define   FLEXIO_TIMCTL3_TIMOD_11                (uint32_t)0x3          // Single 16-bit counter mode.
#define FLEXIO_TIMCTL3_PINPOL                    ((uint32_t)1 << 7)     // Timer Pin Polarity
#define   FLEXIO_TIMCTL3_PINPOL_0                (uint32_t)0x0          // Pin is active high
#define   FLEXIO_TIMCTL3_PINPOL_1                (uint32_t)0x1          // Pin is active low
                                                                        // Timer Pin Select
#define FLEXIO_TIMCTL3_PINSEL(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCTL3_PINSEL_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCTL3_PINSEL_EXTRACT(_v)            (((_v) >> 8) & 0x7)
                                                                        // Timer Pin Configuration
#define FLEXIO_TIMCTL3_PINCFG(_n)                (((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_TIMCTL3_PINCFG_INSERT(_v, _n)         (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define FLEXIO_TIMCTL3_PINCFG_EXTRACT(_v)            (((_v) >> 16) & 0x3)
#define   FLEXIO_TIMCTL3_PINCFG_0                (uint32_t)0x0          // Timer pin output disabled
#define   FLEXIO_TIMCTL3_PINCFG_1                (uint32_t)0x1          // Timer pin open drain or bidirectional output enable
#define   FLEXIO_TIMCTL3_PINCFG_10               (uint32_t)0x2          // Timer pin bidirectional output data
#define   FLEXIO_TIMCTL3_PINCFG_11               (uint32_t)0x3          // Timer pin output
#define FLEXIO_TIMCTL3_TRGSRC                    ((uint32_t)1 << 22)    // Trigger Source
#define   FLEXIO_TIMCTL3_TRGSRC_0                (uint32_t)0x0          // External trigger selected
#define   FLEXIO_TIMCTL3_TRGSRC_1                (uint32_t)0x1          // Internal trigger selected
#define FLEXIO_TIMCTL3_TRGPOL                    ((uint32_t)1 << 23)    // Trigger Polarity
#define   FLEXIO_TIMCTL3_TRGPOL_0                (uint32_t)0x0          // Trigger active high
#define   FLEXIO_TIMCTL3_TRGPOL_1                (uint32_t)0x1          // Trigger active low
                                                                        // Trigger Select
#define FLEXIO_TIMCTL3_TRGSEL(_n)                (((uint32_t)(_n) & 0xf) << 24)
#define FLEXIO_TIMCTL3_TRGSEL_INSERT(_v, _n)         (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define FLEXIO_TIMCTL3_TRGSEL_EXTRACT(_v)            (((_v) >> 24) & 0xf)

    uint8_t _res9[112];
    uint32_t             TIMCFG0;                                       // Timer Configuration N Register
#define FLEXIO_TIMCFG0_TSTART                    ((uint32_t)1 << 1)     // Timer Start Bit
#define   FLEXIO_TIMCFG0_TSTART_0                (uint32_t)0x0          // Start bit disabled
#define   FLEXIO_TIMCFG0_TSTART_1                (uint32_t)0x1          // Start bit enabled
                                                                        // Timer Stop Bit
#define FLEXIO_TIMCFG0_TSTOP(_n)                 (((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_TIMCFG0_TSTOP_INSERT(_v, _n)          (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_TIMCFG0_TSTOP_EXTRACT(_v)             (((_v) >> 4) & 0x3)
#define   FLEXIO_TIMCFG0_TSTOP_0                 (uint32_t)0x0          // Stop bit disabled
#define   FLEXIO_TIMCFG0_TSTOP_1                 (uint32_t)0x1          // Stop bit is enabled on timer compare
#define   FLEXIO_TIMCFG0_TSTOP_10                (uint32_t)0x2          // Stop bit is enabled on timer disable
#define   FLEXIO_TIMCFG0_TSTOP_11                (uint32_t)0x3          // Stop bit is enabled on timer compare and timer disable
                                                                        // Timer Enable
#define FLEXIO_TIMCFG0_TIMENA(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCFG0_TIMENA_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCFG0_TIMENA_EXTRACT(_v)            (((_v) >> 8) & 0x7)
#define   FLEXIO_TIMCFG0_TIMENA_0                (uint32_t)0x0          // Timer always enabled
#define   FLEXIO_TIMCFG0_TIMENA_1                (uint32_t)0x1          // Timer enabled on Timer N-1 enable
#define   FLEXIO_TIMCFG0_TIMENA_10               (uint32_t)0x2          // Timer enabled on Trigger high
#define   FLEXIO_TIMCFG0_TIMENA_11               (uint32_t)0x3          // Timer enabled on Trigger high and Pin high
#define   FLEXIO_TIMCFG0_TIMENA_100              (uint32_t)0x4          // Timer enabled on Pin rising edge
#define   FLEXIO_TIMCFG0_TIMENA_101              (uint32_t)0x5          // Timer enabled on Pin rising edge and Trigger high
#define   FLEXIO_TIMCFG0_TIMENA_110              (uint32_t)0x6          // Timer enabled on Trigger rising edge
#define   FLEXIO_TIMCFG0_TIMENA_111              (uint32_t)0x7          // Timer enabled on Trigger rising or falling edge
                                                                        // Timer Disable
#define FLEXIO_TIMCFG0_TIMDIS(_n)                (((uint32_t)(_n) & 0x7) << 12)
#define FLEXIO_TIMCFG0_TIMDIS_INSERT(_v, _n)         (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define FLEXIO_TIMCFG0_TIMDIS_EXTRACT(_v)            (((_v) >> 12) & 0x7)
#define   FLEXIO_TIMCFG0_TIMDIS_0                (uint32_t)0x0          // Timer never disabled
#define   FLEXIO_TIMCFG0_TIMDIS_1                (uint32_t)0x1          // Timer disabled on Timer N-1 disable
#define   FLEXIO_TIMCFG0_TIMDIS_10               (uint32_t)0x2          // Timer disabled on Timer compare
#define   FLEXIO_TIMCFG0_TIMDIS_11               (uint32_t)0x3          // Timer disabled on Timer compare and Trigger Low
#define   FLEXIO_TIMCFG0_TIMDIS_100              (uint32_t)0x4          // Timer disabled on Pin rising or falling edge
#define   FLEXIO_TIMCFG0_TIMDIS_101              (uint32_t)0x5          // Timer disabled on Pin rising or falling edge provided Trigger is high
#define   FLEXIO_TIMCFG0_TIMDIS_110              (uint32_t)0x6          // Timer disabled on Trigger falling edge
                                                                        // Timer Reset
#define FLEXIO_TIMCFG0_TIMRST(_n)                (((uint32_t)(_n) & 0x7) << 16)
#define FLEXIO_TIMCFG0_TIMRST_INSERT(_v, _n)         (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define FLEXIO_TIMCFG0_TIMRST_EXTRACT(_v)            (((_v) >> 16) & 0x7)
#define   FLEXIO_TIMCFG0_TIMRST_0                (uint32_t)0x0          // Timer never reset
#define   FLEXIO_TIMCFG0_TIMRST_10               (uint32_t)0x2          // Timer reset on Timer Pin equal to Timer Output
#define   FLEXIO_TIMCFG0_TIMRST_11               (uint32_t)0x3          // Timer reset on Timer Trigger equal to Timer Output
#define   FLEXIO_TIMCFG0_TIMRST_100              (uint32_t)0x4          // Timer reset on Timer Pin rising edge
#define   FLEXIO_TIMCFG0_TIMRST_110              (uint32_t)0x6          // Timer reset on Trigger rising edge
#define   FLEXIO_TIMCFG0_TIMRST_111              (uint32_t)0x7          // Timer reset on Trigger rising or falling edge
                                                                        // Timer Decrement
#define FLEXIO_TIMCFG0_TIMDEC(_n)                (((uint32_t)(_n) & 0x3) << 20)
#define FLEXIO_TIMCFG0_TIMDEC_INSERT(_v, _n)         (((_v) & ~0x300000) | ((uint32_t)(_n) & 0x3) << 20)
#define FLEXIO_TIMCFG0_TIMDEC_EXTRACT(_v)            (((_v) >> 20) & 0x3)
#define   FLEXIO_TIMCFG0_TIMDEC_0                (uint32_t)0x0          // Decrement counter on FlexIO clock, Shift clock equals Timer output.
#define   FLEXIO_TIMCFG0_TIMDEC_1                (uint32_t)0x1          // Decrement counter on Trigger input (both edges), Shift clock equals Timer output.
#define   FLEXIO_TIMCFG0_TIMDEC_10               (uint32_t)0x2          // Decrement counter on Pin input (both edges), Shift clock equals Pin input.
#define   FLEXIO_TIMCFG0_TIMDEC_11               (uint32_t)0x3          // Decrement counter on Trigger input (both edges), Shift clock equals Trigger input.
                                                                        // Timer Output
#define FLEXIO_TIMCFG0_TIMOUT(_n)                (((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_TIMCFG0_TIMOUT_INSERT(_v, _n)         (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_TIMCFG0_TIMOUT_EXTRACT(_v)            (((_v) >> 24) & 0x3)
#define   FLEXIO_TIMCFG0_TIMOUT_0                (uint32_t)0x0          // Timer output is logic one when enabled and is not affected by timer reset
#define   FLEXIO_TIMCFG0_TIMOUT_1                (uint32_t)0x1          // Timer output is logic zero when enabled and is not affected by timer reset
#define   FLEXIO_TIMCFG0_TIMOUT_10               (uint32_t)0x2          // Timer output is logic one when enabled and on timer reset
#define   FLEXIO_TIMCFG0_TIMOUT_11               (uint32_t)0x3          // Timer output is logic zero when enabled and on timer reset

    uint32_t             TIMCFG1;                                       // Timer Configuration N Register
#define FLEXIO_TIMCFG1_TSTART                    ((uint32_t)1 << 1)     // Timer Start Bit
#define   FLEXIO_TIMCFG1_TSTART_0                (uint32_t)0x0          // Start bit disabled
#define   FLEXIO_TIMCFG1_TSTART_1                (uint32_t)0x1          // Start bit enabled
                                                                        // Timer Stop Bit
#define FLEXIO_TIMCFG1_TSTOP(_n)                 (((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_TIMCFG1_TSTOP_INSERT(_v, _n)          (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_TIMCFG1_TSTOP_EXTRACT(_v)             (((_v) >> 4) & 0x3)
#define   FLEXIO_TIMCFG1_TSTOP_0                 (uint32_t)0x0          // Stop bit disabled
#define   FLEXIO_TIMCFG1_TSTOP_1                 (uint32_t)0x1          // Stop bit is enabled on timer compare
#define   FLEXIO_TIMCFG1_TSTOP_10                (uint32_t)0x2          // Stop bit is enabled on timer disable
#define   FLEXIO_TIMCFG1_TSTOP_11                (uint32_t)0x3          // Stop bit is enabled on timer compare and timer disable
                                                                        // Timer Enable
#define FLEXIO_TIMCFG1_TIMENA(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCFG1_TIMENA_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCFG1_TIMENA_EXTRACT(_v)            (((_v) >> 8) & 0x7)
#define   FLEXIO_TIMCFG1_TIMENA_0                (uint32_t)0x0          // Timer always enabled
#define   FLEXIO_TIMCFG1_TIMENA_1                (uint32_t)0x1          // Timer enabled on Timer N-1 enable
#define   FLEXIO_TIMCFG1_TIMENA_10               (uint32_t)0x2          // Timer enabled on Trigger high
#define   FLEXIO_TIMCFG1_TIMENA_11               (uint32_t)0x3          // Timer enabled on Trigger high and Pin high
#define   FLEXIO_TIMCFG1_TIMENA_100              (uint32_t)0x4          // Timer enabled on Pin rising edge
#define   FLEXIO_TIMCFG1_TIMENA_101              (uint32_t)0x5          // Timer enabled on Pin rising edge and Trigger high
#define   FLEXIO_TIMCFG1_TIMENA_110              (uint32_t)0x6          // Timer enabled on Trigger rising edge
#define   FLEXIO_TIMCFG1_TIMENA_111              (uint32_t)0x7          // Timer enabled on Trigger rising or falling edge
                                                                        // Timer Disable
#define FLEXIO_TIMCFG1_TIMDIS(_n)                (((uint32_t)(_n) & 0x7) << 12)
#define FLEXIO_TIMCFG1_TIMDIS_INSERT(_v, _n)         (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define FLEXIO_TIMCFG1_TIMDIS_EXTRACT(_v)            (((_v) >> 12) & 0x7)
#define   FLEXIO_TIMCFG1_TIMDIS_0                (uint32_t)0x0          // Timer never disabled
#define   FLEXIO_TIMCFG1_TIMDIS_1                (uint32_t)0x1          // Timer disabled on Timer N-1 disable
#define   FLEXIO_TIMCFG1_TIMDIS_10               (uint32_t)0x2          // Timer disabled on Timer compare
#define   FLEXIO_TIMCFG1_TIMDIS_11               (uint32_t)0x3          // Timer disabled on Timer compare and Trigger Low
#define   FLEXIO_TIMCFG1_TIMDIS_100              (uint32_t)0x4          // Timer disabled on Pin rising or falling edge
#define   FLEXIO_TIMCFG1_TIMDIS_101              (uint32_t)0x5          // Timer disabled on Pin rising or falling edge provided Trigger is high
#define   FLEXIO_TIMCFG1_TIMDIS_110              (uint32_t)0x6          // Timer disabled on Trigger falling edge
                                                                        // Timer Reset
#define FLEXIO_TIMCFG1_TIMRST(_n)                (((uint32_t)(_n) & 0x7) << 16)
#define FLEXIO_TIMCFG1_TIMRST_INSERT(_v, _n)         (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define FLEXIO_TIMCFG1_TIMRST_EXTRACT(_v)            (((_v) >> 16) & 0x7)
#define   FLEXIO_TIMCFG1_TIMRST_0                (uint32_t)0x0          // Timer never reset
#define   FLEXIO_TIMCFG1_TIMRST_10               (uint32_t)0x2          // Timer reset on Timer Pin equal to Timer Output
#define   FLEXIO_TIMCFG1_TIMRST_11               (uint32_t)0x3          // Timer reset on Timer Trigger equal to Timer Output
#define   FLEXIO_TIMCFG1_TIMRST_100              (uint32_t)0x4          // Timer reset on Timer Pin rising edge
#define   FLEXIO_TIMCFG1_TIMRST_110              (uint32_t)0x6          // Timer reset on Trigger rising edge
#define   FLEXIO_TIMCFG1_TIMRST_111              (uint32_t)0x7          // Timer reset on Trigger rising or falling edge
                                                                        // Timer Decrement
#define FLEXIO_TIMCFG1_TIMDEC(_n)                (((uint32_t)(_n) & 0x3) << 20)
#define FLEXIO_TIMCFG1_TIMDEC_INSERT(_v, _n)         (((_v) & ~0x300000) | ((uint32_t)(_n) & 0x3) << 20)
#define FLEXIO_TIMCFG1_TIMDEC_EXTRACT(_v)            (((_v) >> 20) & 0x3)
#define   FLEXIO_TIMCFG1_TIMDEC_0                (uint32_t)0x0          // Decrement counter on FlexIO clock, Shift clock equals Timer output.
#define   FLEXIO_TIMCFG1_TIMDEC_1                (uint32_t)0x1          // Decrement counter on Trigger input (both edges), Shift clock equals Timer output.
#define   FLEXIO_TIMCFG1_TIMDEC_10               (uint32_t)0x2          // Decrement counter on Pin input (both edges), Shift clock equals Pin input.
#define   FLEXIO_TIMCFG1_TIMDEC_11               (uint32_t)0x3          // Decrement counter on Trigger input (both edges), Shift clock equals Trigger input.
                                                                        // Timer Output
#define FLEXIO_TIMCFG1_TIMOUT(_n)                (((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_TIMCFG1_TIMOUT_INSERT(_v, _n)         (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_TIMCFG1_TIMOUT_EXTRACT(_v)            (((_v) >> 24) & 0x3)
#define   FLEXIO_TIMCFG1_TIMOUT_0                (uint32_t)0x0          // Timer output is logic one when enabled and is not affected by timer reset
#define   FLEXIO_TIMCFG1_TIMOUT_1                (uint32_t)0x1          // Timer output is logic zero when enabled and is not affected by timer reset
#define   FLEXIO_TIMCFG1_TIMOUT_10               (uint32_t)0x2          // Timer output is logic one when enabled and on timer reset
#define   FLEXIO_TIMCFG1_TIMOUT_11               (uint32_t)0x3          // Timer output is logic zero when enabled and on timer reset

    uint32_t             TIMCFG2;                                       // Timer Configuration N Register
#define FLEXIO_TIMCFG2_TSTART                    ((uint32_t)1 << 1)     // Timer Start Bit
#define   FLEXIO_TIMCFG2_TSTART_0                (uint32_t)0x0          // Start bit disabled
#define   FLEXIO_TIMCFG2_TSTART_1                (uint32_t)0x1          // Start bit enabled
                                                                        // Timer Stop Bit
#define FLEXIO_TIMCFG2_TSTOP(_n)                 (((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_TIMCFG2_TSTOP_INSERT(_v, _n)          (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_TIMCFG2_TSTOP_EXTRACT(_v)             (((_v) >> 4) & 0x3)
#define   FLEXIO_TIMCFG2_TSTOP_0                 (uint32_t)0x0          // Stop bit disabled
#define   FLEXIO_TIMCFG2_TSTOP_1                 (uint32_t)0x1          // Stop bit is enabled on timer compare
#define   FLEXIO_TIMCFG2_TSTOP_10                (uint32_t)0x2          // Stop bit is enabled on timer disable
#define   FLEXIO_TIMCFG2_TSTOP_11                (uint32_t)0x3          // Stop bit is enabled on timer compare and timer disable
                                                                        // Timer Enable
#define FLEXIO_TIMCFG2_TIMENA(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCFG2_TIMENA_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCFG2_TIMENA_EXTRACT(_v)            (((_v) >> 8) & 0x7)
#define   FLEXIO_TIMCFG2_TIMENA_0                (uint32_t)0x0          // Timer always enabled
#define   FLEXIO_TIMCFG2_TIMENA_1                (uint32_t)0x1          // Timer enabled on Timer N-1 enable
#define   FLEXIO_TIMCFG2_TIMENA_10               (uint32_t)0x2          // Timer enabled on Trigger high
#define   FLEXIO_TIMCFG2_TIMENA_11               (uint32_t)0x3          // Timer enabled on Trigger high and Pin high
#define   FLEXIO_TIMCFG2_TIMENA_100              (uint32_t)0x4          // Timer enabled on Pin rising edge
#define   FLEXIO_TIMCFG2_TIMENA_101              (uint32_t)0x5          // Timer enabled on Pin rising edge and Trigger high
#define   FLEXIO_TIMCFG2_TIMENA_110              (uint32_t)0x6          // Timer enabled on Trigger rising edge
#define   FLEXIO_TIMCFG2_TIMENA_111              (uint32_t)0x7          // Timer enabled on Trigger rising or falling edge
                                                                        // Timer Disable
#define FLEXIO_TIMCFG2_TIMDIS(_n)                (((uint32_t)(_n) & 0x7) << 12)
#define FLEXIO_TIMCFG2_TIMDIS_INSERT(_v, _n)         (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define FLEXIO_TIMCFG2_TIMDIS_EXTRACT(_v)            (((_v) >> 12) & 0x7)
#define   FLEXIO_TIMCFG2_TIMDIS_0                (uint32_t)0x0          // Timer never disabled
#define   FLEXIO_TIMCFG2_TIMDIS_1                (uint32_t)0x1          // Timer disabled on Timer N-1 disable
#define   FLEXIO_TIMCFG2_TIMDIS_10               (uint32_t)0x2          // Timer disabled on Timer compare
#define   FLEXIO_TIMCFG2_TIMDIS_11               (uint32_t)0x3          // Timer disabled on Timer compare and Trigger Low
#define   FLEXIO_TIMCFG2_TIMDIS_100              (uint32_t)0x4          // Timer disabled on Pin rising or falling edge
#define   FLEXIO_TIMCFG2_TIMDIS_101              (uint32_t)0x5          // Timer disabled on Pin rising or falling edge provided Trigger is high
#define   FLEXIO_TIMCFG2_TIMDIS_110              (uint32_t)0x6          // Timer disabled on Trigger falling edge
                                                                        // Timer Reset
#define FLEXIO_TIMCFG2_TIMRST(_n)                (((uint32_t)(_n) & 0x7) << 16)
#define FLEXIO_TIMCFG2_TIMRST_INSERT(_v, _n)         (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define FLEXIO_TIMCFG2_TIMRST_EXTRACT(_v)            (((_v) >> 16) & 0x7)
#define   FLEXIO_TIMCFG2_TIMRST_0                (uint32_t)0x0          // Timer never reset
#define   FLEXIO_TIMCFG2_TIMRST_10               (uint32_t)0x2          // Timer reset on Timer Pin equal to Timer Output
#define   FLEXIO_TIMCFG2_TIMRST_11               (uint32_t)0x3          // Timer reset on Timer Trigger equal to Timer Output
#define   FLEXIO_TIMCFG2_TIMRST_100              (uint32_t)0x4          // Timer reset on Timer Pin rising edge
#define   FLEXIO_TIMCFG2_TIMRST_110              (uint32_t)0x6          // Timer reset on Trigger rising edge
#define   FLEXIO_TIMCFG2_TIMRST_111              (uint32_t)0x7          // Timer reset on Trigger rising or falling edge
                                                                        // Timer Decrement
#define FLEXIO_TIMCFG2_TIMDEC(_n)                (((uint32_t)(_n) & 0x3) << 20)
#define FLEXIO_TIMCFG2_TIMDEC_INSERT(_v, _n)         (((_v) & ~0x300000) | ((uint32_t)(_n) & 0x3) << 20)
#define FLEXIO_TIMCFG2_TIMDEC_EXTRACT(_v)            (((_v) >> 20) & 0x3)
#define   FLEXIO_TIMCFG2_TIMDEC_0                (uint32_t)0x0          // Decrement counter on FlexIO clock, Shift clock equals Timer output.
#define   FLEXIO_TIMCFG2_TIMDEC_1                (uint32_t)0x1          // Decrement counter on Trigger input (both edges), Shift clock equals Timer output.
#define   FLEXIO_TIMCFG2_TIMDEC_10               (uint32_t)0x2          // Decrement counter on Pin input (both edges), Shift clock equals Pin input.
#define   FLEXIO_TIMCFG2_TIMDEC_11               (uint32_t)0x3          // Decrement counter on Trigger input (both edges), Shift clock equals Trigger input.
                                                                        // Timer Output
#define FLEXIO_TIMCFG2_TIMOUT(_n)                (((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_TIMCFG2_TIMOUT_INSERT(_v, _n)         (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_TIMCFG2_TIMOUT_EXTRACT(_v)            (((_v) >> 24) & 0x3)
#define   FLEXIO_TIMCFG2_TIMOUT_0                (uint32_t)0x0          // Timer output is logic one when enabled and is not affected by timer reset
#define   FLEXIO_TIMCFG2_TIMOUT_1                (uint32_t)0x1          // Timer output is logic zero when enabled and is not affected by timer reset
#define   FLEXIO_TIMCFG2_TIMOUT_10               (uint32_t)0x2          // Timer output is logic one when enabled and on timer reset
#define   FLEXIO_TIMCFG2_TIMOUT_11               (uint32_t)0x3          // Timer output is logic zero when enabled and on timer reset

    uint32_t             TIMCFG3;                                       // Timer Configuration N Register
#define FLEXIO_TIMCFG3_TSTART                    ((uint32_t)1 << 1)     // Timer Start Bit
#define   FLEXIO_TIMCFG3_TSTART_0                (uint32_t)0x0          // Start bit disabled
#define   FLEXIO_TIMCFG3_TSTART_1                (uint32_t)0x1          // Start bit enabled
                                                                        // Timer Stop Bit
#define FLEXIO_TIMCFG3_TSTOP(_n)                 (((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_TIMCFG3_TSTOP_INSERT(_v, _n)          (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define FLEXIO_TIMCFG3_TSTOP_EXTRACT(_v)             (((_v) >> 4) & 0x3)
#define   FLEXIO_TIMCFG3_TSTOP_0                 (uint32_t)0x0          // Stop bit disabled
#define   FLEXIO_TIMCFG3_TSTOP_1                 (uint32_t)0x1          // Stop bit is enabled on timer compare
#define   FLEXIO_TIMCFG3_TSTOP_10                (uint32_t)0x2          // Stop bit is enabled on timer disable
#define   FLEXIO_TIMCFG3_TSTOP_11                (uint32_t)0x3          // Stop bit is enabled on timer compare and timer disable
                                                                        // Timer Enable
#define FLEXIO_TIMCFG3_TIMENA(_n)                (((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCFG3_TIMENA_INSERT(_v, _n)         (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define FLEXIO_TIMCFG3_TIMENA_EXTRACT(_v)            (((_v) >> 8) & 0x7)
#define   FLEXIO_TIMCFG3_TIMENA_0                (uint32_t)0x0          // Timer always enabled
#define   FLEXIO_TIMCFG3_TIMENA_1                (uint32_t)0x1          // Timer enabled on Timer N-1 enable
#define   FLEXIO_TIMCFG3_TIMENA_10               (uint32_t)0x2          // Timer enabled on Trigger high
#define   FLEXIO_TIMCFG3_TIMENA_11               (uint32_t)0x3          // Timer enabled on Trigger high and Pin high
#define   FLEXIO_TIMCFG3_TIMENA_100              (uint32_t)0x4          // Timer enabled on Pin rising edge
#define   FLEXIO_TIMCFG3_TIMENA_101              (uint32_t)0x5          // Timer enabled on Pin rising edge and Trigger high
#define   FLEXIO_TIMCFG3_TIMENA_110              (uint32_t)0x6          // Timer enabled on Trigger rising edge
#define   FLEXIO_TIMCFG3_TIMENA_111              (uint32_t)0x7          // Timer enabled on Trigger rising or falling edge
                                                                        // Timer Disable
#define FLEXIO_TIMCFG3_TIMDIS(_n)                (((uint32_t)(_n) & 0x7) << 12)
#define FLEXIO_TIMCFG3_TIMDIS_INSERT(_v, _n)         (((_v) & ~0x7000) | ((uint32_t)(_n) & 0x7) << 12)
#define FLEXIO_TIMCFG3_TIMDIS_EXTRACT(_v)            (((_v) >> 12) & 0x7)
#define   FLEXIO_TIMCFG3_TIMDIS_0                (uint32_t)0x0          // Timer never disabled
#define   FLEXIO_TIMCFG3_TIMDIS_1                (uint32_t)0x1          // Timer disabled on Timer N-1 disable
#define   FLEXIO_TIMCFG3_TIMDIS_10               (uint32_t)0x2          // Timer disabled on Timer compare
#define   FLEXIO_TIMCFG3_TIMDIS_11               (uint32_t)0x3          // Timer disabled on Timer compare and Trigger Low
#define   FLEXIO_TIMCFG3_TIMDIS_100              (uint32_t)0x4          // Timer disabled on Pin rising or falling edge
#define   FLEXIO_TIMCFG3_TIMDIS_101              (uint32_t)0x5          // Timer disabled on Pin rising or falling edge provided Trigger is high
#define   FLEXIO_TIMCFG3_TIMDIS_110              (uint32_t)0x6          // Timer disabled on Trigger falling edge
                                                                        // Timer Reset
#define FLEXIO_TIMCFG3_TIMRST(_n)                (((uint32_t)(_n) & 0x7) << 16)
#define FLEXIO_TIMCFG3_TIMRST_INSERT(_v, _n)         (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define FLEXIO_TIMCFG3_TIMRST_EXTRACT(_v)            (((_v) >> 16) & 0x7)
#define   FLEXIO_TIMCFG3_TIMRST_0                (uint32_t)0x0          // Timer never reset
#define   FLEXIO_TIMCFG3_TIMRST_10               (uint32_t)0x2          // Timer reset on Timer Pin equal to Timer Output
#define   FLEXIO_TIMCFG3_TIMRST_11               (uint32_t)0x3          // Timer reset on Timer Trigger equal to Timer Output
#define   FLEXIO_TIMCFG3_TIMRST_100              (uint32_t)0x4          // Timer reset on Timer Pin rising edge
#define   FLEXIO_TIMCFG3_TIMRST_110              (uint32_t)0x6          // Timer reset on Trigger rising edge
#define   FLEXIO_TIMCFG3_TIMRST_111              (uint32_t)0x7          // Timer reset on Trigger rising or falling edge
                                                                        // Timer Decrement
#define FLEXIO_TIMCFG3_TIMDEC(_n)                (((uint32_t)(_n) & 0x3) << 20)
#define FLEXIO_TIMCFG3_TIMDEC_INSERT(_v, _n)         (((_v) & ~0x300000) | ((uint32_t)(_n) & 0x3) << 20)
#define FLEXIO_TIMCFG3_TIMDEC_EXTRACT(_v)            (((_v) >> 20) & 0x3)
#define   FLEXIO_TIMCFG3_TIMDEC_0                (uint32_t)0x0          // Decrement counter on FlexIO clock, Shift clock equals Timer output.
#define   FLEXIO_TIMCFG3_TIMDEC_1                (uint32_t)0x1          // Decrement counter on Trigger input (both edges), Shift clock equals Timer output.
#define   FLEXIO_TIMCFG3_TIMDEC_10               (uint32_t)0x2          // Decrement counter on Pin input (both edges), Shift clock equals Pin input.
#define   FLEXIO_TIMCFG3_TIMDEC_11               (uint32_t)0x3          // Decrement counter on Trigger input (both edges), Shift clock equals Trigger input.
                                                                        // Timer Output
#define FLEXIO_TIMCFG3_TIMOUT(_n)                (((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_TIMCFG3_TIMOUT_INSERT(_v, _n)         (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define FLEXIO_TIMCFG3_TIMOUT_EXTRACT(_v)            (((_v) >> 24) & 0x3)
#define   FLEXIO_TIMCFG3_TIMOUT_0                (uint32_t)0x0          // Timer output is logic one when enabled and is not affected by timer reset
#define   FLEXIO_TIMCFG3_TIMOUT_1                (uint32_t)0x1          // Timer output is logic zero when enabled and is not affected by timer reset
#define   FLEXIO_TIMCFG3_TIMOUT_10               (uint32_t)0x2          // Timer output is logic one when enabled and on timer reset
#define   FLEXIO_TIMCFG3_TIMOUT_11               (uint32_t)0x3          // Timer output is logic zero when enabled and on timer reset

    uint8_t _res10[112];
    uint32_t             TIMCMP0;                                       // Timer Compare N Register
                                                                        // Timer Compare Value
#define FLEXIO_TIMCMP0_CMP(_n)                   (((uint32_t)(_n) & 0xffff) << 0)
#define FLEXIO_TIMCMP0_CMP_INSERT(_v, _n)            (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FLEXIO_TIMCMP0_CMP_EXTRACT(_v)               (((_v) >> 0) & 0xffff)

    uint32_t             TIMCMP1;                                       // Timer Compare N Register
                                                                        // Timer Compare Value
#define FLEXIO_TIMCMP1_CMP(_n)                   (((uint32_t)(_n) & 0xffff) << 0)
#define FLEXIO_TIMCMP1_CMP_INSERT(_v, _n)            (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FLEXIO_TIMCMP1_CMP_EXTRACT(_v)               (((_v) >> 0) & 0xffff)

    uint32_t             TIMCMP2;                                       // Timer Compare N Register
                                                                        // Timer Compare Value
#define FLEXIO_TIMCMP2_CMP(_n)                   (((uint32_t)(_n) & 0xffff) << 0)
#define FLEXIO_TIMCMP2_CMP_INSERT(_v, _n)            (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FLEXIO_TIMCMP2_CMP_EXTRACT(_v)               (((_v) >> 0) & 0xffff)

    uint32_t             TIMCMP3;                                       // Timer Compare N Register
                                                                        // Timer Compare Value
#define FLEXIO_TIMCMP3_CMP(_n)                   (((uint32_t)(_n) & 0xffff) << 0)
#define FLEXIO_TIMCMP3_CMP_INSERT(_v, _n)            (((_v) & ~0xffff) | ((uint32_t)(_n) & 0xffff) << 0)
#define FLEXIO_TIMCMP3_CMP_EXTRACT(_v)               (((_v) >> 0) & 0xffff)

} FLEXIO_regs_t;
                                                                        // --------------------
                                                                        // External Watchdog Monitor
typedef struct                                                          // --------------------
{
    uint8_t              CTRL;                                          // Control Register
#define EWM_CTRL_EWMEN                           ((uint8_t)1 << 0)      // EWM enable.
#define EWM_CTRL_ASSIN                           ((uint8_t)1 << 1)      // EWM_in's Assertion State Select.
#define EWM_CTRL_INEN                            ((uint8_t)1 << 2)      // Input Enable.
#define EWM_CTRL_INTEN                           ((uint8_t)1 << 3)      // Interrupt Enable.

    uint8_t              SERV;                                          // Service Register
    uint8_t              CMPL;                                          // Compare Low Register
    uint8_t              CMPH;                                          // Compare High Register
    uint8_t _res0[1];
    uint8_t              CLKPRESCALER;                                  // Clock Prescaler Register
} EWM_regs_t;
                                                                        // --------------------
                                                                        // TRGMUX
typedef struct                                                          // --------------------
{
    uint32_t             TRGMUX_DMAMUX0;                                // TRGMUX DMAMUX0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_DMAMUX0_SEL0(_n)           (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_DMAMUX0_SEL0_INSERT(_v, _n)    (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_DMAMUX0_SEL0_EXTRACT(_v)       (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_DMAMUX0_SEL1(_n)           (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_DMAMUX0_SEL1_INSERT(_v, _n)    (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_DMAMUX0_SEL1_EXTRACT(_v)       (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_DMAMUX0_SEL2(_n)           (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_DMAMUX0_SEL2_INSERT(_v, _n)    (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_DMAMUX0_SEL2_EXTRACT(_v)       (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_DMAMUX0_SEL3(_n)           (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_DMAMUX0_SEL3_INSERT(_v, _n)    (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_DMAMUX0_SEL3_EXTRACT(_v)       (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_DMAMUX0_LK                 ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_DMAMUX0_LK_0             (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_DMAMUX0_LK_1             (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_EXTOUT0;                                // TRGMUX EXTOUT0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_EXTOUT0_SEL0(_n)           (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_EXTOUT0_SEL0_INSERT(_v, _n)    (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_EXTOUT0_SEL0_EXTRACT(_v)       (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_EXTOUT0_SEL1(_n)           (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_EXTOUT0_SEL1_INSERT(_v, _n)    (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_EXTOUT0_SEL1_EXTRACT(_v)       (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_EXTOUT0_SEL2(_n)           (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_EXTOUT0_SEL2_INSERT(_v, _n)    (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_EXTOUT0_SEL2_EXTRACT(_v)       (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_EXTOUT0_SEL3(_n)           (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_EXTOUT0_SEL3_INSERT(_v, _n)    (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_EXTOUT0_SEL3_EXTRACT(_v)       (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_EXTOUT0_LK                 ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_EXTOUT0_LK_0             (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_EXTOUT0_LK_1             (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_EXTOUT1;                                // TRGMUX EXTOUT1 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_EXTOUT1_SEL0(_n)           (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_EXTOUT1_SEL0_INSERT(_v, _n)    (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_EXTOUT1_SEL0_EXTRACT(_v)       (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_EXTOUT1_SEL1(_n)           (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_EXTOUT1_SEL1_INSERT(_v, _n)    (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_EXTOUT1_SEL1_EXTRACT(_v)       (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_EXTOUT1_SEL2(_n)           (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_EXTOUT1_SEL2_INSERT(_v, _n)    (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_EXTOUT1_SEL2_EXTRACT(_v)       (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_EXTOUT1_SEL3(_n)           (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_EXTOUT1_SEL3_INSERT(_v, _n)    (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_EXTOUT1_SEL3_EXTRACT(_v)       (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_EXTOUT1_LK                 ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_EXTOUT1_LK_0             (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_EXTOUT1_LK_1             (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_ADC0;                                   // TRGMUX ADC0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_ADC0_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_ADC0_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_ADC0_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_ADC0_SEL1(_n)              (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_ADC0_SEL1_INSERT(_v, _n)       (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_ADC0_SEL1_EXTRACT(_v)          (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_ADC0_SEL2(_n)              (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_ADC0_SEL2_INSERT(_v, _n)       (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_ADC0_SEL2_EXTRACT(_v)          (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_ADC0_SEL3(_n)              (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_ADC0_SEL3_INSERT(_v, _n)       (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_ADC0_SEL3_EXTRACT(_v)          (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_ADC0_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_ADC0_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_ADC0_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_ADC1;                                   // TRGMUX ADC1 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_ADC1_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_ADC1_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_ADC1_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_ADC1_SEL1(_n)              (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_ADC1_SEL1_INSERT(_v, _n)       (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_ADC1_SEL1_EXTRACT(_v)          (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_ADC1_SEL2(_n)              (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_ADC1_SEL2_INSERT(_v, _n)       (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_ADC1_SEL2_EXTRACT(_v)          (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_ADC1_SEL3(_n)              (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_ADC1_SEL3_INSERT(_v, _n)       (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_ADC1_SEL3_EXTRACT(_v)          (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_ADC1_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_ADC1_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_ADC1_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint8_t _res0[8];
    uint32_t             TRGMUX_CMP0;                                   // TRGMUX CMP0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_CMP0_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_CMP0_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_CMP0_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_CMP0_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_CMP0_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_CMP0_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint8_t _res1[8];
    uint32_t             TRGMUX_FTM0;                                   // TRGMUX FTM0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_FTM0_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FTM0_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FTM0_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_FTM0_SEL1(_n)              (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FTM0_SEL1_INSERT(_v, _n)       (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FTM0_SEL1_EXTRACT(_v)          (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_FTM0_SEL2(_n)              (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FTM0_SEL2_INSERT(_v, _n)       (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FTM0_SEL2_EXTRACT(_v)          (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_FTM0_SEL3(_n)              (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FTM0_SEL3_INSERT(_v, _n)       (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FTM0_SEL3_EXTRACT(_v)          (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_FTM0_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_FTM0_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_FTM0_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_FTM1;                                   // TRGMUX FTM1 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_FTM1_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FTM1_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FTM1_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_FTM1_SEL1(_n)              (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FTM1_SEL1_INSERT(_v, _n)       (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FTM1_SEL1_EXTRACT(_v)          (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_FTM1_SEL2(_n)              (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FTM1_SEL2_INSERT(_v, _n)       (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FTM1_SEL2_EXTRACT(_v)          (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_FTM1_SEL3(_n)              (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FTM1_SEL3_INSERT(_v, _n)       (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FTM1_SEL3_EXTRACT(_v)          (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_FTM1_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_FTM1_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_FTM1_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_FTM2;                                   // TRGMUX FTM2 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_FTM2_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FTM2_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FTM2_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_FTM2_SEL1(_n)              (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FTM2_SEL1_INSERT(_v, _n)       (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FTM2_SEL1_EXTRACT(_v)          (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_FTM2_SEL2(_n)              (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FTM2_SEL2_INSERT(_v, _n)       (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FTM2_SEL2_EXTRACT(_v)          (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_FTM2_SEL3(_n)              (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FTM2_SEL3_INSERT(_v, _n)       (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FTM2_SEL3_EXTRACT(_v)          (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_FTM2_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_FTM2_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_FTM2_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_FTM3;                                   // TRGMUX FTM3 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_FTM3_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FTM3_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FTM3_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_FTM3_SEL1(_n)              (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FTM3_SEL1_INSERT(_v, _n)       (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FTM3_SEL1_EXTRACT(_v)          (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_FTM3_SEL2(_n)              (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FTM3_SEL2_INSERT(_v, _n)       (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FTM3_SEL2_EXTRACT(_v)          (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_FTM3_SEL3(_n)              (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FTM3_SEL3_INSERT(_v, _n)       (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FTM3_SEL3_EXTRACT(_v)          (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_FTM3_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_FTM3_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_FTM3_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_PDB0;                                   // TRGMUX PDB0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_PDB0_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_PDB0_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_PDB0_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_PDB0_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_PDB0_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_PDB0_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_PDB1;                                   // TRGMUX PDB1 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_PDB1_SEL0(_n)              (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_PDB1_SEL0_INSERT(_v, _n)       (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_PDB1_SEL0_EXTRACT(_v)          (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_PDB1_LK                    ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_PDB1_LK_0                (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_PDB1_LK_1                (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint8_t _res2[4];
    uint32_t             TRGMUX_FLEXIO;                                 // TRGMUX FLEXIO Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_FLEXIO_SEL0(_n)            (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FLEXIO_SEL0_INSERT(_v, _n)     (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_FLEXIO_SEL0_EXTRACT(_v)        (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_FLEXIO_SEL1(_n)            (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FLEXIO_SEL1_INSERT(_v, _n)     (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_FLEXIO_SEL1_EXTRACT(_v)        (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_FLEXIO_SEL2(_n)            (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FLEXIO_SEL2_INSERT(_v, _n)     (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_FLEXIO_SEL2_EXTRACT(_v)        (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_FLEXIO_SEL3(_n)            (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FLEXIO_SEL3_INSERT(_v, _n)     (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_FLEXIO_SEL3_EXTRACT(_v)        (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_FLEXIO_LK                  ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_FLEXIO_LK_0              (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_FLEXIO_LK_1              (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_LPIT0;                                  // TRGMUX LPIT0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_LPIT0_SEL0(_n)             (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPIT0_SEL0_INSERT(_v, _n)      (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPIT0_SEL0_EXTRACT(_v)         (((_v) >> 0) & 0x3f)
                                                                        // Trigger MUX Input 1 Source Select
#define TRGMUX_TRGMUX_LPIT0_SEL1(_n)             (((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_LPIT0_SEL1_INSERT(_v, _n)      (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define TRGMUX_TRGMUX_LPIT0_SEL1_EXTRACT(_v)         (((_v) >> 8) & 0x3f)
                                                                        // Trigger MUX Input 2 Source Select
#define TRGMUX_TRGMUX_LPIT0_SEL2(_n)             (((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_LPIT0_SEL2_INSERT(_v, _n)      (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define TRGMUX_TRGMUX_LPIT0_SEL2_EXTRACT(_v)         (((_v) >> 16) & 0x3f)
                                                                        // Trigger MUX Input 3 Source Select
#define TRGMUX_TRGMUX_LPIT0_SEL3(_n)             (((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_LPIT0_SEL3_INSERT(_v, _n)      (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define TRGMUX_TRGMUX_LPIT0_SEL3_EXTRACT(_v)         (((_v) >> 24) & 0x3f)
#define TRGMUX_TRGMUX_LPIT0_LK                   ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_LPIT0_LK_0               (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_LPIT0_LK_1               (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_LPUART0;                                // TRGMUX LPUART0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_LPUART0_SEL0(_n)           (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPUART0_SEL0_INSERT(_v, _n)    (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPUART0_SEL0_EXTRACT(_v)       (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_LPUART0_LK                 ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_LPUART0_LK_0             (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_LPUART0_LK_1             (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_LPUART1;                                // TRGMUX LPUART1 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_LPUART1_SEL0(_n)           (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPUART1_SEL0_INSERT(_v, _n)    (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPUART1_SEL0_EXTRACT(_v)       (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_LPUART1_LK                 ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_LPUART1_LK_0             (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_LPUART1_LK_1             (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_LPI2C0;                                 // TRGMUX LPI2C0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_LPI2C0_SEL0(_n)            (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPI2C0_SEL0_INSERT(_v, _n)     (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPI2C0_SEL0_EXTRACT(_v)        (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_LPI2C0_LK                  ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_LPI2C0_LK_0              (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_LPI2C0_LK_1              (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint8_t _res3[4];
    uint32_t             TRGMUX_LPSPI0;                                 // TRGMUX LPSPI0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_LPSPI0_SEL0(_n)            (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPSPI0_SEL0_INSERT(_v, _n)     (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPSPI0_SEL0_EXTRACT(_v)        (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_LPSPI0_LK                  ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_LPSPI0_LK_0              (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_LPSPI0_LK_1              (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_LPSPI1;                                 // TRGMUX LPSPI1 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_LPSPI1_SEL0(_n)            (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPSPI1_SEL0_INSERT(_v, _n)     (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPSPI1_SEL0_EXTRACT(_v)        (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_LPSPI1_LK                  ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_LPSPI1_LK_0              (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_LPSPI1_LK_1              (uint32_t)0x1          // Register cannot be written until the next system Reset.

    uint32_t             TRGMUX_LPTMR0;                                 // TRGMUX LPTMR0 Register
                                                                        // Trigger MUX Input 0 Source Select
#define TRGMUX_TRGMUX_LPTMR0_SEL0(_n)            (((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPTMR0_SEL0_INSERT(_v, _n)     (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define TRGMUX_TRGMUX_LPTMR0_SEL0_EXTRACT(_v)        (((_v) >> 0) & 0x3f)
#define TRGMUX_TRGMUX_LPTMR0_LK                  ((uint32_t)1 << 31)    // TRGMUX register lock.
#define   TRGMUX_TRGMUX_LPTMR0_LK_0              (uint32_t)0x0          // Register can be written.
#define   TRGMUX_TRGMUX_LPTMR0_LK_1              (uint32_t)0x1          // Register cannot be written until the next system Reset.

} TRGMUX_regs_t;
                                                                        // --------------------
                                                                        // System Clock Generator
typedef struct                                                          // --------------------
{
    const uint32_t       VERID;                                         // Version ID Register
    const uint32_t       PARAM;                                         // Parameter Register
                                                                        // Clock Present
#define SCG_PARAM_CLKPRES_EXTRACT(_v)                (((_v) >> 0) & 0xff)
                                                                        // Divider Present
#define SCG_PARAM_DIVPRES_EXTRACT(_v)                (((_v) >> 27) & 0x1f)

    uint8_t _res0[8];
    const uint32_t       CSR;                                           // Clock Status Register
                                                                        // Slow Clock Divide Ratio
#define SCG_CSR_DIVSLOW_EXTRACT(_v)                  (((_v) >> 0) & 0xf)
#define   SCG_CSR_DIVSLOW_0000                   (uint32_t)0x0          // Divide-by-1
#define   SCG_CSR_DIVSLOW_0001                   (uint32_t)0x1          // Divide-by-2
#define   SCG_CSR_DIVSLOW_0010                   (uint32_t)0x2          // Divide-by-3
#define   SCG_CSR_DIVSLOW_0011                   (uint32_t)0x3          // Divide-by-4
#define   SCG_CSR_DIVSLOW_0100                   (uint32_t)0x4          // Divide-by-5
#define   SCG_CSR_DIVSLOW_0101                   (uint32_t)0x5          // Divide-by-6
#define   SCG_CSR_DIVSLOW_0110                   (uint32_t)0x6          // Divide-by-7
#define   SCG_CSR_DIVSLOW_0111                   (uint32_t)0x7          // Divide-by-8
                                                                        // Bus Clock Divide Ratio
#define SCG_CSR_DIVBUS_EXTRACT(_v)                   (((_v) >> 4) & 0xf)
#define   SCG_CSR_DIVBUS_0000                    (uint32_t)0x0          // Divide-by-1
#define   SCG_CSR_DIVBUS_0001                    (uint32_t)0x1          // Divide-by-2
#define   SCG_CSR_DIVBUS_0010                    (uint32_t)0x2          // Divide-by-3
#define   SCG_CSR_DIVBUS_0011                    (uint32_t)0x3          // Divide-by-4
#define   SCG_CSR_DIVBUS_0100                    (uint32_t)0x4          // Divide-by-5
#define   SCG_CSR_DIVBUS_0101                    (uint32_t)0x5          // Divide-by-6
#define   SCG_CSR_DIVBUS_0110                    (uint32_t)0x6          // Divide-by-7
#define   SCG_CSR_DIVBUS_0111                    (uint32_t)0x7          // Divide-by-8
#define   SCG_CSR_DIVBUS_1000                    (uint32_t)0x8          // Divide-by-9
#define   SCG_CSR_DIVBUS_1001                    (uint32_t)0x9          // Divide-by-10
#define   SCG_CSR_DIVBUS_1010                    (uint32_t)0xa          // Divide-by-11
#define   SCG_CSR_DIVBUS_1011                    (uint32_t)0xb          // Divide-by-12
#define   SCG_CSR_DIVBUS_1100                    (uint32_t)0xc          // Divide-by-13
#define   SCG_CSR_DIVBUS_1101                    (uint32_t)0xd          // Divide-by-14
#define   SCG_CSR_DIVBUS_1110                    (uint32_t)0xe          // Divide-by-15
#define   SCG_CSR_DIVBUS_1111                    (uint32_t)0xf          // Divide-by-16
                                                                        // Core Clock Divide Ratio
#define SCG_CSR_DIVCORE_EXTRACT(_v)                  (((_v) >> 16) & 0xf)
#define   SCG_CSR_DIVCORE_0000                   (uint32_t)0x0          // Divide-by-1
#define   SCG_CSR_DIVCORE_0001                   (uint32_t)0x1          // Divide-by-2
#define   SCG_CSR_DIVCORE_0010                   (uint32_t)0x2          // Divide-by-3
#define   SCG_CSR_DIVCORE_0011                   (uint32_t)0x3          // Divide-by-4
#define   SCG_CSR_DIVCORE_0100                   (uint32_t)0x4          // Divide-by-5
#define   SCG_CSR_DIVCORE_0101                   (uint32_t)0x5          // Divide-by-6
#define   SCG_CSR_DIVCORE_0110                   (uint32_t)0x6          // Divide-by-7
#define   SCG_CSR_DIVCORE_0111                   (uint32_t)0x7          // Divide-by-8
#define   SCG_CSR_DIVCORE_1000                   (uint32_t)0x8          // Divide-by-9
#define   SCG_CSR_DIVCORE_1001                   (uint32_t)0x9          // Divide-by-10
#define   SCG_CSR_DIVCORE_1010                   (uint32_t)0xa          // Divide-by-11
#define   SCG_CSR_DIVCORE_1011                   (uint32_t)0xb          // Divide-by-12
#define   SCG_CSR_DIVCORE_1100                   (uint32_t)0xc          // Divide-by-13
#define   SCG_CSR_DIVCORE_1101                   (uint32_t)0xd          // Divide-by-14
#define   SCG_CSR_DIVCORE_1110                   (uint32_t)0xe          // Divide-by-15
#define   SCG_CSR_DIVCORE_1111                   (uint32_t)0xf          // Divide-by-16
                                                                        // System Clock Source
#define SCG_CSR_SCS_EXTRACT(_v)                      (((_v) >> 24) & 0xf)
#define   SCG_CSR_SCS_0001                       (uint32_t)0x1          // System OSC (SOSC_CLK)
#define   SCG_CSR_SCS_0010                       (uint32_t)0x2          // Slow IRC (SIRC_CLK)
#define   SCG_CSR_SCS_0011                       (uint32_t)0x3          // Fast IRC (FIRC_CLK)
#define   SCG_CSR_SCS_0110                       (uint32_t)0x6          // System PLL (SPLL_CLK)

    uint32_t             RCCR;                                          // Run Clock Control Register
                                                                        // Slow Clock Divide Ratio
#define SCG_RCCR_DIVSLOW(_n)                     (((uint32_t)(_n) & 0xf) << 0)
#define SCG_RCCR_DIVSLOW_INSERT(_v, _n)              (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define SCG_RCCR_DIVSLOW_EXTRACT(_v)                 (((_v) >> 0) & 0xf)
#define   SCG_RCCR_DIVSLOW_0000                  (uint32_t)0x0          // Divide-by-1
#define   SCG_RCCR_DIVSLOW_0001                  (uint32_t)0x1          // Divide-by-2
#define   SCG_RCCR_DIVSLOW_0010                  (uint32_t)0x2          // Divide-by-3
#define   SCG_RCCR_DIVSLOW_0011                  (uint32_t)0x3          // Divide-by-4
#define   SCG_RCCR_DIVSLOW_0100                  (uint32_t)0x4          // Divide-by-5
#define   SCG_RCCR_DIVSLOW_0101                  (uint32_t)0x5          // Divide-by-6
#define   SCG_RCCR_DIVSLOW_0110                  (uint32_t)0x6          // Divide-by-7
#define   SCG_RCCR_DIVSLOW_0111                  (uint32_t)0x7          // Divide-by-8
                                                                        // Bus Clock Divide Ratio
#define SCG_RCCR_DIVBUS(_n)                      (((uint32_t)(_n) & 0xf) << 4)
#define SCG_RCCR_DIVBUS_INSERT(_v, _n)               (((_v) & ~0xf0) | ((uint32_t)(_n) & 0xf) << 4)
#define SCG_RCCR_DIVBUS_EXTRACT(_v)                  (((_v) >> 4) & 0xf)
#define   SCG_RCCR_DIVBUS_0000                   (uint32_t)0x0          // Divide-by-1
#define   SCG_RCCR_DIVBUS_0001                   (uint32_t)0x1          // Divide-by-2
#define   SCG_RCCR_DIVBUS_0010                   (uint32_t)0x2          // Divide-by-3
#define   SCG_RCCR_DIVBUS_0011                   (uint32_t)0x3          // Divide-by-4
#define   SCG_RCCR_DIVBUS_0100                   (uint32_t)0x4          // Divide-by-5
#define   SCG_RCCR_DIVBUS_0101                   (uint32_t)0x5          // Divide-by-6
#define   SCG_RCCR_DIVBUS_0110                   (uint32_t)0x6          // Divide-by-7
#define   SCG_RCCR_DIVBUS_0111                   (uint32_t)0x7          // Divide-by-8
#define   SCG_RCCR_DIVBUS_1000                   (uint32_t)0x8          // Divide-by-9
#define   SCG_RCCR_DIVBUS_1001                   (uint32_t)0x9          // Divide-by-10
#define   SCG_RCCR_DIVBUS_1010                   (uint32_t)0xa          // Divide-by-11
#define   SCG_RCCR_DIVBUS_1011                   (uint32_t)0xb          // Divide-by-12
#define   SCG_RCCR_DIVBUS_1100                   (uint32_t)0xc          // Divide-by-13
#define   SCG_RCCR_DIVBUS_1101                   (uint32_t)0xd          // Divide-by-14
#define   SCG_RCCR_DIVBUS_1110                   (uint32_t)0xe          // Divide-by-15
#define   SCG_RCCR_DIVBUS_1111                   (uint32_t)0xf          // Divide-by-16
                                                                        // Core Clock Divide Ratio
#define SCG_RCCR_DIVCORE(_n)                     (((uint32_t)(_n) & 0xf) << 16)
#define SCG_RCCR_DIVCORE_INSERT(_v, _n)              (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define SCG_RCCR_DIVCORE_EXTRACT(_v)                 (((_v) >> 16) & 0xf)
#define   SCG_RCCR_DIVCORE_0000                  (uint32_t)0x0          // Divide-by-1
#define   SCG_RCCR_DIVCORE_0001                  (uint32_t)0x1          // Divide-by-2
#define   SCG_RCCR_DIVCORE_0010                  (uint32_t)0x2          // Divide-by-3
#define   SCG_RCCR_DIVCORE_0011                  (uint32_t)0x3          // Divide-by-4
#define   SCG_RCCR_DIVCORE_0100                  (uint32_t)0x4          // Divide-by-5
#define   SCG_RCCR_DIVCORE_0101                  (uint32_t)0x5          // Divide-by-6
#define   SCG_RCCR_DIVCORE_0110                  (uint32_t)0x6          // Divide-by-7
#define   SCG_RCCR_DIVCORE_0111                  (uint32_t)0x7          // Divide-by-8
#define   SCG_RCCR_DIVCORE_1000                  (uint32_t)0x8          // Divide-by-9
#define   SCG_RCCR_DIVCORE_1001                  (uint32_t)0x9          // Divide-by-10
#define   SCG_RCCR_DIVCORE_1010                  (uint32_t)0xa          // Divide-by-11
#define   SCG_RCCR_DIVCORE_1011                  (uint32_t)0xb          // Divide-by-12
#define   SCG_RCCR_DIVCORE_1100                  (uint32_t)0xc          // Divide-by-13
#define   SCG_RCCR_DIVCORE_1101                  (uint32_t)0xd          // Divide-by-14
#define   SCG_RCCR_DIVCORE_1110                  (uint32_t)0xe          // Divide-by-15
#define   SCG_RCCR_DIVCORE_1111                  (uint32_t)0xf          // Divide-by-16
                                                                        // System Clock Source
#define SCG_RCCR_SCS(_n)                         (((uint32_t)(_n) & 0xf) << 24)
#define SCG_RCCR_SCS_INSERT(_v, _n)                  (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define SCG_RCCR_SCS_EXTRACT(_v)                     (((_v) >> 24) & 0xf)
#define   SCG_RCCR_SCS_0001                      (uint32_t)0x1          // System OSC (SOSC_CLK)
#define   SCG_RCCR_SCS_0010                      (uint32_t)0x2          // Slow IRC (SIRC_CLK)
#define   SCG_RCCR_SCS_0011                      (uint32_t)0x3          // Fast IRC (FIRC_CLK)
#define   SCG_RCCR_SCS_0110                      (uint32_t)0x6          // System PLL (SPLL_CLK)

    uint32_t             VCCR;                                          // VLPR Clock Control Register
                                                                        // Slow Clock Divide Ratio
#define SCG_VCCR_DIVSLOW(_n)                     (((uint32_t)(_n) & 0xf) << 0)
#define SCG_VCCR_DIVSLOW_INSERT(_v, _n)              (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define SCG_VCCR_DIVSLOW_EXTRACT(_v)                 (((_v) >> 0) & 0xf)
#define   SCG_VCCR_DIVSLOW_0000                  (uint32_t)0x0          // Divide-by-1
#define   SCG_VCCR_DIVSLOW_0001                  (uint32_t)0x1          // Divide-by-2
#define   SCG_VCCR_DIVSLOW_0010                  (uint32_t)0x2          // Divide-by-3
#define   SCG_VCCR_DIVSLOW_0011                  (uint32_t)0x3          // Divide-by-4
#define   SCG_VCCR_DIVSLOW_0100                  (uint32_t)0x4          // Divide-by-5
#define   SCG_VCCR_DIVSLOW_0101                  (uint32_t)0x5          // Divide-by-6
#define   SCG_VCCR_DIVSLOW_0110                  (uint32_t)0x6          // Divide-by-7
#define   SCG_VCCR_DIVSLOW_0111                  (uint32_t)0x7          // Divide-by-8
                                                                        // Bus Clock Divide Ratio
#define SCG_VCCR_DIVBUS(_n)                      (((uint32_t)(_n) & 0xf) << 4)
#define SCG_VCCR_DIVBUS_INSERT(_v, _n)               (((_v) & ~0xf0) | ((uint32_t)(_n) & 0xf) << 4)
#define SCG_VCCR_DIVBUS_EXTRACT(_v)                  (((_v) >> 4) & 0xf)
#define   SCG_VCCR_DIVBUS_0000                   (uint32_t)0x0          // Divide-by-1
#define   SCG_VCCR_DIVBUS_0001                   (uint32_t)0x1          // Divide-by-2
#define   SCG_VCCR_DIVBUS_0010                   (uint32_t)0x2          // Divide-by-3
#define   SCG_VCCR_DIVBUS_0011                   (uint32_t)0x3          // Divide-by-4
#define   SCG_VCCR_DIVBUS_0100                   (uint32_t)0x4          // Divide-by-5
#define   SCG_VCCR_DIVBUS_0101                   (uint32_t)0x5          // Divide-by-6
#define   SCG_VCCR_DIVBUS_0110                   (uint32_t)0x6          // Divide-by-7
#define   SCG_VCCR_DIVBUS_0111                   (uint32_t)0x7          // Divide-by-8
#define   SCG_VCCR_DIVBUS_1000                   (uint32_t)0x8          // Divide-by-9
#define   SCG_VCCR_DIVBUS_1001                   (uint32_t)0x9          // Divide-by-10
#define   SCG_VCCR_DIVBUS_1010                   (uint32_t)0xa          // Divide-by-11
#define   SCG_VCCR_DIVBUS_1011                   (uint32_t)0xb          // Divide-by-12
#define   SCG_VCCR_DIVBUS_1100                   (uint32_t)0xc          // Divide-by-13
#define   SCG_VCCR_DIVBUS_1101                   (uint32_t)0xd          // Divide-by-14
#define   SCG_VCCR_DIVBUS_1110                   (uint32_t)0xe          // Divide-by-15
#define   SCG_VCCR_DIVBUS_1111                   (uint32_t)0xf          // Divide-by-16
                                                                        // Core Clock Divide Ratio
#define SCG_VCCR_DIVCORE(_n)                     (((uint32_t)(_n) & 0xf) << 16)
#define SCG_VCCR_DIVCORE_INSERT(_v, _n)              (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define SCG_VCCR_DIVCORE_EXTRACT(_v)                 (((_v) >> 16) & 0xf)
#define   SCG_VCCR_DIVCORE_0000                  (uint32_t)0x0          // Divide-by-1
#define   SCG_VCCR_DIVCORE_0001                  (uint32_t)0x1          // Divide-by-2
#define   SCG_VCCR_DIVCORE_0010                  (uint32_t)0x2          // Divide-by-3
#define   SCG_VCCR_DIVCORE_0011                  (uint32_t)0x3          // Divide-by-4
#define   SCG_VCCR_DIVCORE_0100                  (uint32_t)0x4          // Divide-by-5
#define   SCG_VCCR_DIVCORE_0101                  (uint32_t)0x5          // Divide-by-6
#define   SCG_VCCR_DIVCORE_0110                  (uint32_t)0x6          // Divide-by-7
#define   SCG_VCCR_DIVCORE_0111                  (uint32_t)0x7          // Divide-by-8
#define   SCG_VCCR_DIVCORE_1000                  (uint32_t)0x8          // Divide-by-9
#define   SCG_VCCR_DIVCORE_1001                  (uint32_t)0x9          // Divide-by-10
#define   SCG_VCCR_DIVCORE_1010                  (uint32_t)0xa          // Divide-by-11
#define   SCG_VCCR_DIVCORE_1011                  (uint32_t)0xb          // Divide-by-12
#define   SCG_VCCR_DIVCORE_1100                  (uint32_t)0xc          // Divide-by-13
#define   SCG_VCCR_DIVCORE_1101                  (uint32_t)0xd          // Divide-by-14
#define   SCG_VCCR_DIVCORE_1110                  (uint32_t)0xe          // Divide-by-15
#define   SCG_VCCR_DIVCORE_1111                  (uint32_t)0xf          // Divide-by-16
                                                                        // System Clock Source
#define SCG_VCCR_SCS(_n)                         (((uint32_t)(_n) & 0xf) << 24)
#define SCG_VCCR_SCS_INSERT(_v, _n)                  (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define SCG_VCCR_SCS_EXTRACT(_v)                     (((_v) >> 24) & 0xf)
#define   SCG_VCCR_SCS_0010                      (uint32_t)0x2          // Slow IRC (SIRC_CLK)

    uint32_t             HCCR;                                          // HSRUN Clock Control Register
                                                                        // Slow Clock Divide Ratio
#define SCG_HCCR_DIVSLOW(_n)                     (((uint32_t)(_n) & 0xf) << 0)
#define SCG_HCCR_DIVSLOW_INSERT(_v, _n)              (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define SCG_HCCR_DIVSLOW_EXTRACT(_v)                 (((_v) >> 0) & 0xf)
#define   SCG_HCCR_DIVSLOW_0000                  (uint32_t)0x0          // Divide-by-1
#define   SCG_HCCR_DIVSLOW_0001                  (uint32_t)0x1          // Divide-by-2
#define   SCG_HCCR_DIVSLOW_0010                  (uint32_t)0x2          // Divide-by-3
#define   SCG_HCCR_DIVSLOW_0011                  (uint32_t)0x3          // Divide-by-4
#define   SCG_HCCR_DIVSLOW_0100                  (uint32_t)0x4          // Divide-by-5
#define   SCG_HCCR_DIVSLOW_0101                  (uint32_t)0x5          // Divide-by-6
#define   SCG_HCCR_DIVSLOW_0110                  (uint32_t)0x6          // Divide-by-7
#define   SCG_HCCR_DIVSLOW_0111                  (uint32_t)0x7          // Divide-by-8
                                                                        // Bus Clock Divide Ratio
#define SCG_HCCR_DIVBUS(_n)                      (((uint32_t)(_n) & 0xf) << 4)
#define SCG_HCCR_DIVBUS_INSERT(_v, _n)               (((_v) & ~0xf0) | ((uint32_t)(_n) & 0xf) << 4)
#define SCG_HCCR_DIVBUS_EXTRACT(_v)                  (((_v) >> 4) & 0xf)
#define   SCG_HCCR_DIVBUS_0000                   (uint32_t)0x0          // Divide-by-1
#define   SCG_HCCR_DIVBUS_0001                   (uint32_t)0x1          // Divide-by-2
#define   SCG_HCCR_DIVBUS_0010                   (uint32_t)0x2          // Divide-by-3
#define   SCG_HCCR_DIVBUS_0011                   (uint32_t)0x3          // Divide-by-4
#define   SCG_HCCR_DIVBUS_0100                   (uint32_t)0x4          // Divide-by-5
#define   SCG_HCCR_DIVBUS_0101                   (uint32_t)0x5          // Divide-by-6
#define   SCG_HCCR_DIVBUS_0110                   (uint32_t)0x6          // Divide-by-7
#define   SCG_HCCR_DIVBUS_0111                   (uint32_t)0x7          // Divide-by-8
#define   SCG_HCCR_DIVBUS_1000                   (uint32_t)0x8          // Divide-by-9
#define   SCG_HCCR_DIVBUS_1001                   (uint32_t)0x9          // Divide-by-10
#define   SCG_HCCR_DIVBUS_1010                   (uint32_t)0xa          // Divide-by-11
#define   SCG_HCCR_DIVBUS_1011                   (uint32_t)0xb          // Divide-by-12
#define   SCG_HCCR_DIVBUS_1100                   (uint32_t)0xc          // Divide-by-13
#define   SCG_HCCR_DIVBUS_1101                   (uint32_t)0xd          // Divide-by-14
#define   SCG_HCCR_DIVBUS_1110                   (uint32_t)0xe          // Divide-by-15
#define   SCG_HCCR_DIVBUS_1111                   (uint32_t)0xf          // Divide-by-16
                                                                        // Core Clock Divide Ratio
#define SCG_HCCR_DIVCORE(_n)                     (((uint32_t)(_n) & 0xf) << 16)
#define SCG_HCCR_DIVCORE_INSERT(_v, _n)              (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define SCG_HCCR_DIVCORE_EXTRACT(_v)                 (((_v) >> 16) & 0xf)
#define   SCG_HCCR_DIVCORE_0000                  (uint32_t)0x0          // Divide-by-1
#define   SCG_HCCR_DIVCORE_0001                  (uint32_t)0x1          // Divide-by-2
#define   SCG_HCCR_DIVCORE_0010                  (uint32_t)0x2          // Divide-by-3
#define   SCG_HCCR_DIVCORE_0011                  (uint32_t)0x3          // Divide-by-4
#define   SCG_HCCR_DIVCORE_0100                  (uint32_t)0x4          // Divide-by-5
#define   SCG_HCCR_DIVCORE_0101                  (uint32_t)0x5          // Divide-by-6
#define   SCG_HCCR_DIVCORE_0110                  (uint32_t)0x6          // Divide-by-7
#define   SCG_HCCR_DIVCORE_0111                  (uint32_t)0x7          // Divide-by-8
#define   SCG_HCCR_DIVCORE_1000                  (uint32_t)0x8          // Divide-by-9
#define   SCG_HCCR_DIVCORE_1001                  (uint32_t)0x9          // Divide-by-10
#define   SCG_HCCR_DIVCORE_1010                  (uint32_t)0xa          // Divide-by-11
#define   SCG_HCCR_DIVCORE_1011                  (uint32_t)0xb          // Divide-by-12
#define   SCG_HCCR_DIVCORE_1100                  (uint32_t)0xc          // Divide-by-13
#define   SCG_HCCR_DIVCORE_1101                  (uint32_t)0xd          // Divide-by-14
#define   SCG_HCCR_DIVCORE_1110                  (uint32_t)0xe          // Divide-by-15
#define   SCG_HCCR_DIVCORE_1111                  (uint32_t)0xf          // Divide-by-16
                                                                        // System Clock Source
#define SCG_HCCR_SCS(_n)                         (((uint32_t)(_n) & 0xf) << 24)
#define SCG_HCCR_SCS_INSERT(_v, _n)                  (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define SCG_HCCR_SCS_EXTRACT(_v)                     (((_v) >> 24) & 0xf)
#define   SCG_HCCR_SCS_0011                      (uint32_t)0x3          // Fast IRC (FIRC_CLK)
#define   SCG_HCCR_SCS_0110                      (uint32_t)0x6          // System PLL (SPLL_CLK)

    uint32_t             CLKOUTCNFG;                                    // SCG CLKOUT Configuration Register
                                                                        // SCG Clkout Select
#define SCG_CLKOUTCNFG_CLKOUTSEL(_n)             (((uint32_t)(_n) & 0xf) << 24)
#define SCG_CLKOUTCNFG_CLKOUTSEL_INSERT(_v, _n)      (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define SCG_CLKOUTCNFG_CLKOUTSEL_EXTRACT(_v)         (((_v) >> 24) & 0xf)
#define   SCG_CLKOUTCNFG_CLKOUTSEL_0000          (uint32_t)0x0          // SCG SLOW Clock
#define   SCG_CLKOUTCNFG_CLKOUTSEL_0001          (uint32_t)0x1          // System OSC (SOSC_CLK)
#define   SCG_CLKOUTCNFG_CLKOUTSEL_0010          (uint32_t)0x2          // Slow IRC (SIRC_CLK)
#define   SCG_CLKOUTCNFG_CLKOUTSEL_0011          (uint32_t)0x3          // Fast IRC (FIRC_CLK)
#define   SCG_CLKOUTCNFG_CLKOUTSEL_0110          (uint32_t)0x6          // System PLL (SPLL_CLK)

    uint8_t _res1[220];
    uint32_t             SOSCCSR;                                       // System OSC Control Status Register
#define SCG_SOSCCSR_SOSCEN                       ((uint32_t)1 << 0)     // System OSC Enable
#define   SCG_SOSCCSR_SOSCEN_0                   (uint32_t)0x0          // System OSC is disabled
#define   SCG_SOSCCSR_SOSCEN_1                   (uint32_t)0x1          // System OSC is enabled
#define SCG_SOSCCSR_SOSCCM                       ((uint32_t)1 << 16)    // System OSC Clock Monitor
#define   SCG_SOSCCSR_SOSCCM_0                   (uint32_t)0x0          // System OSC Clock Monitor is disabled
#define   SCG_SOSCCSR_SOSCCM_1                   (uint32_t)0x1          // System OSC Clock Monitor is enabled
#define SCG_SOSCCSR_SOSCCMRE                     ((uint32_t)1 << 17)    // System OSC Clock Monitor Reset Enable
#define   SCG_SOSCCSR_SOSCCMRE_0                 (uint32_t)0x0          // Clock Monitor generates interrupt when error detected
#define   SCG_SOSCCSR_SOSCCMRE_1                 (uint32_t)0x1          // Clock Monitor generates reset when error detected
#define SCG_SOSCCSR_LK                           ((uint32_t)1 << 23)    // Lock Register
#define   SCG_SOSCCSR_LK_0                       (uint32_t)0x0          // This Control Status Register can be written.
#define   SCG_SOSCCSR_LK_1                       (uint32_t)0x1          // This Control Status Register cannot be written.
#define SCG_SOSCCSR_SOSCVLD                      ((uint32_t)1 << 24)    // System OSC Valid
#define   SCG_SOSCCSR_SOSCVLD_0                  (uint32_t)0x0          // System OSC is not enabled or clock is not valid
#define   SCG_SOSCCSR_SOSCVLD_1                  (uint32_t)0x1          // System OSC is enabled and output clock is valid
#define SCG_SOSCCSR_SOSCSEL                      ((uint32_t)1 << 25)    // System OSC Selected
#define   SCG_SOSCCSR_SOSCSEL_0                  (uint32_t)0x0          // System OSC is not the system clock source
#define   SCG_SOSCCSR_SOSCSEL_1                  (uint32_t)0x1          // System OSC is the system clock source
#define SCG_SOSCCSR_SOSCERR                      ((uint32_t)1 << 26)    // System OSC Clock Error
#define   SCG_SOSCCSR_SOSCERR_0                  (uint32_t)0x0          // System OSC Clock Monitor is disabled or has not detected an error
#define   SCG_SOSCCSR_SOSCERR_1                  (uint32_t)0x1          // System OSC Clock Monitor is enabled and detected an error

    uint32_t             SOSCDIV;                                       // System OSC Divide Register
                                                                        // System OSC Clock Divide 1
#define SCG_SOSCDIV_SOSCDIV1(_n)                 (((uint32_t)(_n) & 0x7) << 0)
#define SCG_SOSCDIV_SOSCDIV1_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define SCG_SOSCDIV_SOSCDIV1_EXTRACT(_v)             (((_v) >> 0) & 0x7)
#define   SCG_SOSCDIV_SOSCDIV1_000               (uint32_t)0x0          // Output disabled
#define   SCG_SOSCDIV_SOSCDIV1_001               (uint32_t)0x1          // Divide by 1
#define   SCG_SOSCDIV_SOSCDIV1_010               (uint32_t)0x2          // Divide by 2
#define   SCG_SOSCDIV_SOSCDIV1_011               (uint32_t)0x3          // Divide by 4
#define   SCG_SOSCDIV_SOSCDIV1_100               (uint32_t)0x4          // Divide by 8
#define   SCG_SOSCDIV_SOSCDIV1_101               (uint32_t)0x5          // Divide by 16
#define   SCG_SOSCDIV_SOSCDIV1_110               (uint32_t)0x6          // Divide by 32
#define   SCG_SOSCDIV_SOSCDIV1_111               (uint32_t)0x7          // Divide by 64
                                                                        // System OSC Clock Divide 2
#define SCG_SOSCDIV_SOSCDIV2(_n)                 (((uint32_t)(_n) & 0x7) << 8)
#define SCG_SOSCDIV_SOSCDIV2_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define SCG_SOSCDIV_SOSCDIV2_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   SCG_SOSCDIV_SOSCDIV2_000               (uint32_t)0x0          // Output disabled
#define   SCG_SOSCDIV_SOSCDIV2_001               (uint32_t)0x1          // Divide by 1
#define   SCG_SOSCDIV_SOSCDIV2_010               (uint32_t)0x2          // Divide by 2
#define   SCG_SOSCDIV_SOSCDIV2_011               (uint32_t)0x3          // Divide by 4
#define   SCG_SOSCDIV_SOSCDIV2_100               (uint32_t)0x4          // Divide by 8
#define   SCG_SOSCDIV_SOSCDIV2_101               (uint32_t)0x5          // Divide by 16
#define   SCG_SOSCDIV_SOSCDIV2_110               (uint32_t)0x6          // Divide by 32
#define   SCG_SOSCDIV_SOSCDIV2_111               (uint32_t)0x7          // Divide by 64

    uint32_t             SOSCCFG;                                       // System Oscillator Configuration Register
#define SCG_SOSCCFG_EREFS                        ((uint32_t)1 << 2)     // External Reference Select
#define   SCG_SOSCCFG_EREFS_0                    (uint32_t)0x0          // External reference clock selected
#define   SCG_SOSCCFG_EREFS_1                    (uint32_t)0x1          // Internal crystal oscillator of OSC selected.
#define SCG_SOSCCFG_HGO                          ((uint32_t)1 << 3)     // High Gain Oscillator Select
#define   SCG_SOSCCFG_HGO_0                      (uint32_t)0x0          // Configure crystal oscillator for low-gain operation
#define   SCG_SOSCCFG_HGO_1                      (uint32_t)0x1          // Configure crystal oscillator for high-gain operation
                                                                        // System OSC Range Select
#define SCG_SOSCCFG_RANGE(_n)                    (((uint32_t)(_n) & 0x3) << 4)
#define SCG_SOSCCFG_RANGE_INSERT(_v, _n)             (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define SCG_SOSCCFG_RANGE_EXTRACT(_v)                (((_v) >> 4) & 0x3)
#define   SCG_SOSCCFG_RANGE_01                   (uint32_t)0x1          // Low frequency range selected for the crystal oscillator
#define   SCG_SOSCCFG_RANGE_10                   (uint32_t)0x2          // Medium frequency range selected for the crytstal oscillator
#define   SCG_SOSCCFG_RANGE_11                   (uint32_t)0x3          // High frequency range selected for the crystal oscillator

    uint8_t _res2[244];
    uint32_t             SIRCCSR;                                       // Slow IRC Control Status Register
#define SCG_SIRCCSR_SIRCEN                       ((uint32_t)1 << 0)     // Slow IRC Enable
#define   SCG_SIRCCSR_SIRCEN_0                   (uint32_t)0x0          // Slow IRC is disabled
#define   SCG_SIRCCSR_SIRCEN_1                   (uint32_t)0x1          // Slow IRC is enabled
#define SCG_SIRCCSR_SIRCSTEN                     ((uint32_t)1 << 1)     // Slow IRC Stop Enable
#define   SCG_SIRCCSR_SIRCSTEN_0                 (uint32_t)0x0          // Slow IRC is disabled in supported Stop modes
#define   SCG_SIRCCSR_SIRCSTEN_1                 (uint32_t)0x1          // Slow IRC is enabled in supported Stop modes
#define SCG_SIRCCSR_SIRCLPEN                     ((uint32_t)1 << 2)     // Slow IRC Low Power Enable
#define   SCG_SIRCCSR_SIRCLPEN_0                 (uint32_t)0x0          // Slow IRC is disabled in VLP modes
#define   SCG_SIRCCSR_SIRCLPEN_1                 (uint32_t)0x1          // Slow IRC is enabled in VLP modes
#define SCG_SIRCCSR_LK                           ((uint32_t)1 << 23)    // Lock Register
#define   SCG_SIRCCSR_LK_0                       (uint32_t)0x0          // Control Status Register can be written.
#define   SCG_SIRCCSR_LK_1                       (uint32_t)0x1          // Control Status Register cannot be written.
#define SCG_SIRCCSR_SIRCVLD                      ((uint32_t)1 << 24)    // Slow IRC Valid
#define   SCG_SIRCCSR_SIRCVLD_0                  (uint32_t)0x0          // Slow IRC is not enabled or clock is not valid
#define   SCG_SIRCCSR_SIRCVLD_1                  (uint32_t)0x1          // Slow IRC is enabled and output clock is valid
#define SCG_SIRCCSR_SIRCSEL                      ((uint32_t)1 << 25)    // Slow IRC Selected
#define   SCG_SIRCCSR_SIRCSEL_0                  (uint32_t)0x0          // Slow IRC is not the system clock source
#define   SCG_SIRCCSR_SIRCSEL_1                  (uint32_t)0x1          // Slow IRC is the system clock source

    uint32_t             SIRCDIV;                                       // Slow IRC Divide Register
                                                                        // Slow IRC Clock Divide 1
#define SCG_SIRCDIV_SIRCDIV1(_n)                 (((uint32_t)(_n) & 0x7) << 0)
#define SCG_SIRCDIV_SIRCDIV1_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define SCG_SIRCDIV_SIRCDIV1_EXTRACT(_v)             (((_v) >> 0) & 0x7)
#define   SCG_SIRCDIV_SIRCDIV1_000               (uint32_t)0x0          // Output disabled
#define   SCG_SIRCDIV_SIRCDIV1_001               (uint32_t)0x1          // Divide by 1
#define   SCG_SIRCDIV_SIRCDIV1_010               (uint32_t)0x2          // Divide by 2
#define   SCG_SIRCDIV_SIRCDIV1_011               (uint32_t)0x3          // Divide by 4
#define   SCG_SIRCDIV_SIRCDIV1_100               (uint32_t)0x4          // Divide by 8
#define   SCG_SIRCDIV_SIRCDIV1_101               (uint32_t)0x5          // Divide by 16
#define   SCG_SIRCDIV_SIRCDIV1_110               (uint32_t)0x6          // Divide by 32
#define   SCG_SIRCDIV_SIRCDIV1_111               (uint32_t)0x7          // Divide by 64
                                                                        // Slow IRC Clock Divide 2
#define SCG_SIRCDIV_SIRCDIV2(_n)                 (((uint32_t)(_n) & 0x7) << 8)
#define SCG_SIRCDIV_SIRCDIV2_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define SCG_SIRCDIV_SIRCDIV2_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   SCG_SIRCDIV_SIRCDIV2_000               (uint32_t)0x0          // Output disabled
#define   SCG_SIRCDIV_SIRCDIV2_001               (uint32_t)0x1          // Divide by 1
#define   SCG_SIRCDIV_SIRCDIV2_010               (uint32_t)0x2          // Divide by 2
#define   SCG_SIRCDIV_SIRCDIV2_011               (uint32_t)0x3          // Divide by 4
#define   SCG_SIRCDIV_SIRCDIV2_100               (uint32_t)0x4          // Divide by 8
#define   SCG_SIRCDIV_SIRCDIV2_101               (uint32_t)0x5          // Divide by 16
#define   SCG_SIRCDIV_SIRCDIV2_110               (uint32_t)0x6          // Divide by 32
#define   SCG_SIRCDIV_SIRCDIV2_111               (uint32_t)0x7          // Divide by 64

    uint32_t             SIRCCFG;                                       // Slow IRC Configuration Register
#define SCG_SIRCCFG_RANGE                        ((uint32_t)1 << 0)     // Frequency Range
#define   SCG_SIRCCFG_RANGE_0                    (uint32_t)0x0          // Slow IRC low range clock (2 MHz)
#define   SCG_SIRCCFG_RANGE_1                    (uint32_t)0x1          // Slow IRC high range clock (8 MHz )

    uint8_t _res3[244];
    uint32_t             FIRCCSR;                                       // Fast IRC Control Status Register
#define SCG_FIRCCSR_FIRCEN                       ((uint32_t)1 << 0)     // Fast IRC Enable
#define   SCG_FIRCCSR_FIRCEN_0                   (uint32_t)0x0          // Fast IRC is disabled
#define   SCG_FIRCCSR_FIRCEN_1                   (uint32_t)0x1          // Fast IRC is enabled
#define SCG_FIRCCSR_FIRCREGOFF                   ((uint32_t)1 << 3)     // Fast IRC Regulator Enable
#define   SCG_FIRCCSR_FIRCREGOFF_0               (uint32_t)0x0          // Fast IRC Regulator is enabled.
#define   SCG_FIRCCSR_FIRCREGOFF_1               (uint32_t)0x1          // Fast IRC Regulator is disabled.
#define SCG_FIRCCSR_LK                           ((uint32_t)1 << 23)    // Lock Register
#define   SCG_FIRCCSR_LK_0                       (uint32_t)0x0          // Control Status Register can be written.
#define   SCG_FIRCCSR_LK_1                       (uint32_t)0x1          // Control Status Register cannot be written.
#define SCG_FIRCCSR_FIRCVLD                      ((uint32_t)1 << 24)    // Fast IRC Valid status
#define   SCG_FIRCCSR_FIRCVLD_0                  (uint32_t)0x0          // Fast IRC is not enabled or clock is not valid.
#define   SCG_FIRCCSR_FIRCVLD_1                  (uint32_t)0x1          // Fast IRC is enabled and output clock is valid. The clock is valid once there is an output clock from the FIRC analog.
#define SCG_FIRCCSR_FIRCSEL                      ((uint32_t)1 << 25)    // Fast IRC Selected status
#define   SCG_FIRCCSR_FIRCSEL_0                  (uint32_t)0x0          // Fast IRC is not the system clock source
#define   SCG_FIRCCSR_FIRCSEL_1                  (uint32_t)0x1          // Fast IRC is the system clock source
#define SCG_FIRCCSR_FIRCERR                      ((uint32_t)1 << 26)    // Fast IRC Clock Error
#define   SCG_FIRCCSR_FIRCERR_0                  (uint32_t)0x0          // Error not detected with the Fast IRC trimming.
#define   SCG_FIRCCSR_FIRCERR_1                  (uint32_t)0x1          // Error detected with the Fast IRC trimming.

    uint32_t             FIRCDIV;                                       // Fast IRC Divide Register
                                                                        // Fast IRC Clock Divide 1
#define SCG_FIRCDIV_FIRCDIV1(_n)                 (((uint32_t)(_n) & 0x7) << 0)
#define SCG_FIRCDIV_FIRCDIV1_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define SCG_FIRCDIV_FIRCDIV1_EXTRACT(_v)             (((_v) >> 0) & 0x7)
#define   SCG_FIRCDIV_FIRCDIV1_000               (uint32_t)0x0          // Output disabled
#define   SCG_FIRCDIV_FIRCDIV1_001               (uint32_t)0x1          // Divide by 1
#define   SCG_FIRCDIV_FIRCDIV1_010               (uint32_t)0x2          // Divide by 2
#define   SCG_FIRCDIV_FIRCDIV1_011               (uint32_t)0x3          // Divide by 4
#define   SCG_FIRCDIV_FIRCDIV1_100               (uint32_t)0x4          // Divide by 8
#define   SCG_FIRCDIV_FIRCDIV1_101               (uint32_t)0x5          // Divide by 16
#define   SCG_FIRCDIV_FIRCDIV1_110               (uint32_t)0x6          // Divide by 32
#define   SCG_FIRCDIV_FIRCDIV1_111               (uint32_t)0x7          // Divide by 64
                                                                        // Fast IRC Clock Divide 2
#define SCG_FIRCDIV_FIRCDIV2(_n)                 (((uint32_t)(_n) & 0x7) << 8)
#define SCG_FIRCDIV_FIRCDIV2_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define SCG_FIRCDIV_FIRCDIV2_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   SCG_FIRCDIV_FIRCDIV2_000               (uint32_t)0x0          // Output disabled
#define   SCG_FIRCDIV_FIRCDIV2_001               (uint32_t)0x1          // Divide by 1
#define   SCG_FIRCDIV_FIRCDIV2_010               (uint32_t)0x2          // Divide by 2
#define   SCG_FIRCDIV_FIRCDIV2_011               (uint32_t)0x3          // Divide by 4
#define   SCG_FIRCDIV_FIRCDIV2_100               (uint32_t)0x4          // Divide by 8
#define   SCG_FIRCDIV_FIRCDIV2_101               (uint32_t)0x5          // Divide by 16
#define   SCG_FIRCDIV_FIRCDIV2_110               (uint32_t)0x6          // Divide by 32
#define   SCG_FIRCDIV_FIRCDIV2_111               (uint32_t)0x7          // Divide by 64

    uint32_t             FIRCCFG;                                       // Fast IRC Configuration Register
                                                                        // Frequency Range
#define SCG_FIRCCFG_RANGE(_n)                    (((uint32_t)(_n) & 0x3) << 0)
#define SCG_FIRCCFG_RANGE_INSERT(_v, _n)             (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define SCG_FIRCCFG_RANGE_EXTRACT(_v)                (((_v) >> 0) & 0x3)
#define   SCG_FIRCCFG_RANGE_00                   (uint32_t)0x0          // Fast IRC is trimmed to 48 MHz

    uint8_t _res4[756];
    uint32_t             SPLLCSR;                                       // System PLL Control Status Register
#define SCG_SPLLCSR_SPLLEN                       ((uint32_t)1 << 0)     // System PLL Enable
#define   SCG_SPLLCSR_SPLLEN_0                   (uint32_t)0x0          // System PLL is disabled
#define   SCG_SPLLCSR_SPLLEN_1                   (uint32_t)0x1          // System PLL is enabled
#define SCG_SPLLCSR_SPLLCM                       ((uint32_t)1 << 16)    // System PLL Clock Monitor
#define   SCG_SPLLCSR_SPLLCM_0                   (uint32_t)0x0          // System PLL Clock Monitor is disabled
#define   SCG_SPLLCSR_SPLLCM_1                   (uint32_t)0x1          // System PLL Clock Monitor is enabled
#define SCG_SPLLCSR_SPLLCMRE                     ((uint32_t)1 << 17)    // System PLL Clock Monitor Reset Enable
#define   SCG_SPLLCSR_SPLLCMRE_0                 (uint32_t)0x0          // Clock Monitor generates interrupt when error detected
#define   SCG_SPLLCSR_SPLLCMRE_1                 (uint32_t)0x1          // Clock Monitor generates reset when error detected
#define SCG_SPLLCSR_LK                           ((uint32_t)1 << 23)    // Lock Register
#define   SCG_SPLLCSR_LK_0                       (uint32_t)0x0          // Control Status Register can be written.
#define   SCG_SPLLCSR_LK_1                       (uint32_t)0x1          // Control Status Register cannot be written.
#define SCG_SPLLCSR_SPLLVLD                      ((uint32_t)1 << 24)    // System PLL Valid
#define   SCG_SPLLCSR_SPLLVLD_0                  (uint32_t)0x0          // System PLL is not enabled or clock is not valid
#define   SCG_SPLLCSR_SPLLVLD_1                  (uint32_t)0x1          // System PLL is enabled and output clock is valid
#define SCG_SPLLCSR_SPLLSEL                      ((uint32_t)1 << 25)    // System PLL Selected
#define   SCG_SPLLCSR_SPLLSEL_0                  (uint32_t)0x0          // System PLL is not the system clock source
#define   SCG_SPLLCSR_SPLLSEL_1                  (uint32_t)0x1          // System PLL is the system clock source
#define SCG_SPLLCSR_SPLLERR                      ((uint32_t)1 << 26)    // System PLL Clock Error
#define   SCG_SPLLCSR_SPLLERR_0                  (uint32_t)0x0          // System PLL Clock Monitor is disabled or has not detected an error
#define   SCG_SPLLCSR_SPLLERR_1                  (uint32_t)0x1          // System PLL Clock Monitor is enabled and detected an error. System PLL Clock Error flag will not set when System OSC is selected as its source and SOSCERR has set.

    uint32_t             SPLLDIV;                                       // System PLL Divide Register
                                                                        // System PLL Clock Divide 1
#define SCG_SPLLDIV_SPLLDIV1(_n)                 (((uint32_t)(_n) & 0x7) << 0)
#define SCG_SPLLDIV_SPLLDIV1_INSERT(_v, _n)          (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define SCG_SPLLDIV_SPLLDIV1_EXTRACT(_v)             (((_v) >> 0) & 0x7)
#define   SCG_SPLLDIV_SPLLDIV1_000               (uint32_t)0x0          // Clock disabled
#define   SCG_SPLLDIV_SPLLDIV1_001               (uint32_t)0x1          // Divide by 1
#define   SCG_SPLLDIV_SPLLDIV1_010               (uint32_t)0x2          // Divide by 2
#define   SCG_SPLLDIV_SPLLDIV1_011               (uint32_t)0x3          // Divide by 4
#define   SCG_SPLLDIV_SPLLDIV1_100               (uint32_t)0x4          // Divide by 8
#define   SCG_SPLLDIV_SPLLDIV1_101               (uint32_t)0x5          // Divide by 16
#define   SCG_SPLLDIV_SPLLDIV1_110               (uint32_t)0x6          // Divide by 32
#define   SCG_SPLLDIV_SPLLDIV1_111               (uint32_t)0x7          // Divide by 64
                                                                        // System PLL Clock Divide 2
#define SCG_SPLLDIV_SPLLDIV2(_n)                 (((uint32_t)(_n) & 0x7) << 8)
#define SCG_SPLLDIV_SPLLDIV2_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define SCG_SPLLDIV_SPLLDIV2_EXTRACT(_v)             (((_v) >> 8) & 0x7)
#define   SCG_SPLLDIV_SPLLDIV2_000               (uint32_t)0x0          // Clock disabled
#define   SCG_SPLLDIV_SPLLDIV2_001               (uint32_t)0x1          // Divide by 1
#define   SCG_SPLLDIV_SPLLDIV2_010               (uint32_t)0x2          // Divide by 2
#define   SCG_SPLLDIV_SPLLDIV2_011               (uint32_t)0x3          // Divide by 4
#define   SCG_SPLLDIV_SPLLDIV2_100               (uint32_t)0x4          // Divide by 8
#define   SCG_SPLLDIV_SPLLDIV2_101               (uint32_t)0x5          // Divide by 16
#define   SCG_SPLLDIV_SPLLDIV2_110               (uint32_t)0x6          // Divide by 32
#define   SCG_SPLLDIV_SPLLDIV2_111               (uint32_t)0x7          // Divide by 64

    uint32_t             SPLLCFG;                                       // System PLL Configuration Register
                                                                        // PLL Reference Clock Divider
#define SCG_SPLLCFG_PREDIV(_n)                   (((uint32_t)(_n) & 0x7) << 8)
#define SCG_SPLLCFG_PREDIV_INSERT(_v, _n)            (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define SCG_SPLLCFG_PREDIV_EXTRACT(_v)               (((_v) >> 8) & 0x7)
                                                                        // System PLL Multiplier
#define SCG_SPLLCFG_MULT(_n)                     (((uint32_t)(_n) & 0x1f) << 16)
#define SCG_SPLLCFG_MULT_INSERT(_v, _n)              (((_v) & ~0x1f0000) | ((uint32_t)(_n) & 0x1f) << 16)
#define SCG_SPLLCFG_MULT_EXTRACT(_v)                 (((_v) >> 16) & 0x1f)

} SCG_regs_t;
                                                                        // --------------------
                                                                        // PCC
typedef struct                                                          // --------------------
{
    uint8_t _res0[128];
    uint32_t             PCC_FTFC;                                      // PCC FTFC Register
#define PCC_PCC_FTFC_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FTFC_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FTFC_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FTFC_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FTFC_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FTFC_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_DMAMUX;                                    // PCC DMAMUX Register
#define PCC_PCC_DMAMUX_CGC                       ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_DMAMUX_CGC_0                   (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_DMAMUX_CGC_1                   (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_DMAMUX_PR                        ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_DMAMUX_PR_0                    (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_DMAMUX_PR_1                    (uint32_t)0x1          // Peripheral is present.

    uint8_t _res1[8];
    uint32_t             PCC_FlexCAN0;                                  // PCC FlexCAN0 Register
#define PCC_PCC_FlexCAN0_CGC                     ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FlexCAN0_CGC_0                 (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FlexCAN0_CGC_1                 (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FlexCAN0_PR                      ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FlexCAN0_PR_0                  (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FlexCAN0_PR_1                  (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_FlexCAN1;                                  // PCC FlexCAN1 Register
#define PCC_PCC_FlexCAN1_CGC                     ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FlexCAN1_CGC_0                 (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FlexCAN1_CGC_1                 (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FlexCAN1_PR                      ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FlexCAN1_PR_0                  (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FlexCAN1_PR_1                  (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_FTM3;                                      // PCC FTM3 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_FTM3_PCS(_n)                     (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FTM3_PCS_INSERT(_v, _n)              (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FTM3_PCS_EXTRACT(_v)                 (((_v) >> 24) & 0x7)
#define   PCC_PCC_FTM3_PCS_000                   (uint32_t)0x0          // Clock is off. An external clock can be enabled for this peripheral.
#define   PCC_PCC_FTM3_PCS_001                   (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_FTM3_PCS_010                   (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_FTM3_PCS_011                   (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_FTM3_PCS_100                   (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_FTM3_PCS_101                   (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_FTM3_PCS_110                   (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_FTM3_PCS_111                   (uint32_t)0x7          // Clock option 7
#define PCC_PCC_FTM3_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FTM3_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FTM3_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FTM3_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FTM3_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FTM3_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_ADC1;                                      // PCC ADC1 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_ADC1_PCS(_n)                     (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_ADC1_PCS_INSERT(_v, _n)              (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_ADC1_PCS_EXTRACT(_v)                 (((_v) >> 24) & 0x7)
#define   PCC_PCC_ADC1_PCS_000                   (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_ADC1_PCS_001                   (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_ADC1_PCS_010                   (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_ADC1_PCS_011                   (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_ADC1_PCS_100                   (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_ADC1_PCS_101                   (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_ADC1_PCS_110                   (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_ADC1_PCS_111                   (uint32_t)0x7          // Clock option 7
#define PCC_PCC_ADC1_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_ADC1_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_ADC1_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_ADC1_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_ADC1_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_ADC1_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint8_t _res2[12];
    uint32_t             PCC_FlexCAN2;                                  // PCC FlexCAN2 Register
#define PCC_PCC_FlexCAN2_CGC                     ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FlexCAN2_CGC_0                 (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FlexCAN2_CGC_1                 (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FlexCAN2_PR                      ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FlexCAN2_PR_0                  (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FlexCAN2_PR_1                  (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_LPSPI0;                                    // PCC LPSPI0 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPSPI0_PCS(_n)                   (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPSPI0_PCS_INSERT(_v, _n)            (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPSPI0_PCS_EXTRACT(_v)               (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPSPI0_PCS_000                 (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPSPI0_PCS_001                 (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPSPI0_PCS_010                 (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPSPI0_PCS_011                 (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPSPI0_PCS_100                 (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPSPI0_PCS_101                 (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPSPI0_PCS_110                 (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPSPI0_PCS_111                 (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPSPI0_CGC                       ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPSPI0_CGC_0                   (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPSPI0_CGC_1                   (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPSPI0_PR                        ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPSPI0_PR_0                    (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPSPI0_PR_1                    (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_LPSPI1;                                    // PCC LPSPI1 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPSPI1_PCS(_n)                   (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPSPI1_PCS_INSERT(_v, _n)            (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPSPI1_PCS_EXTRACT(_v)               (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPSPI1_PCS_000                 (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPSPI1_PCS_001                 (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPSPI1_PCS_010                 (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPSPI1_PCS_011                 (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPSPI1_PCS_100                 (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPSPI1_PCS_101                 (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPSPI1_PCS_110                 (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPSPI1_PCS_111                 (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPSPI1_CGC                       ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPSPI1_CGC_0                   (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPSPI1_CGC_1                   (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPSPI1_PR                        ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPSPI1_PR_0                    (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPSPI1_PR_1                    (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_LPSPI2;                                    // PCC LPSPI2 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPSPI2_PCS(_n)                   (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPSPI2_PCS_INSERT(_v, _n)            (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPSPI2_PCS_EXTRACT(_v)               (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPSPI2_PCS_000                 (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPSPI2_PCS_001                 (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPSPI2_PCS_010                 (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPSPI2_PCS_011                 (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPSPI2_PCS_100                 (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPSPI2_PCS_101                 (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPSPI2_PCS_110                 (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPSPI2_PCS_111                 (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPSPI2_CGC                       ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPSPI2_CGC_0                   (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPSPI2_CGC_1                   (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPSPI2_PR                        ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPSPI2_PR_0                    (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPSPI2_PR_1                    (uint32_t)0x1          // Peripheral is present.

    uint8_t _res3[8];
    uint32_t             PCC_PDB1;                                      // PCC PDB1 Register
#define PCC_PCC_PDB1_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_PDB1_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_PDB1_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_PDB1_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_PDB1_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_PDB1_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_CRC;                                       // PCC CRC Register
#define PCC_PCC_CRC_CGC                          ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_CRC_CGC_0                      (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_CRC_CGC_1                      (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_CRC_PR                           ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_CRC_PR_0                       (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_CRC_PR_1                       (uint32_t)0x1          // Peripheral is present.

    uint8_t _res4[12];
    uint32_t             PCC_PDB0;                                      // PCC PDB0 Register
#define PCC_PCC_PDB0_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_PDB0_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_PDB0_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_PDB0_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_PDB0_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_PDB0_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_LPIT;                                      // PCC LPIT Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPIT_PCS(_n)                     (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPIT_PCS_INSERT(_v, _n)              (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPIT_PCS_EXTRACT(_v)                 (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPIT_PCS_000                   (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPIT_PCS_001                   (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPIT_PCS_010                   (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPIT_PCS_011                   (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPIT_PCS_100                   (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPIT_PCS_101                   (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPIT_PCS_110                   (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPIT_PCS_111                   (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPIT_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPIT_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPIT_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPIT_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPIT_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPIT_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_FTM0;                                      // PCC FTM0 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_FTM0_PCS(_n)                     (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FTM0_PCS_INSERT(_v, _n)              (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FTM0_PCS_EXTRACT(_v)                 (((_v) >> 24) & 0x7)
#define   PCC_PCC_FTM0_PCS_000                   (uint32_t)0x0          // Clock is off. An external clock can be enabled for this peripheral.
#define   PCC_PCC_FTM0_PCS_001                   (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_FTM0_PCS_010                   (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_FTM0_PCS_011                   (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_FTM0_PCS_100                   (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_FTM0_PCS_101                   (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_FTM0_PCS_110                   (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_FTM0_PCS_111                   (uint32_t)0x7          // Clock option 7
#define PCC_PCC_FTM0_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FTM0_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FTM0_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FTM0_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FTM0_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FTM0_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_FTM1;                                      // PCC FTM1 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_FTM1_PCS(_n)                     (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FTM1_PCS_INSERT(_v, _n)              (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FTM1_PCS_EXTRACT(_v)                 (((_v) >> 24) & 0x7)
#define   PCC_PCC_FTM1_PCS_000                   (uint32_t)0x0          // Clock is off. An external clock can be enabled for this peripheral.
#define   PCC_PCC_FTM1_PCS_001                   (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_FTM1_PCS_010                   (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_FTM1_PCS_011                   (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_FTM1_PCS_100                   (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_FTM1_PCS_101                   (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_FTM1_PCS_110                   (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_FTM1_PCS_111                   (uint32_t)0x7          // Clock option 7
#define PCC_PCC_FTM1_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FTM1_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FTM1_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FTM1_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FTM1_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FTM1_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_FTM2;                                      // PCC FTM2 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_FTM2_PCS(_n)                     (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FTM2_PCS_INSERT(_v, _n)              (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FTM2_PCS_EXTRACT(_v)                 (((_v) >> 24) & 0x7)
#define   PCC_PCC_FTM2_PCS_000                   (uint32_t)0x0          // Clock is off. An external clock can be enabled for this peripheral.
#define   PCC_PCC_FTM2_PCS_001                   (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_FTM2_PCS_010                   (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_FTM2_PCS_011                   (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_FTM2_PCS_100                   (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_FTM2_PCS_101                   (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_FTM2_PCS_110                   (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_FTM2_PCS_111                   (uint32_t)0x7          // Clock option 7
#define PCC_PCC_FTM2_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FTM2_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FTM2_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FTM2_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FTM2_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FTM2_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_ADC0;                                      // PCC ADC0 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_ADC0_PCS(_n)                     (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_ADC0_PCS_INSERT(_v, _n)              (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_ADC0_PCS_EXTRACT(_v)                 (((_v) >> 24) & 0x7)
#define   PCC_PCC_ADC0_PCS_000                   (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_ADC0_PCS_001                   (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_ADC0_PCS_010                   (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_ADC0_PCS_011                   (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_ADC0_PCS_100                   (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_ADC0_PCS_101                   (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_ADC0_PCS_110                   (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_ADC0_PCS_111                   (uint32_t)0x7          // Clock option 7
#define PCC_PCC_ADC0_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_ADC0_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_ADC0_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_ADC0_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_ADC0_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_ADC0_PR_1                      (uint32_t)0x1          // Peripheral is present.

    uint8_t _res5[4];
    uint32_t             PCC_RTC;                                       // PCC RTC Register
#define PCC_PCC_RTC_CGC                          ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_RTC_CGC_0                      (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_RTC_CGC_1                      (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_RTC_PR                           ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_RTC_PR_0                       (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_RTC_PR_1                       (uint32_t)0x1          // Peripheral is present.

    uint8_t _res6[8];
    uint32_t             PCC_LPTMR0;                                    // PCC LPTMR0 Register
                                                                        // Peripheral Clock Divider Select
#define PCC_PCC_LPTMR0_PCD(_n)                   (((uint32_t)(_n) & 0x7) << 0)
#define PCC_PCC_LPTMR0_PCD_INSERT(_v, _n)            (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define PCC_PCC_LPTMR0_PCD_EXTRACT(_v)               (((_v) >> 0) & 0x7)
#define   PCC_PCC_LPTMR0_PCD_000                 (uint32_t)0x0          // Divide by 1.
#define   PCC_PCC_LPTMR0_PCD_001                 (uint32_t)0x1          // Divide by 2.
#define   PCC_PCC_LPTMR0_PCD_010                 (uint32_t)0x2          // Divide by 3.
#define   PCC_PCC_LPTMR0_PCD_011                 (uint32_t)0x3          // Divide by 4.
#define   PCC_PCC_LPTMR0_PCD_100                 (uint32_t)0x4          // Divide by 5.
#define   PCC_PCC_LPTMR0_PCD_101                 (uint32_t)0x5          // Divide by 6.
#define   PCC_PCC_LPTMR0_PCD_110                 (uint32_t)0x6          // Divide by 7.
#define   PCC_PCC_LPTMR0_PCD_111                 (uint32_t)0x7          // Divide by 8.
#define PCC_PCC_LPTMR0_FRAC                      ((uint32_t)1 << 3)     // Peripheral Clock Divider Fraction
#define   PCC_PCC_LPTMR0_FRAC_0                  (uint32_t)0x0          // Fractional value is 0.
#define   PCC_PCC_LPTMR0_FRAC_1                  (uint32_t)0x1          // Fractional value is 1.
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPTMR0_PCS(_n)                   (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPTMR0_PCS_INSERT(_v, _n)            (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPTMR0_PCS_EXTRACT(_v)               (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPTMR0_PCS_000                 (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPTMR0_PCS_001                 (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPTMR0_PCS_010                 (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPTMR0_PCS_011                 (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPTMR0_PCS_100                 (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPTMR0_PCS_101                 (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPTMR0_PCS_110                 (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPTMR0_PCS_111                 (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPTMR0_CGC                       ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPTMR0_CGC_0                   (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPTMR0_CGC_1                   (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPTMR0_PR                        ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPTMR0_PR_0                    (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPTMR0_PR_1                    (uint32_t)0x1          // Peripheral is present.

    uint8_t _res7[32];
    uint32_t             PCC_PORTA;                                     // PCC PORTA Register
#define PCC_PCC_PORTA_CGC                        ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_PORTA_CGC_0                    (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_PORTA_CGC_1                    (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_PORTA_PR                         ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_PORTA_PR_0                     (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_PORTA_PR_1                     (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_PORTB;                                     // PCC PORTB Register
#define PCC_PCC_PORTB_CGC                        ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_PORTB_CGC_0                    (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_PORTB_CGC_1                    (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_PORTB_PR                         ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_PORTB_PR_0                     (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_PORTB_PR_1                     (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_PORTC;                                     // PCC PORTC Register
#define PCC_PCC_PORTC_CGC                        ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_PORTC_CGC_0                    (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_PORTC_CGC_1                    (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_PORTC_PR                         ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_PORTC_PR_0                     (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_PORTC_PR_1                     (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_PORTD;                                     // PCC PORTD Register
#define PCC_PCC_PORTD_CGC                        ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_PORTD_CGC_0                    (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_PORTD_CGC_1                    (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_PORTD_PR                         ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_PORTD_PR_0                     (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_PORTD_PR_1                     (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_PORTE;                                     // PCC PORTE Register
#define PCC_PCC_PORTE_CGC                        ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_PORTE_CGC_0                    (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_PORTE_CGC_1                    (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_PORTE_PR                         ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_PORTE_PR_0                     (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_PORTE_PR_1                     (uint32_t)0x1          // Peripheral is present.

    uint8_t _res8[48];
    uint32_t             PCC_FlexIO;                                    // PCC FlexIO Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_FlexIO_PCS(_n)                   (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FlexIO_PCS_INSERT(_v, _n)            (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_FlexIO_PCS_EXTRACT(_v)               (((_v) >> 24) & 0x7)
#define   PCC_PCC_FlexIO_PCS_000                 (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_FlexIO_PCS_001                 (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_FlexIO_PCS_010                 (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_FlexIO_PCS_011                 (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_FlexIO_PCS_100                 (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_FlexIO_PCS_101                 (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_FlexIO_PCS_110                 (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_FlexIO_PCS_111                 (uint32_t)0x7          // Clock option 7
#define PCC_PCC_FlexIO_CGC                       ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_FlexIO_CGC_0                   (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_FlexIO_CGC_1                   (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_FlexIO_PR                        ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_FlexIO_PR_0                    (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_FlexIO_PR_1                    (uint32_t)0x1          // Peripheral is present.

    uint8_t _res9[24];
    uint32_t             PCC_EWM;                                       // PCC EWM Register
#define PCC_PCC_EWM_CGC                          ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_EWM_CGC_0                      (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_EWM_CGC_1                      (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_EWM_PR                           ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_EWM_PR_0                       (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_EWM_PR_1                       (uint32_t)0x1          // Peripheral is present.

    uint8_t _res10[16];
    uint32_t             PCC_LPI2C0;                                    // PCC LPI2C0 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPI2C0_PCS(_n)                   (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPI2C0_PCS_INSERT(_v, _n)            (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPI2C0_PCS_EXTRACT(_v)               (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPI2C0_PCS_000                 (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPI2C0_PCS_001                 (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPI2C0_PCS_010                 (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPI2C0_PCS_011                 (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPI2C0_PCS_100                 (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPI2C0_PCS_101                 (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPI2C0_PCS_110                 (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPI2C0_PCS_111                 (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPI2C0_CGC                       ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPI2C0_CGC_0                   (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPI2C0_CGC_1                   (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPI2C0_PR                        ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPI2C0_PR_0                    (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPI2C0_PR_1                    (uint32_t)0x1          // Peripheral is present.

    uint8_t _res11[12];
    uint32_t             PCC_LPUART0;                                   // PCC LPUART0 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPUART0_PCS(_n)                  (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPUART0_PCS_INSERT(_v, _n)           (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPUART0_PCS_EXTRACT(_v)              (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPUART0_PCS_000                (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPUART0_PCS_001                (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPUART0_PCS_010                (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPUART0_PCS_011                (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPUART0_PCS_100                (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPUART0_PCS_101                (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPUART0_PCS_110                (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPUART0_PCS_111                (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPUART0_CGC                      ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPUART0_CGC_0                  (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPUART0_CGC_1                  (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPUART0_PR                       ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPUART0_PR_0                   (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPUART0_PR_1                   (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_LPUART1;                                   // PCC LPUART1 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPUART1_PCS(_n)                  (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPUART1_PCS_INSERT(_v, _n)           (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPUART1_PCS_EXTRACT(_v)              (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPUART1_PCS_000                (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPUART1_PCS_001                (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPUART1_PCS_010                (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPUART1_PCS_011                (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPUART1_PCS_100                (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPUART1_PCS_101                (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPUART1_PCS_110                (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPUART1_PCS_111                (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPUART1_CGC                      ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPUART1_CGC_0                  (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPUART1_CGC_1                  (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPUART1_PR                       ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPUART1_PR_0                   (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPUART1_PR_1                   (uint32_t)0x1          // Peripheral is present.

    uint32_t             PCC_LPUART2;                                   // PCC LPUART2 Register
                                                                        // Peripheral Clock Source Select
#define PCC_PCC_LPUART2_PCS(_n)                  (((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPUART2_PCS_INSERT(_v, _n)           (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define PCC_PCC_LPUART2_PCS_EXTRACT(_v)              (((_v) >> 24) & 0x7)
#define   PCC_PCC_LPUART2_PCS_000                (uint32_t)0x0          // Clock is off.
#define   PCC_PCC_LPUART2_PCS_001                (uint32_t)0x1          // Clock option 1
#define   PCC_PCC_LPUART2_PCS_010                (uint32_t)0x2          // Clock option 2
#define   PCC_PCC_LPUART2_PCS_011                (uint32_t)0x3          // Clock option 3
#define   PCC_PCC_LPUART2_PCS_100                (uint32_t)0x4          // Clock option 4
#define   PCC_PCC_LPUART2_PCS_101                (uint32_t)0x5          // Clock option 5
#define   PCC_PCC_LPUART2_PCS_110                (uint32_t)0x6          // Clock option 6
#define   PCC_PCC_LPUART2_PCS_111                (uint32_t)0x7          // Clock option 7
#define PCC_PCC_LPUART2_CGC                      ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_LPUART2_CGC_0                  (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_LPUART2_CGC_1                  (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_LPUART2_PR                       ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_LPUART2_PR_0                   (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_LPUART2_PR_1                   (uint32_t)0x1          // Peripheral is present.

    uint8_t _res12[24];
    uint32_t             PCC_CMP0;                                      // PCC CMP0 Register
#define PCC_PCC_CMP0_CGC                         ((uint32_t)1 << 30)    // Clock Gate Control
#define   PCC_PCC_CMP0_CGC_0                     (uint32_t)0x0          // Clock disabled
#define   PCC_PCC_CMP0_CGC_1                     (uint32_t)0x1          // Clock enabled. The current clock selection and divider options are locked.
#define PCC_PCC_CMP0_PR                          ((uint32_t)1 << 31)    // Present
#define   PCC_PCC_CMP0_PR_0                      (uint32_t)0x0          // Peripheral is not present.
#define   PCC_PCC_CMP0_PR_1                      (uint32_t)0x1          // Peripheral is present.

} PCC_regs_t;
                                                                        // --------------------
                                                                        // The LPI2C Memory Map/Register Definition can be found here.
typedef struct                                                          // --------------------
{
    const uint32_t       VERID;                                         // Version ID Register
                                                                        // Feature Specification Number
#define LPI2C0_VERID_FEATURE_EXTRACT(_v)             (((_v) >> 0) & 0xffff)
#define   LPI2C0_VERID_FEATURE_0000000000000010  (uint32_t)0x2          // Master only with standard feature set.
#define   LPI2C0_VERID_FEATURE_0000000000000011  (uint32_t)0x3          // Master and slave with standard feature set.
                                                                        // Minor Version Number
#define LPI2C0_VERID_MINOR_EXTRACT(_v)               (((_v) >> 16) & 0xff)
                                                                        // Major Version Number
#define LPI2C0_VERID_MAJOR_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    const uint32_t       PARAM;                                         // Parameter Register
                                                                        // Master Transmit FIFO Size
#define LPI2C0_PARAM_MTXFIFO_EXTRACT(_v)             (((_v) >> 0) & 0xf)
                                                                        // Master Receive FIFO Size
#define LPI2C0_PARAM_MRXFIFO_EXTRACT(_v)             (((_v) >> 8) & 0xf)

    uint8_t _res0[8];
    uint32_t             MCR;                                           // Master Control Register
#define LPI2C0_MCR_MEN                           ((uint32_t)1 << 0)     // Master Enable
#define   LPI2C0_MCR_MEN_0                       (uint32_t)0x0          // Master logic is disabled.
#define   LPI2C0_MCR_MEN_1                       (uint32_t)0x1          // Master logic is enabled.
#define LPI2C0_MCR_RST                           ((uint32_t)1 << 1)     // Software Reset
#define   LPI2C0_MCR_RST_0                       (uint32_t)0x0          // Master logic is not reset.
#define   LPI2C0_MCR_RST_1                       (uint32_t)0x1          // Master logic is reset.
#define LPI2C0_MCR_DOZEN                         ((uint32_t)1 << 2)     // Doze mode enable
#define   LPI2C0_MCR_DOZEN_0                     (uint32_t)0x0          // Master is enabled in Doze mode.
#define   LPI2C0_MCR_DOZEN_1                     (uint32_t)0x1          // Master is disabled in Doze mode.
#define LPI2C0_MCR_DBGEN                         ((uint32_t)1 << 3)     // Debug Enable
#define   LPI2C0_MCR_DBGEN_0                     (uint32_t)0x0          // Master is disabled in debug mode.
#define   LPI2C0_MCR_DBGEN_1                     (uint32_t)0x1          // Master is enabled in debug mode.
#define LPI2C0_MCR_RTF                           ((uint32_t)1 << 8)     // Reset Transmit FIFO
#define   LPI2C0_MCR_RTF_0                       (uint32_t)0x0          // No effect.
#define   LPI2C0_MCR_RTF_1                       (uint32_t)0x1          // Transmit FIFO is reset.
#define LPI2C0_MCR_RRF                           ((uint32_t)1 << 9)     // Reset Receive FIFO
#define   LPI2C0_MCR_RRF_0                       (uint32_t)0x0          // No effect.
#define   LPI2C0_MCR_RRF_1                       (uint32_t)0x1          // Receive FIFO is reset.

    uint32_t             MSR;                                           // Master Status Register
#define LPI2C0_MSR_TDF                           ((uint32_t)1 << 0)     // Transmit Data Flag
#define   LPI2C0_MSR_TDF_0                       (uint32_t)0x0          // Transmit data not requested.
#define   LPI2C0_MSR_TDF_1                       (uint32_t)0x1          // Transmit data is requested.
#define LPI2C0_MSR_RDF                           ((uint32_t)1 << 1)     // Receive Data Flag
#define   LPI2C0_MSR_RDF_0                       (uint32_t)0x0          // Receive Data is not ready.
#define   LPI2C0_MSR_RDF_1                       (uint32_t)0x1          // Receive data is ready.
#define LPI2C0_MSR_EPF                           ((uint32_t)1 << 8)     // End Packet Flag
#define   LPI2C0_MSR_EPF_0                       (uint32_t)0x0          // Master has not generated a STOP or Repeated START condition.
#define   LPI2C0_MSR_EPF_1                       (uint32_t)0x1          // Master has generated a STOP or Repeated START condition.
#define LPI2C0_MSR_SDF                           ((uint32_t)1 << 9)     // STOP Detect Flag
#define   LPI2C0_MSR_SDF_0                       (uint32_t)0x0          // Master has not generated a STOP condition.
#define   LPI2C0_MSR_SDF_1                       (uint32_t)0x1          // Master has generated a STOP condition.
#define LPI2C0_MSR_NDF                           ((uint32_t)1 << 10)    // NACK Detect Flag
#define   LPI2C0_MSR_NDF_0                       (uint32_t)0x0          // Unexpected NACK not detected.
#define   LPI2C0_MSR_NDF_1                       (uint32_t)0x1          // Unexpected NACK was detected.
#define LPI2C0_MSR_ALF                           ((uint32_t)1 << 11)    // Arbitration Lost Flag
#define   LPI2C0_MSR_ALF_0                       (uint32_t)0x0          // Master has not lost arbitration.
#define   LPI2C0_MSR_ALF_1                       (uint32_t)0x1          // Master has lost arbitration.
#define LPI2C0_MSR_FEF                           ((uint32_t)1 << 12)    // FIFO Error Flag
#define   LPI2C0_MSR_FEF_0                       (uint32_t)0x0          // No error.
#define   LPI2C0_MSR_FEF_1                       (uint32_t)0x1          // Master sending or receiving data without START condition.
#define LPI2C0_MSR_PLTF                          ((uint32_t)1 << 13)    // Pin Low Timeout Flag
#define   LPI2C0_MSR_PLTF_0                      (uint32_t)0x0          // Pin low timeout has not occurred or is disabled.
#define   LPI2C0_MSR_PLTF_1                      (uint32_t)0x1          // Pin low timeout has occurred.
#define LPI2C0_MSR_DMF                           ((uint32_t)1 << 14)    // Data Match Flag
#define   LPI2C0_MSR_DMF_0                       (uint32_t)0x0          // Have not received matching data.
#define   LPI2C0_MSR_DMF_1                       (uint32_t)0x1          // Have received matching data.
#define LPI2C0_MSR_MBF                           ((uint32_t)1 << 24)    // Master Busy Flag
#define   LPI2C0_MSR_MBF_0                       (uint32_t)0x0          // I2C Master is idle.
#define   LPI2C0_MSR_MBF_1                       (uint32_t)0x1          // I2C Master is busy.
#define LPI2C0_MSR_BBF                           ((uint32_t)1 << 25)    // Bus Busy Flag
#define   LPI2C0_MSR_BBF_0                       (uint32_t)0x0          // I2C Bus is idle.
#define   LPI2C0_MSR_BBF_1                       (uint32_t)0x1          // I2C Bus is busy.

    uint32_t             MIER;                                          // Master Interrupt Enable Register
#define LPI2C0_MIER_TDIE                         ((uint32_t)1 << 0)     // Transmit Data Interrupt Enable
#define   LPI2C0_MIER_TDIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_MIER_TDIE_1                     (uint32_t)0x1          // Interrupt enabled
#define LPI2C0_MIER_RDIE                         ((uint32_t)1 << 1)     // Receive Data Interrupt Enable
#define   LPI2C0_MIER_RDIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_MIER_RDIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_MIER_EPIE                         ((uint32_t)1 << 8)     // End Packet Interrupt Enable
#define   LPI2C0_MIER_EPIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_MIER_EPIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_MIER_SDIE                         ((uint32_t)1 << 9)     // STOP Detect Interrupt Enable
#define   LPI2C0_MIER_SDIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_MIER_SDIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_MIER_NDIE                         ((uint32_t)1 << 10)    // NACK Detect Interrupt Enable
#define   LPI2C0_MIER_NDIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_MIER_NDIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_MIER_ALIE                         ((uint32_t)1 << 11)    // Arbitration Lost Interrupt Enable
#define   LPI2C0_MIER_ALIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_MIER_ALIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_MIER_FEIE                         ((uint32_t)1 << 12)    // FIFO Error Interrupt Enable
#define   LPI2C0_MIER_FEIE_0                     (uint32_t)0x0          // Interrupt enabled.
#define   LPI2C0_MIER_FEIE_1                     (uint32_t)0x1          // Interrupt disabled.
#define LPI2C0_MIER_PLTIE                        ((uint32_t)1 << 13)    // Pin Low Timeout Interrupt Enable
#define   LPI2C0_MIER_PLTIE_0                    (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_MIER_PLTIE_1                    (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_MIER_DMIE                         ((uint32_t)1 << 14)    // Data Match Interrupt Enable
#define   LPI2C0_MIER_DMIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_MIER_DMIE_1                     (uint32_t)0x1          // Interrupt enabled.

    uint32_t             MDER;                                          // Master DMA Enable Register
#define LPI2C0_MDER_TDDE                         ((uint32_t)1 << 0)     // Transmit Data DMA Enable
#define   LPI2C0_MDER_TDDE_0                     (uint32_t)0x0          // DMA request disabled.
#define   LPI2C0_MDER_TDDE_1                     (uint32_t)0x1          // DMA request enabled
#define LPI2C0_MDER_RDDE                         ((uint32_t)1 << 1)     // Receive Data DMA Enable
#define   LPI2C0_MDER_RDDE_0                     (uint32_t)0x0          // DMA request disabled.
#define   LPI2C0_MDER_RDDE_1                     (uint32_t)0x1          // DMA request enabled.

    uint32_t             MCFGR0;                                        // Master Configuration Register 0
#define LPI2C0_MCFGR0_HREN                       ((uint32_t)1 << 0)     // Host Request Enable
#define   LPI2C0_MCFGR0_HREN_0                   (uint32_t)0x0          // Host request input is disabled.
#define   LPI2C0_MCFGR0_HREN_1                   (uint32_t)0x1          // Host request input is enabled.
#define LPI2C0_MCFGR0_HRPOL                      ((uint32_t)1 << 1)     // Host Request Polarity
#define   LPI2C0_MCFGR0_HRPOL_0                  (uint32_t)0x0          // Active low.
#define   LPI2C0_MCFGR0_HRPOL_1                  (uint32_t)0x1          // Active high.
#define LPI2C0_MCFGR0_HRSEL                      ((uint32_t)1 << 2)     // Host Request Select
#define   LPI2C0_MCFGR0_HRSEL_0                  (uint32_t)0x0          // Host request input is pin HREQ.
#define   LPI2C0_MCFGR0_HRSEL_1                  (uint32_t)0x1          // Host request input is input trigger.
#define LPI2C0_MCFGR0_CIRFIFO                    ((uint32_t)1 << 8)     // Circular FIFO Enable
#define   LPI2C0_MCFGR0_CIRFIFO_0                (uint32_t)0x0          // Circular FIFO is disabled.
#define   LPI2C0_MCFGR0_CIRFIFO_1                (uint32_t)0x1          // Circular FIFO is enabled.
#define LPI2C0_MCFGR0_RDMO                       ((uint32_t)1 << 9)     // Receive Data Match Only
#define   LPI2C0_MCFGR0_RDMO_0                   (uint32_t)0x0          // Received data is stored in the receive FIFO as normal.
#define   LPI2C0_MCFGR0_RDMO_1                   (uint32_t)0x1          // Received data is discarded unless the RMF is set.

    uint32_t             MCFGR1;                                        // Master Configuration Register 1
                                                                        // Prescaler
#define LPI2C0_MCFGR1_PRESCALE(_n)               (((uint32_t)(_n) & 0x7) << 0)
#define LPI2C0_MCFGR1_PRESCALE_INSERT(_v, _n)        (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define LPI2C0_MCFGR1_PRESCALE_EXTRACT(_v)           (((_v) >> 0) & 0x7)
#define   LPI2C0_MCFGR1_PRESCALE_000             (uint32_t)0x0          // Divide by 1.
#define   LPI2C0_MCFGR1_PRESCALE_001             (uint32_t)0x1          // Divide by 2.
#define   LPI2C0_MCFGR1_PRESCALE_010             (uint32_t)0x2          // Divide by 4.
#define   LPI2C0_MCFGR1_PRESCALE_011             (uint32_t)0x3          // Divide by 8.
#define   LPI2C0_MCFGR1_PRESCALE_100             (uint32_t)0x4          // Divide by 16.
#define   LPI2C0_MCFGR1_PRESCALE_101             (uint32_t)0x5          // Divide by 32.
#define   LPI2C0_MCFGR1_PRESCALE_110             (uint32_t)0x6          // Divide by 64.
#define   LPI2C0_MCFGR1_PRESCALE_111             (uint32_t)0x7          // Divide by 128.
#define LPI2C0_MCFGR1_AUTOSTOP                   ((uint32_t)1 << 8)     // Automatic STOP Generation
#define   LPI2C0_MCFGR1_AUTOSTOP_0               (uint32_t)0x0          // No effect.
#define   LPI2C0_MCFGR1_AUTOSTOP_1               (uint32_t)0x1          // STOP condition is automatically generated whenever the transmit FIFO is empty and LPI2C master is busy.
#define LPI2C0_MCFGR1_IGNACK                     ((uint32_t)1 << 9)     // IGNACK
#define   LPI2C0_MCFGR1_IGNACK_0                 (uint32_t)0x0          // LPI2C Master will receive ACK and NACK normally.
#define   LPI2C0_MCFGR1_IGNACK_1                 (uint32_t)0x1          // LPI2C Master will treat a received NACK as if it was an ACK.
#define LPI2C0_MCFGR1_TIMECFG                    ((uint32_t)1 << 10)    // Timeout Configuration
#define   LPI2C0_MCFGR1_TIMECFG_0                (uint32_t)0x0          // Pin Low Timeout Flag will set if SCL is low for longer than the configured timeout.
#define   LPI2C0_MCFGR1_TIMECFG_1                (uint32_t)0x1          // Pin Low Timeout Flag will set if either SCL or SDA is low for longer than the configured timeout.
                                                                        // Match Configuration
#define LPI2C0_MCFGR1_MATCFG(_n)                 (((uint32_t)(_n) & 0x7) << 16)
#define LPI2C0_MCFGR1_MATCFG_INSERT(_v, _n)          (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define LPI2C0_MCFGR1_MATCFG_EXTRACT(_v)             (((_v) >> 16) & 0x7)
#define   LPI2C0_MCFGR1_MATCFG_000               (uint32_t)0x0          // Match disabled.
#define   LPI2C0_MCFGR1_MATCFG_010               (uint32_t)0x2          // Match enabled (1st data word equals MATCH0 OR MATCH1).
#define   LPI2C0_MCFGR1_MATCFG_011               (uint32_t)0x3          // Match enabled (any data word equals MATCH0 OR MATCH1).
#define   LPI2C0_MCFGR1_MATCFG_100               (uint32_t)0x4          // Match enabled (1st data word equals MATCH0 AND 2nd data word equals MATCH1).
#define   LPI2C0_MCFGR1_MATCFG_101               (uint32_t)0x5          // Match enabled (any data word equals MATCH0 AND next data word equals MATCH1).
#define   LPI2C0_MCFGR1_MATCFG_110               (uint32_t)0x6          // Match enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1).
#define   LPI2C0_MCFGR1_MATCFG_111               (uint32_t)0x7          // Match enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1).
                                                                        // Pin Configuration
#define LPI2C0_MCFGR1_PINCFG(_n)                 (((uint32_t)(_n) & 0x7) << 24)
#define LPI2C0_MCFGR1_PINCFG_INSERT(_v, _n)          (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define LPI2C0_MCFGR1_PINCFG_EXTRACT(_v)             (((_v) >> 24) & 0x7)
#define   LPI2C0_MCFGR1_PINCFG_000               (uint32_t)0x0          // LPI2C configured for 2-pin open drain mode.
#define   LPI2C0_MCFGR1_PINCFG_001               (uint32_t)0x1          // LPI2C configured for 2-pin output only mode (ultra-fast mode).
#define   LPI2C0_MCFGR1_PINCFG_010               (uint32_t)0x2          // LPI2C configured for 2-pin push-pull mode.
#define   LPI2C0_MCFGR1_PINCFG_011               (uint32_t)0x3          // LPI2C configured for 4-pin push-pull mode.
#define   LPI2C0_MCFGR1_PINCFG_100               (uint32_t)0x4          // LPI2C configured for 2-pin open drain mode with separate LPI2C slave.
#define   LPI2C0_MCFGR1_PINCFG_101               (uint32_t)0x5          // LPI2C configured for 2-pin output only mode (ultra-fast mode) with separate LPI2C slave.
#define   LPI2C0_MCFGR1_PINCFG_110               (uint32_t)0x6          // LPI2C configured for 2-pin push-pull mode with separate LPI2C slave.
#define   LPI2C0_MCFGR1_PINCFG_111               (uint32_t)0x7          // LPI2C configured for 4-pin push-pull mode (inverted outputs).

    uint32_t             MCFGR2;                                        // Master Configuration Register 2
                                                                        // Bus Idle Timeout
#define LPI2C0_MCFGR2_BUSIDLE(_n)                (((uint32_t)(_n) & 0xfff) << 0)
#define LPI2C0_MCFGR2_BUSIDLE_INSERT(_v, _n)         (((_v) & ~0xfff) | ((uint32_t)(_n) & 0xfff) << 0)
#define LPI2C0_MCFGR2_BUSIDLE_EXTRACT(_v)            (((_v) >> 0) & 0xfff)
                                                                        // Glitch Filter SCL
#define LPI2C0_MCFGR2_FILTSCL(_n)                (((uint32_t)(_n) & 0xf) << 16)
#define LPI2C0_MCFGR2_FILTSCL_INSERT(_v, _n)         (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define LPI2C0_MCFGR2_FILTSCL_EXTRACT(_v)            (((_v) >> 16) & 0xf)
                                                                        // Glitch Filter SDA
#define LPI2C0_MCFGR2_FILTSDA(_n)                (((uint32_t)(_n) & 0xf) << 24)
#define LPI2C0_MCFGR2_FILTSDA_INSERT(_v, _n)         (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define LPI2C0_MCFGR2_FILTSDA_EXTRACT(_v)            (((_v) >> 24) & 0xf)

    uint32_t             MCFGR3;                                        // Master Configuration Register 3
                                                                        // Pin Low Timeout
#define LPI2C0_MCFGR3_PINLOW(_n)                 (((uint32_t)(_n) & 0xfff) << 8)
#define LPI2C0_MCFGR3_PINLOW_INSERT(_v, _n)          (((_v) & ~0xfff00) | ((uint32_t)(_n) & 0xfff) << 8)
#define LPI2C0_MCFGR3_PINLOW_EXTRACT(_v)             (((_v) >> 8) & 0xfff)

    uint8_t _res1[16];
    uint32_t             MDMR;                                          // Master Data Match Register
                                                                        // Match 0 Value
#define LPI2C0_MDMR_MATCH0(_n)                   (((uint32_t)(_n) & 0xff) << 0)
#define LPI2C0_MDMR_MATCH0_INSERT(_v, _n)            (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define LPI2C0_MDMR_MATCH0_EXTRACT(_v)               (((_v) >> 0) & 0xff)
                                                                        // Match 1 Value
#define LPI2C0_MDMR_MATCH1(_n)                   (((uint32_t)(_n) & 0xff) << 16)
#define LPI2C0_MDMR_MATCH1_INSERT(_v, _n)            (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define LPI2C0_MDMR_MATCH1_EXTRACT(_v)               (((_v) >> 16) & 0xff)

    uint8_t _res2[4];
    uint32_t             MCCR0;                                         // Master Clock Configuration Register 0
                                                                        // Clock Low Period
#define LPI2C0_MCCR0_CLKLO(_n)                   (((uint32_t)(_n) & 0x3f) << 0)
#define LPI2C0_MCCR0_CLKLO_INSERT(_v, _n)            (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define LPI2C0_MCCR0_CLKLO_EXTRACT(_v)               (((_v) >> 0) & 0x3f)
                                                                        // Clock High Period
#define LPI2C0_MCCR0_CLKHI(_n)                   (((uint32_t)(_n) & 0x3f) << 8)
#define LPI2C0_MCCR0_CLKHI_INSERT(_v, _n)            (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define LPI2C0_MCCR0_CLKHI_EXTRACT(_v)               (((_v) >> 8) & 0x3f)
                                                                        // Setup Hold Delay
#define LPI2C0_MCCR0_SETHOLD(_n)                 (((uint32_t)(_n) & 0x3f) << 16)
#define LPI2C0_MCCR0_SETHOLD_INSERT(_v, _n)          (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define LPI2C0_MCCR0_SETHOLD_EXTRACT(_v)             (((_v) >> 16) & 0x3f)
                                                                        // Data Valid Delay
#define LPI2C0_MCCR0_DATAVD(_n)                  (((uint32_t)(_n) & 0x3f) << 24)
#define LPI2C0_MCCR0_DATAVD_INSERT(_v, _n)           (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define LPI2C0_MCCR0_DATAVD_EXTRACT(_v)              (((_v) >> 24) & 0x3f)

    uint8_t _res3[4];
    uint32_t             MCCR1;                                         // Master Clock Configuration Register 1
                                                                        // Clock Low Period
#define LPI2C0_MCCR1_CLKLO(_n)                   (((uint32_t)(_n) & 0x3f) << 0)
#define LPI2C0_MCCR1_CLKLO_INSERT(_v, _n)            (((_v) & ~0x3f) | ((uint32_t)(_n) & 0x3f) << 0)
#define LPI2C0_MCCR1_CLKLO_EXTRACT(_v)               (((_v) >> 0) & 0x3f)
                                                                        // Clock High Period
#define LPI2C0_MCCR1_CLKHI(_n)                   (((uint32_t)(_n) & 0x3f) << 8)
#define LPI2C0_MCCR1_CLKHI_INSERT(_v, _n)            (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define LPI2C0_MCCR1_CLKHI_EXTRACT(_v)               (((_v) >> 8) & 0x3f)
                                                                        // Setup Hold Delay
#define LPI2C0_MCCR1_SETHOLD(_n)                 (((uint32_t)(_n) & 0x3f) << 16)
#define LPI2C0_MCCR1_SETHOLD_INSERT(_v, _n)          (((_v) & ~0x3f0000) | ((uint32_t)(_n) & 0x3f) << 16)
#define LPI2C0_MCCR1_SETHOLD_EXTRACT(_v)             (((_v) >> 16) & 0x3f)
                                                                        // Data Valid Delay
#define LPI2C0_MCCR1_DATAVD(_n)                  (((uint32_t)(_n) & 0x3f) << 24)
#define LPI2C0_MCCR1_DATAVD_INSERT(_v, _n)           (((_v) & ~0x3f000000) | ((uint32_t)(_n) & 0x3f) << 24)
#define LPI2C0_MCCR1_DATAVD_EXTRACT(_v)              (((_v) >> 24) & 0x3f)

    uint8_t _res4[4];
    uint32_t             MFCR;                                          // Master FIFO Control Register
                                                                        // Transmit FIFO Watermark
#define LPI2C0_MFCR_TXWATER(_n)                  (((uint32_t)(_n) & 0x3) << 0)
#define LPI2C0_MFCR_TXWATER_INSERT(_v, _n)           (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define LPI2C0_MFCR_TXWATER_EXTRACT(_v)              (((_v) >> 0) & 0x3)
                                                                        // Receive FIFO Watermark
#define LPI2C0_MFCR_RXWATER(_n)                  (((uint32_t)(_n) & 0x3) << 16)
#define LPI2C0_MFCR_RXWATER_INSERT(_v, _n)           (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define LPI2C0_MFCR_RXWATER_EXTRACT(_v)              (((_v) >> 16) & 0x3)

    const uint32_t       MFSR;                                          // Master FIFO Status Register
                                                                        // Transmit FIFO Count
#define LPI2C0_MFSR_TXCOUNT_EXTRACT(_v)              (((_v) >> 0) & 0x7)
                                                                        // Receive FIFO Count
#define LPI2C0_MFSR_RXCOUNT_EXTRACT(_v)              (((_v) >> 16) & 0x7)

    uint32_t             MTDR;                                          // Master Transmit Data Register
                                                                        // Transmit Data
#define LPI2C0_MTDR_DATA(_n)                     (((uint32_t)(_n) & 0xff) << 0)
#define LPI2C0_MTDR_DATA_INSERT(_v, _n)              (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define LPI2C0_MTDR_DATA_EXTRACT(_v)                 (((_v) >> 0) & 0xff)
                                                                        // Command Data
#define LPI2C0_MTDR_CMD(_n)                      (((uint32_t)(_n) & 0x7) << 8)
#define LPI2C0_MTDR_CMD_INSERT(_v, _n)               (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define LPI2C0_MTDR_CMD_EXTRACT(_v)                  (((_v) >> 8) & 0x7)
#define   LPI2C0_MTDR_CMD_000                    (uint32_t)0x0          // Transmit DATA[7:0].
#define   LPI2C0_MTDR_CMD_001                    (uint32_t)0x1          // Receive (DATA[7:0] + 1) bytes.
#define   LPI2C0_MTDR_CMD_010                    (uint32_t)0x2          // Generate STOP condition.
#define   LPI2C0_MTDR_CMD_011                    (uint32_t)0x3          // Receive and discard (DATA[7:0] + 1) bytes.
#define   LPI2C0_MTDR_CMD_100                    (uint32_t)0x4          // Generate (repeated) START and transmit address in DATA[7:0].
#define   LPI2C0_MTDR_CMD_101                    (uint32_t)0x5          // Generate (repeated) START and transmit address in DATA[7:0]. This transfer expects a NACK to be returned.
#define   LPI2C0_MTDR_CMD_110                    (uint32_t)0x6          // Generate (repeated) START and transmit address in DATA[7:0] using high speed mode.
#define   LPI2C0_MTDR_CMD_111                    (uint32_t)0x7          // Generate (repeated) START and transmit address in DATA[7:0] using high speed mode. This transfer expects a NACK to be returned.

    uint8_t _res5[12];
    const uint32_t       MRDR;                                          // Master Receive Data Register
                                                                        // Receive Data
#define LPI2C0_MRDR_DATA_EXTRACT(_v)                 (((_v) >> 0) & 0xff)
#define LPI2C0_MRDR_RXEMPTY                      ((uint32_t)1 << 14)    // RX Empty
#define   LPI2C0_MRDR_RXEMPTY_0                  (uint32_t)0x0          // Receive FIFO is not empty.
#define   LPI2C0_MRDR_RXEMPTY_1                  (uint32_t)0x1          // Receive FIFO is empty.

    uint8_t _res6[156];
    uint32_t             SCR;                                           // Slave Control Register
#define LPI2C0_SCR_SEN                           ((uint32_t)1 << 0)     // Slave Enable
#define   LPI2C0_SCR_SEN_0                       (uint32_t)0x0          // Slave mode is disabled.
#define   LPI2C0_SCR_SEN_1                       (uint32_t)0x1          // Slave mode is enabled.
#define LPI2C0_SCR_RST                           ((uint32_t)1 << 1)     // Software Reset
#define   LPI2C0_SCR_RST_0                       (uint32_t)0x0          // Slave logic is not reset.
#define   LPI2C0_SCR_RST_1                       (uint32_t)0x1          // Slave logic is reset.
#define LPI2C0_SCR_FILTEN                        ((uint32_t)1 << 4)     // Filter Enable
#define   LPI2C0_SCR_FILTEN_0                    (uint32_t)0x0          // Disable digital filter and output delay counter for slave mode.
#define   LPI2C0_SCR_FILTEN_1                    (uint32_t)0x1          // Enable digital filter and output delay counter for slave mode.
#define LPI2C0_SCR_FILTDZ                        ((uint32_t)1 << 5)     // Filter Doze Enable
#define   LPI2C0_SCR_FILTDZ_0                    (uint32_t)0x0          // Filter remains enabled in Doze mode.
#define   LPI2C0_SCR_FILTDZ_1                    (uint32_t)0x1          // Filter is disabled in Doze mode.
#define LPI2C0_SCR_RTF                           ((uint32_t)1 << 8)     // Reset Transmit FIFO
#define   LPI2C0_SCR_RTF_0                       (uint32_t)0x0          // No effect
#define   LPI2C0_SCR_RTF_1                       (uint32_t)0x1          // Transmit Data Register is now empty
#define LPI2C0_SCR_RRF                           ((uint32_t)1 << 9)     // Reset Receive FIFO
#define   LPI2C0_SCR_RRF_0                       (uint32_t)0x0          // No effect
#define   LPI2C0_SCR_RRF_1                       (uint32_t)0x1          // Receive Data Register is now empty

    uint32_t             SSR;                                           // Slave Status Register
#define LPI2C0_SSR_TDF                           ((uint32_t)1 << 0)     // Transmit Data Flag
#define   LPI2C0_SSR_TDF_0                       (uint32_t)0x0          // Transmit data not requested.
#define   LPI2C0_SSR_TDF_1                       (uint32_t)0x1          // Transmit data is requested.
#define LPI2C0_SSR_RDF                           ((uint32_t)1 << 1)     // Receive Data Flag
#define   LPI2C0_SSR_RDF_0                       (uint32_t)0x0          // Receive Data is not ready.
#define   LPI2C0_SSR_RDF_1                       (uint32_t)0x1          // Receive data is ready.
#define LPI2C0_SSR_AVF                           ((uint32_t)1 << 2)     // Address Valid Flag
#define   LPI2C0_SSR_AVF_0                       (uint32_t)0x0          // Address Status Register is not valid.
#define   LPI2C0_SSR_AVF_1                       (uint32_t)0x1          // Address Status Register is valid.
#define LPI2C0_SSR_TAF                           ((uint32_t)1 << 3)     // Transmit ACK Flag
#define   LPI2C0_SSR_TAF_0                       (uint32_t)0x0          // Transmit ACK/NACK is not required.
#define   LPI2C0_SSR_TAF_1                       (uint32_t)0x1          // Transmit ACK/NACK is required.
#define LPI2C0_SSR_RSF                           ((uint32_t)1 << 8)     // Repeated Start Flag
#define   LPI2C0_SSR_RSF_0                       (uint32_t)0x0          // Slave has not detected a Repeated START condition.
#define   LPI2C0_SSR_RSF_1                       (uint32_t)0x1          // Slave has detected a Repeated START condition.
#define LPI2C0_SSR_SDF                           ((uint32_t)1 << 9)     // STOP Detect Flag
#define   LPI2C0_SSR_SDF_0                       (uint32_t)0x0          // Slave has not detected a STOP condition.
#define   LPI2C0_SSR_SDF_1                       (uint32_t)0x1          // Slave has detected a STOP condition.
#define LPI2C0_SSR_BEF                           ((uint32_t)1 << 10)    // Bit Error Flag
#define   LPI2C0_SSR_BEF_0                       (uint32_t)0x0          // Slave has not detected a bit error.
#define   LPI2C0_SSR_BEF_1                       (uint32_t)0x1          // Slave has detected a bit error.
#define LPI2C0_SSR_FEF                           ((uint32_t)1 << 11)    // FIFO Error Flag
#define   LPI2C0_SSR_FEF_0                       (uint32_t)0x0          // FIFO underflow or overflow not detected.
#define   LPI2C0_SSR_FEF_1                       (uint32_t)0x1          // FIFO underflow or overflow detected.
#define LPI2C0_SSR_AM0F                          ((uint32_t)1 << 12)    // Address Match 0 Flag
#define   LPI2C0_SSR_AM0F_0                      (uint32_t)0x0          // Have not received ADDR0 matching address.
#define   LPI2C0_SSR_AM0F_1                      (uint32_t)0x1          // Have received ADDR0 matching address.
#define LPI2C0_SSR_AM1F                          ((uint32_t)1 << 13)    // Address Match 1 Flag
#define   LPI2C0_SSR_AM1F_0                      (uint32_t)0x0          // Have not received ADDR1 or ADDR0/ADDR1 range matching address.
#define   LPI2C0_SSR_AM1F_1                      (uint32_t)0x1          // Have received ADDR1 or ADDR0/ADDR1 range matching address.
#define LPI2C0_SSR_GCF                           ((uint32_t)1 << 14)    // General Call Flag
#define   LPI2C0_SSR_GCF_0                       (uint32_t)0x0          // Slave has not detected the General Call Address or General Call Address disabled.
#define   LPI2C0_SSR_GCF_1                       (uint32_t)0x1          // Slave has detected the General Call Address.
#define LPI2C0_SSR_SARF                          ((uint32_t)1 << 15)    // SMBus Alert Response Flag
#define   LPI2C0_SSR_SARF_0                      (uint32_t)0x0          // SMBus Alert Response disabled or not detected.
#define   LPI2C0_SSR_SARF_1                      (uint32_t)0x1          // SMBus Alert Response enabled and detected.
#define LPI2C0_SSR_SBF                           ((uint32_t)1 << 24)    // Slave Busy Flag
#define   LPI2C0_SSR_SBF_0                       (uint32_t)0x0          // I2C Slave is idle.
#define   LPI2C0_SSR_SBF_1                       (uint32_t)0x1          // I2C Slave is busy.
#define LPI2C0_SSR_BBF                           ((uint32_t)1 << 25)    // Bus Busy Flag
#define   LPI2C0_SSR_BBF_0                       (uint32_t)0x0          // I2C Bus is idle.
#define   LPI2C0_SSR_BBF_1                       (uint32_t)0x1          // I2C Bus is busy.

    uint32_t             SIER;                                          // Slave Interrupt Enable Register
#define LPI2C0_SIER_TDIE                         ((uint32_t)1 << 0)     // Transmit Data Interrupt Enable
#define   LPI2C0_SIER_TDIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_TDIE_1                     (uint32_t)0x1          // Interrupt enabled
#define LPI2C0_SIER_RDIE                         ((uint32_t)1 << 1)     // Receive Data Interrupt Enable
#define   LPI2C0_SIER_RDIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_RDIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_AVIE                         ((uint32_t)1 << 2)     // Address Valid Interrupt Enable
#define   LPI2C0_SIER_AVIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_AVIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_TAIE                         ((uint32_t)1 << 3)     // Transmit ACK Interrupt Enable
#define   LPI2C0_SIER_TAIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_TAIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_RSIE                         ((uint32_t)1 << 8)     // Repeated Start Interrupt Enable
#define   LPI2C0_SIER_RSIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_RSIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_SDIE                         ((uint32_t)1 << 9)     // STOP Detect Interrupt Enable
#define   LPI2C0_SIER_SDIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_SDIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_BEIE                         ((uint32_t)1 << 10)    // Bit Error Interrupt Enable
#define   LPI2C0_SIER_BEIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_BEIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_FEIE                         ((uint32_t)1 << 11)    // FIFO Error Interrupt Enable
#define   LPI2C0_SIER_FEIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_FEIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_AM0IE                        ((uint32_t)1 << 12)    // Address Match 0 Interrupt Enable
#define   LPI2C0_SIER_AM0IE_0                    (uint32_t)0x0          // Interrupt enabled.
#define   LPI2C0_SIER_AM0IE_1                    (uint32_t)0x1          // Interrupt disabled.
#define LPI2C0_SIER_AM1F                         ((uint32_t)1 << 13)    // Address Match 1 Interrupt Enable
#define   LPI2C0_SIER_AM1F_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_AM1F_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_GCIE                         ((uint32_t)1 << 14)    // General Call Interrupt Enable
#define   LPI2C0_SIER_GCIE_0                     (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_GCIE_1                     (uint32_t)0x1          // Interrupt enabled.
#define LPI2C0_SIER_SARIE                        ((uint32_t)1 << 15)    // SMBus Alert Response Interrupt Enable
#define   LPI2C0_SIER_SARIE_0                    (uint32_t)0x0          // Interrupt disabled.
#define   LPI2C0_SIER_SARIE_1                    (uint32_t)0x1          // Interrupt enabled.

    uint32_t             SDER;                                          // Slave DMA Enable Register
#define LPI2C0_SDER_TDDE                         ((uint32_t)1 << 0)     // Transmit Data DMA Enable
#define   LPI2C0_SDER_TDDE_0                     (uint32_t)0x0          // DMA request disabled.
#define   LPI2C0_SDER_TDDE_1                     (uint32_t)0x1          // DMA request enabled
#define LPI2C0_SDER_RDDE                         ((uint32_t)1 << 1)     // Receive Data DMA Enable
#define   LPI2C0_SDER_RDDE_0                     (uint32_t)0x0          // DMA request disabled.
#define   LPI2C0_SDER_RDDE_1                     (uint32_t)0x1          // DMA request enabled.
#define LPI2C0_SDER_AVDE                         ((uint32_t)1 << 2)     // Address Valid DMA Enable
#define   LPI2C0_SDER_AVDE_0                     (uint32_t)0x0          // DMA request disabled.
#define   LPI2C0_SDER_AVDE_1                     (uint32_t)0x1          // DMA request enabled.

    uint8_t _res7[4];
    uint32_t             SCFGR1;                                        // Slave Configuration Register 1
#define LPI2C0_SCFGR1_ADRSTALL                   ((uint32_t)1 << 0)     // Address SCL Stall
#define   LPI2C0_SCFGR1_ADRSTALL_0               (uint32_t)0x0          // Clock stretching disabled.
#define   LPI2C0_SCFGR1_ADRSTALL_1               (uint32_t)0x1          // Clock stretching enabled.
#define LPI2C0_SCFGR1_RXSTALL                    ((uint32_t)1 << 1)     // RX SCL Stall
#define   LPI2C0_SCFGR1_RXSTALL_0                (uint32_t)0x0          // Clock stretching disabled.
#define   LPI2C0_SCFGR1_RXSTALL_1                (uint32_t)0x1          // Clock stretching enabled.
#define LPI2C0_SCFGR1_TXDSTALL                   ((uint32_t)1 << 2)     // TX Data SCL Stall
#define   LPI2C0_SCFGR1_TXDSTALL_0               (uint32_t)0x0          // Clock stretching disabled.
#define   LPI2C0_SCFGR1_TXDSTALL_1               (uint32_t)0x1          // Clock stretching enabled.
#define LPI2C0_SCFGR1_ACKSTALL                   ((uint32_t)1 << 3)     // ACK SCL Stall
#define   LPI2C0_SCFGR1_ACKSTALL_0               (uint32_t)0x0          // Clock stretching disabled.
#define   LPI2C0_SCFGR1_ACKSTALL_1               (uint32_t)0x1          // Clock stretching enabled.
#define LPI2C0_SCFGR1_GCEN                       ((uint32_t)1 << 8)     // General Call Enable
#define   LPI2C0_SCFGR1_GCEN_0                   (uint32_t)0x0          // General Call address is disabled.
#define   LPI2C0_SCFGR1_GCEN_1                   (uint32_t)0x1          // General call address is enabled.
#define LPI2C0_SCFGR1_SAEN                       ((uint32_t)1 << 9)     // SMBus Alert Enable
#define   LPI2C0_SCFGR1_SAEN_0                   (uint32_t)0x0          // Disables match on SMBus Alert.
#define   LPI2C0_SCFGR1_SAEN_1                   (uint32_t)0x1          // Enables match on SMBus Alert.
#define LPI2C0_SCFGR1_TXCFG                      ((uint32_t)1 << 10)    // Transmit Flag Configuration
#define   LPI2C0_SCFGR1_TXCFG_0                  (uint32_t)0x0          // Transmit Data Flag will only assert during a slave-transmit transfer when the transmit data register is empty.
#define   LPI2C0_SCFGR1_TXCFG_1                  (uint32_t)0x1          // Transmit Data Flag will assert whenever the transmit data register is empty.
#define LPI2C0_SCFGR1_RXCFG                      ((uint32_t)1 << 11)    // Receive Data Configuration
#define   LPI2C0_SCFGR1_RXCFG_0                  (uint32_t)0x0          // Reading the receive data register will return receive data and clear the receive data flag.
#define   LPI2C0_SCFGR1_RXCFG_1                  (uint32_t)0x1          // Reading the Receive Data register when the Address Valid flag (SSR[AVF])is set, will return the Address Status register and clear the Address Valid flag. Reading the Receive Data register when the Address Valid flag is clear, will return received data and clear the Receive Data flag (MSR[RDF]).
#define LPI2C0_SCFGR1_IGNACK                     ((uint32_t)1 << 12)    // Ignore NACK
#define   LPI2C0_SCFGR1_IGNACK_0                 (uint32_t)0x0          // Slave will end transfer when NACK detected.
#define   LPI2C0_SCFGR1_IGNACK_1                 (uint32_t)0x1          // Slave will not end transfer when NACK detected.
#define LPI2C0_SCFGR1_HSMEN                      ((uint32_t)1 << 13)    // High Speed Mode Enable
#define   LPI2C0_SCFGR1_HSMEN_0                  (uint32_t)0x0          // Disables detection of Hs-mode master code.
#define   LPI2C0_SCFGR1_HSMEN_1                  (uint32_t)0x1          // Enables detection of Hs-mode master code.
                                                                        // Address Configuration
#define LPI2C0_SCFGR1_ADDRCFG(_n)                (((uint32_t)(_n) & 0x7) << 16)
#define LPI2C0_SCFGR1_ADDRCFG_INSERT(_v, _n)         (((_v) & ~0x70000) | ((uint32_t)(_n) & 0x7) << 16)
#define LPI2C0_SCFGR1_ADDRCFG_EXTRACT(_v)            (((_v) >> 16) & 0x7)
#define   LPI2C0_SCFGR1_ADDRCFG_000              (uint32_t)0x0          // Address match 0 (7-bit).
#define   LPI2C0_SCFGR1_ADDRCFG_001              (uint32_t)0x1          // Address match 0 (10-bit).
#define   LPI2C0_SCFGR1_ADDRCFG_010              (uint32_t)0x2          // Address match 0 (7-bit) or Address match 1 (7-bit).
#define   LPI2C0_SCFGR1_ADDRCFG_011              (uint32_t)0x3          // Address match 0 (10-bit) or Address match 1 (10-bit).
#define   LPI2C0_SCFGR1_ADDRCFG_100              (uint32_t)0x4          // Address match 0 (7-bit) or Address match 1 (10-bit).
#define   LPI2C0_SCFGR1_ADDRCFG_101              (uint32_t)0x5          // Address match 0 (10-bit) or Address match 1 (7-bit).
#define   LPI2C0_SCFGR1_ADDRCFG_110              (uint32_t)0x6          // From Address match 0 (7-bit) to Address match 1 (7-bit).
#define   LPI2C0_SCFGR1_ADDRCFG_111              (uint32_t)0x7          // From Address match 0 (10-bit) to Address match 1 (10-bit).

    uint32_t             SCFGR2;                                        // Slave Configuration Register 2
                                                                        // Clock Hold Time
#define LPI2C0_SCFGR2_CLKHOLD(_n)                (((uint32_t)(_n) & 0xf) << 0)
#define LPI2C0_SCFGR2_CLKHOLD_INSERT(_v, _n)         (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define LPI2C0_SCFGR2_CLKHOLD_EXTRACT(_v)            (((_v) >> 0) & 0xf)
                                                                        // Data Valid Delay
#define LPI2C0_SCFGR2_DATAVD(_n)                 (((uint32_t)(_n) & 0x3f) << 8)
#define LPI2C0_SCFGR2_DATAVD_INSERT(_v, _n)          (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define LPI2C0_SCFGR2_DATAVD_EXTRACT(_v)             (((_v) >> 8) & 0x3f)
                                                                        // Glitch Filter SCL
#define LPI2C0_SCFGR2_FILTSCL(_n)                (((uint32_t)(_n) & 0xf) << 16)
#define LPI2C0_SCFGR2_FILTSCL_INSERT(_v, _n)         (((_v) & ~0xf0000) | ((uint32_t)(_n) & 0xf) << 16)
#define LPI2C0_SCFGR2_FILTSCL_EXTRACT(_v)            (((_v) >> 16) & 0xf)
                                                                        // Glitch Filter SDA
#define LPI2C0_SCFGR2_FILTSDA(_n)                (((uint32_t)(_n) & 0xf) << 24)
#define LPI2C0_SCFGR2_FILTSDA_INSERT(_v, _n)         (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define LPI2C0_SCFGR2_FILTSDA_EXTRACT(_v)            (((_v) >> 24) & 0xf)

    uint8_t _res8[20];
    uint32_t             SAMR;                                          // Slave Address Match Register
                                                                        // Address 0 Value
#define LPI2C0_SAMR_ADDR0(_n)                    (((uint32_t)(_n) & 0x3ff) << 1)
#define LPI2C0_SAMR_ADDR0_INSERT(_v, _n)             (((_v) & ~0x7fe) | ((uint32_t)(_n) & 0x3ff) << 1)
#define LPI2C0_SAMR_ADDR0_EXTRACT(_v)                (((_v) >> 1) & 0x3ff)
                                                                        // Address 1 Value
#define LPI2C0_SAMR_ADDR1(_n)                    (((uint32_t)(_n) & 0x3ff) << 17)
#define LPI2C0_SAMR_ADDR1_INSERT(_v, _n)             (((_v) & ~0x7fe0000) | ((uint32_t)(_n) & 0x3ff) << 17)
#define LPI2C0_SAMR_ADDR1_EXTRACT(_v)                (((_v) >> 17) & 0x3ff)

    uint8_t _res9[12];
    const uint32_t       SASR;                                          // Slave Address Status Register
                                                                        // Received Address
#define LPI2C0_SASR_RADDR_EXTRACT(_v)                (((_v) >> 0) & 0x7ff)
#define LPI2C0_SASR_ANV                          ((uint32_t)1 << 14)    // Address Not Valid
#define   LPI2C0_SASR_ANV_0                      (uint32_t)0x0          // RADDR is valid.
#define   LPI2C0_SASR_ANV_1                      (uint32_t)0x1          // RADDR is not valid.

    uint32_t             STAR;                                          // Slave Transmit ACK Register
#define LPI2C0_STAR_TXNACK                       ((uint32_t)1 << 0)     // Transmit NACK
#define   LPI2C0_STAR_TXNACK_0                   (uint32_t)0x0          // Transmit ACK for received word.
#define   LPI2C0_STAR_TXNACK_1                   (uint32_t)0x1          // Transmit NACK for received word.

    uint8_t _res10[8];
    uint32_t             STDR;                                          // Slave Transmit Data Register
                                                                        // Transmit Data
#define LPI2C0_STDR_DATA(_n)                     (((uint32_t)(_n) & 0xff) << 0)
#define LPI2C0_STDR_DATA_INSERT(_v, _n)              (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define LPI2C0_STDR_DATA_EXTRACT(_v)                 (((_v) >> 0) & 0xff)

    uint8_t _res11[12];
    const uint32_t       SRDR;                                          // Slave Receive Data Register
                                                                        // Receive Data
#define LPI2C0_SRDR_DATA_EXTRACT(_v)                 (((_v) >> 0) & 0xff)
#define LPI2C0_SRDR_RXEMPTY                      ((uint32_t)1 << 14)    // RX Empty
#define   LPI2C0_SRDR_RXEMPTY_0                  (uint32_t)0x0          // The Receive Data Register is not empty.
#define   LPI2C0_SRDR_RXEMPTY_1                  (uint32_t)0x1          // The Receive Data Register is empty.
#define LPI2C0_SRDR_SOF                          ((uint32_t)1 << 15)    // Start Of Frame
#define   LPI2C0_SRDR_SOF_0                      (uint32_t)0x0          // Indicates this is not the first data word since a (repeated) START or STOP condition.
#define   LPI2C0_SRDR_SOF_1                      (uint32_t)0x1          // Indicates this is the first data word since a (repeated) START or STOP condition.

} LPI2C0_regs_t;
                                                                        // --------------------
                                                                        // Universal Asynchronous Receiver/Transmitter
typedef struct                                                          // --------------------
{
    const uint32_t       VERID;                                         // Version ID Register
                                                                        // Feature Identification Number
#define LPUART_VERID_FEATURE_EXTRACT(_v)             (((_v) >> 0) & 0xffff)
#define   LPUART_VERID_FEATURE_0000000000000001  (uint32_t)0x1          // Standard feature set.
#define   LPUART_VERID_FEATURE_0000000000000011  (uint32_t)0x3          // Standard feature set with MODEM/IrDA support.
                                                                        // Minor Version Number
#define LPUART_VERID_MINOR_EXTRACT(_v)               (((_v) >> 16) & 0xff)
                                                                        // Major Version Number
#define LPUART_VERID_MAJOR_EXTRACT(_v)               (((_v) >> 24) & 0xff)

    const uint32_t       PARAM;                                         // Parameter Register
                                                                        // Transmit FIFO Size
#define LPUART_PARAM_TXFIFO_EXTRACT(_v)              (((_v) >> 0) & 0xff)
                                                                        // Receive FIFO Size
#define LPUART_PARAM_RXFIFO_EXTRACT(_v)              (((_v) >> 8) & 0xff)

    uint32_t             GLOBAL;                                        // LPUART Global Register
#define LPUART_GLOBAL_RST                        ((uint32_t)1 << 1)     // Software Reset
#define   LPUART_GLOBAL_RST_0                    (uint32_t)0x0          // Module is not reset.
#define   LPUART_GLOBAL_RST_1                    (uint32_t)0x1          // Module is reset.

    uint32_t             PINCFG;                                        // LPUART Pin Configuration Register
                                                                        // Trigger Select
#define LPUART_PINCFG_TRGSEL(_n)                 (((uint32_t)(_n) & 0x3) << 0)
#define LPUART_PINCFG_TRGSEL_INSERT(_v, _n)          (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define LPUART_PINCFG_TRGSEL_EXTRACT(_v)             (((_v) >> 0) & 0x3)
#define   LPUART_PINCFG_TRGSEL_00                (uint32_t)0x0          // Input trigger is disabled.
#define   LPUART_PINCFG_TRGSEL_01                (uint32_t)0x1          // Input trigger is used instead of RXD pin input.
#define   LPUART_PINCFG_TRGSEL_10                (uint32_t)0x2          // Input trigger is used instead of CTS_B pin input.
#define   LPUART_PINCFG_TRGSEL_11                (uint32_t)0x3          // Input trigger is used to modulate the TXD pin output. The TXD pin output (after TXINV configuration) is ANDed with the input trigger.

    uint32_t             BAUD;                                          // LPUART Baud Rate Register
                                                                        // Baud Rate Modulo Divisor.
#define LPUART_BAUD_SBR(_n)                      (((uint32_t)(_n) & 0x1fff) << 0)
#define LPUART_BAUD_SBR_INSERT(_v, _n)               (((_v) & ~0x1fff) | ((uint32_t)(_n) & 0x1fff) << 0)
#define LPUART_BAUD_SBR_EXTRACT(_v)                  (((_v) >> 0) & 0x1fff)
#define LPUART_BAUD_SBNS                         ((uint32_t)1 << 13)    // Stop Bit Number Select
#define   LPUART_BAUD_SBNS_0                     (uint32_t)0x0          // One stop bit.
#define   LPUART_BAUD_SBNS_1                     (uint32_t)0x1          // Two stop bits.
#define LPUART_BAUD_RXEDGIE                      ((uint32_t)1 << 14)    // RX Input Active Edge Interrupt Enable
#define   LPUART_BAUD_RXEDGIE_0                  (uint32_t)0x0          // Hardware interrupts from LPUART_STAT[RXEDGIF] disabled.
#define   LPUART_BAUD_RXEDGIE_1                  (uint32_t)0x1          // Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.
#define LPUART_BAUD_LBKDIE                       ((uint32_t)1 << 15)    // LIN Break Detect Interrupt Enable
#define   LPUART_BAUD_LBKDIE_0                   (uint32_t)0x0          // Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
#define   LPUART_BAUD_LBKDIE_1                   (uint32_t)0x1          // Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.
#define LPUART_BAUD_RESYNCDIS                    ((uint32_t)1 << 16)    // Resynchronization Disable
#define   LPUART_BAUD_RESYNCDIS_0                (uint32_t)0x0          // Resynchronization during received data word is supported
#define   LPUART_BAUD_RESYNCDIS_1                (uint32_t)0x1          // Resynchronization during received data word is disabled
#define LPUART_BAUD_BOTHEDGE                     ((uint32_t)1 << 17)    // Both Edge Sampling
#define   LPUART_BAUD_BOTHEDGE_0                 (uint32_t)0x0          // Receiver samples input data using the rising edge of the baud rate clock.
#define   LPUART_BAUD_BOTHEDGE_1                 (uint32_t)0x1          // Receiver samples input data using the rising and falling edge of the baud rate clock.
                                                                        // Match Configuration
#define LPUART_BAUD_MATCFG(_n)                   (((uint32_t)(_n) & 0x3) << 18)
#define LPUART_BAUD_MATCFG_INSERT(_v, _n)            (((_v) & ~0xc0000) | ((uint32_t)(_n) & 0x3) << 18)
#define LPUART_BAUD_MATCFG_EXTRACT(_v)               (((_v) >> 18) & 0x3)
#define   LPUART_BAUD_MATCFG_00                  (uint32_t)0x0          // Address Match Wakeup
#define   LPUART_BAUD_MATCFG_01                  (uint32_t)0x1          // Idle Match Wakeup
#define   LPUART_BAUD_MATCFG_10                  (uint32_t)0x2          // Match On and Match Off
#define LPUART_BAUD_RIDMAE                       ((uint32_t)1 << 20)    // Receiver Idle DMA Enable
#define   LPUART_BAUD_RIDMAE_0                   (uint32_t)0x0          // DMA request disabled.
#define   LPUART_BAUD_RIDMAE_1                   (uint32_t)0x1          // DMA request enabled.
#define LPUART_BAUD_RDMAE                        ((uint32_t)1 << 21)    // Receiver Full DMA Enable
#define   LPUART_BAUD_RDMAE_0                    (uint32_t)0x0          // DMA request disabled.
#define   LPUART_BAUD_RDMAE_1                    (uint32_t)0x1          // DMA request enabled.
#define LPUART_BAUD_TDMAE                        ((uint32_t)1 << 23)    // Transmitter DMA Enable
#define   LPUART_BAUD_TDMAE_0                    (uint32_t)0x0          // DMA request disabled.
#define   LPUART_BAUD_TDMAE_1                    (uint32_t)0x1          // DMA request enabled.
                                                                        // Oversampling Ratio
#define LPUART_BAUD_OSR(_n)                      (((uint32_t)(_n) & 0x1f) << 24)
#define LPUART_BAUD_OSR_INSERT(_v, _n)               (((_v) & ~0x1f000000) | ((uint32_t)(_n) & 0x1f) << 24)
#define LPUART_BAUD_OSR_EXTRACT(_v)                  (((_v) >> 24) & 0x1f)
#define   LPUART_BAUD_OSR_00000                  (uint32_t)0x0          // Writing 0 to this field will result in an oversampling ratio of 16
#define   LPUART_BAUD_OSR_00011                  (uint32_t)0x3          // Oversampling ratio of 4, requires BOTHEDGE to be set.
#define   LPUART_BAUD_OSR_00100                  (uint32_t)0x4          // Oversampling ratio of 5, requires BOTHEDGE to be set.
#define   LPUART_BAUD_OSR_00101                  (uint32_t)0x5          // Oversampling ratio of 6, requires BOTHEDGE to be set.
#define   LPUART_BAUD_OSR_00110                  (uint32_t)0x6          // Oversampling ratio of 7, requires BOTHEDGE to be set.
#define   LPUART_BAUD_OSR_00111                  (uint32_t)0x7          // Oversampling ratio of 8.
#define   LPUART_BAUD_OSR_01000                  (uint32_t)0x8          // Oversampling ratio of 9.
#define   LPUART_BAUD_OSR_01001                  (uint32_t)0x9          // Oversampling ratio of 10.
#define   LPUART_BAUD_OSR_01010                  (uint32_t)0xa          // Oversampling ratio of 11.
#define   LPUART_BAUD_OSR_01011                  (uint32_t)0xb          // Oversampling ratio of 12.
#define   LPUART_BAUD_OSR_01100                  (uint32_t)0xc          // Oversampling ratio of 13.
#define   LPUART_BAUD_OSR_01101                  (uint32_t)0xd          // Oversampling ratio of 14.
#define   LPUART_BAUD_OSR_01110                  (uint32_t)0xe          // Oversampling ratio of 15.
#define   LPUART_BAUD_OSR_01111                  (uint32_t)0xf          // Oversampling ratio of 16.
#define   LPUART_BAUD_OSR_10000                  (uint32_t)0x10         // Oversampling ratio of 17.
#define   LPUART_BAUD_OSR_10001                  (uint32_t)0x11         // Oversampling ratio of 18.
#define   LPUART_BAUD_OSR_10010                  (uint32_t)0x12         // Oversampling ratio of 19.
#define   LPUART_BAUD_OSR_10011                  (uint32_t)0x13         // Oversampling ratio of 20.
#define   LPUART_BAUD_OSR_10100                  (uint32_t)0x14         // Oversampling ratio of 21.
#define   LPUART_BAUD_OSR_10101                  (uint32_t)0x15         // Oversampling ratio of 22.
#define   LPUART_BAUD_OSR_10110                  (uint32_t)0x16         // Oversampling ratio of 23.
#define   LPUART_BAUD_OSR_10111                  (uint32_t)0x17         // Oversampling ratio of 24.
#define   LPUART_BAUD_OSR_11000                  (uint32_t)0x18         // Oversampling ratio of 25.
#define   LPUART_BAUD_OSR_11001                  (uint32_t)0x19         // Oversampling ratio of 26.
#define   LPUART_BAUD_OSR_11010                  (uint32_t)0x1a         // Oversampling ratio of 27.
#define   LPUART_BAUD_OSR_11011                  (uint32_t)0x1b         // Oversampling ratio of 28.
#define   LPUART_BAUD_OSR_11100                  (uint32_t)0x1c         // Oversampling ratio of 29.
#define   LPUART_BAUD_OSR_11101                  (uint32_t)0x1d         // Oversampling ratio of 30.
#define   LPUART_BAUD_OSR_11110                  (uint32_t)0x1e         // Oversampling ratio of 31.
#define   LPUART_BAUD_OSR_11111                  (uint32_t)0x1f         // Oversampling ratio of 32.
#define LPUART_BAUD_M10                          ((uint32_t)1 << 29)    // 10-bit Mode select
#define   LPUART_BAUD_M10_0                      (uint32_t)0x0          // Receiver and transmitter use 7-bit to 9-bit data characters.
#define   LPUART_BAUD_M10_1                      (uint32_t)0x1          // Receiver and transmitter use 10-bit data characters.
#define LPUART_BAUD_MAEN2                        ((uint32_t)1 << 30)    // Match Address Mode Enable 2
#define   LPUART_BAUD_MAEN2_0                    (uint32_t)0x0          // Normal operation.
#define   LPUART_BAUD_MAEN2_1                    (uint32_t)0x1          // Enables automatic address matching or data matching mode for MATCH[MA2].
#define LPUART_BAUD_MAEN1                        ((uint32_t)1 << 31)    // Match Address Mode Enable 1
#define   LPUART_BAUD_MAEN1_0                    (uint32_t)0x0          // Normal operation.
#define   LPUART_BAUD_MAEN1_1                    (uint32_t)0x1          // Enables automatic address matching or data matching mode for MATCH[MA1].

    uint32_t             STAT;                                          // LPUART Status Register
#define LPUART_STAT_MA2F                         ((uint32_t)1 << 14)    // Match 2 Flag
#define   LPUART_STAT_MA2F_0                     (uint32_t)0x0          // Received data is not equal to MA2
#define   LPUART_STAT_MA2F_1                     (uint32_t)0x1          // Received data is equal to MA2
#define LPUART_STAT_MA1F                         ((uint32_t)1 << 15)    // Match 1 Flag
#define   LPUART_STAT_MA1F_0                     (uint32_t)0x0          // Received data is not equal to MA1
#define   LPUART_STAT_MA1F_1                     (uint32_t)0x1          // Received data is equal to MA1
#define LPUART_STAT_PF                           ((uint32_t)1 << 16)    // Parity Error Flag
#define   LPUART_STAT_PF_0                       (uint32_t)0x0          // No parity error.
#define   LPUART_STAT_PF_1                       (uint32_t)0x1          // Parity error.
#define LPUART_STAT_FE                           ((uint32_t)1 << 17)    // Framing Error Flag
#define   LPUART_STAT_FE_0                       (uint32_t)0x0          // No framing error detected. This does not guarantee the framing is correct.
#define   LPUART_STAT_FE_1                       (uint32_t)0x1          // Framing error.
#define LPUART_STAT_NF                           ((uint32_t)1 << 18)    // Noise Flag
#define   LPUART_STAT_NF_0                       (uint32_t)0x0          // No noise detected.
#define   LPUART_STAT_NF_1                       (uint32_t)0x1          // Noise detected in the received character in LPUART_DATA.
#define LPUART_STAT_OR                           ((uint32_t)1 << 19)    // Receiver Overrun Flag
#define   LPUART_STAT_OR_0                       (uint32_t)0x0          // No overrun.
#define   LPUART_STAT_OR_1                       (uint32_t)0x1          // Receive overrun (new LPUART data lost).
#define LPUART_STAT_IDLE                         ((uint32_t)1 << 20)    // Idle Line Flag
#define   LPUART_STAT_IDLE_0                     (uint32_t)0x0          // No idle line detected.
#define   LPUART_STAT_IDLE_1                     (uint32_t)0x1          // Idle line was detected.
#define LPUART_STAT_RDRF                         ((uint32_t)1 << 21)    // Receive Data Register Full Flag
#define   LPUART_STAT_RDRF_0                     (uint32_t)0x0          // Receive data buffer empty.
#define   LPUART_STAT_RDRF_1                     (uint32_t)0x1          // Receive data buffer full.
#define LPUART_STAT_TC                           ((uint32_t)1 << 22)    // Transmission Complete Flag
#define   LPUART_STAT_TC_0                       (uint32_t)0x0          // Transmitter active (sending data, a preamble, or a break).
#define   LPUART_STAT_TC_1                       (uint32_t)0x1          // Transmitter idle (transmission activity complete).
#define LPUART_STAT_TDRE                         ((uint32_t)1 << 23)    // Transmit Data Register Empty Flag
#define   LPUART_STAT_TDRE_0                     (uint32_t)0x0          // Transmit data buffer full.
#define   LPUART_STAT_TDRE_1                     (uint32_t)0x1          // Transmit data buffer empty.
#define LPUART_STAT_RAF                          ((uint32_t)1 << 24)    // Receiver Active Flag
#define   LPUART_STAT_RAF_0                      (uint32_t)0x0          // LPUART receiver idle waiting for a start bit.
#define   LPUART_STAT_RAF_1                      (uint32_t)0x1          // LPUART receiver active (RXD input not idle).
#define LPUART_STAT_LBKDE                        ((uint32_t)1 << 25)    // LIN Break Detection Enable
#define   LPUART_STAT_LBKDE_0                    (uint32_t)0x0          // LIN break detect is disabled, normal break character can be detected.
#define   LPUART_STAT_LBKDE_1                    (uint32_t)0x1          // LIN break detect is enabled. LIN break character is detected at length of 11 bit times (if M = 0) or 12 (if M = 1) or 13 (M10 = 1).
#define LPUART_STAT_BRK13                        ((uint32_t)1 << 26)    // Break Character Generation Length
#define   LPUART_STAT_BRK13_0                    (uint32_t)0x0          // Break character is transmitted with length of 9 to 13 bit times.
#define   LPUART_STAT_BRK13_1                    (uint32_t)0x1          // Break character is transmitted with length of 12 to 15 bit times.
#define LPUART_STAT_RWUID                        ((uint32_t)1 << 27)    // Receive Wake Up Idle Detect
#define   LPUART_STAT_RWUID_0                    (uint32_t)0x0          // During receive standby state (RWU = 1), the IDLE bit does not get set upon detection of an idle character. During address match wakeup, the IDLE bit does not set when an address does not match.
#define   LPUART_STAT_RWUID_1                    (uint32_t)0x1          // During receive standby state (RWU = 1), the IDLE bit gets set upon detection of an idle character. During address match wakeup, the IDLE bit does set when an address does not match.
#define LPUART_STAT_RXINV                        ((uint32_t)1 << 28)    // Receive Data Inversion
#define   LPUART_STAT_RXINV_0                    (uint32_t)0x0          // Receive data not inverted.
#define   LPUART_STAT_RXINV_1                    (uint32_t)0x1          // Receive data inverted.
#define LPUART_STAT_MSBF                         ((uint32_t)1 << 29)    // MSB First
#define   LPUART_STAT_MSBF_0                     (uint32_t)0x0          // LSB (bit0) is the first bit that is transmitted following the start bit. Further, the first bit received after the start bit is identified as bit0.
#define   LPUART_STAT_MSBF_1                     (uint32_t)0x1          // MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted following the start bit depending on the setting of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first bit received after the start bit is identified as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and CTRL[PE].
#define LPUART_STAT_RXEDGIF                      ((uint32_t)1 << 30)    // RXD Pin Active Edge Interrupt Flag
#define   LPUART_STAT_RXEDGIF_0                  (uint32_t)0x0          // No active edge on the receive pin has occurred.
#define   LPUART_STAT_RXEDGIF_1                  (uint32_t)0x1          // An active edge on the receive pin has occurred.
#define LPUART_STAT_LBKDIF                       ((uint32_t)1 << 31)    // LIN Break Detect Interrupt Flag
#define   LPUART_STAT_LBKDIF_0                   (uint32_t)0x0          // No LIN break character has been detected.
#define   LPUART_STAT_LBKDIF_1                   (uint32_t)0x1          // LIN break character has been detected.

    uint32_t             CTRL;                                          // LPUART Control Register
#define LPUART_CTRL_PT                           ((uint32_t)1 << 0)     // Parity Type
#define   LPUART_CTRL_PT_0                       (uint32_t)0x0          // Even parity.
#define   LPUART_CTRL_PT_1                       (uint32_t)0x1          // Odd parity.
#define LPUART_CTRL_PE                           ((uint32_t)1 << 1)     // Parity Enable
#define   LPUART_CTRL_PE_0                       (uint32_t)0x0          // No hardware parity generation or checking.
#define   LPUART_CTRL_PE_1                       (uint32_t)0x1          // Parity enabled.
#define LPUART_CTRL_ILT                          ((uint32_t)1 << 2)     // Idle Line Type Select
#define   LPUART_CTRL_ILT_0                      (uint32_t)0x0          // Idle character bit count starts after start bit.
#define   LPUART_CTRL_ILT_1                      (uint32_t)0x1          // Idle character bit count starts after stop bit.
#define LPUART_CTRL_WAKE                         ((uint32_t)1 << 3)     // Receiver Wakeup Method Select
#define   LPUART_CTRL_WAKE_0                     (uint32_t)0x0          // Configures RWU for idle-line wakeup.
#define   LPUART_CTRL_WAKE_1                     (uint32_t)0x1          // Configures RWU with address-mark wakeup.
#define LPUART_CTRL_M                            ((uint32_t)1 << 4)     // 9-Bit or 8-Bit Mode Select
#define   LPUART_CTRL_M_0                        (uint32_t)0x0          // Receiver and transmitter use 8-bit data characters.
#define   LPUART_CTRL_M_1                        (uint32_t)0x1          // Receiver and transmitter use 9-bit data characters.
#define LPUART_CTRL_RSRC                         ((uint32_t)1 << 5)     // Receiver Source Select
#define   LPUART_CTRL_RSRC_0                     (uint32_t)0x0          // Provided LOOPS is set, RSRC is cleared, selects internal loop back mode and the LPUART does not use the RXD pin.
#define   LPUART_CTRL_RSRC_1                     (uint32_t)0x1          // Single-wire LPUART mode where the TXD pin is connected to the transmitter output and receiver input.
#define LPUART_CTRL_DOZEEN                       ((uint32_t)1 << 6)     // Doze Enable
#define   LPUART_CTRL_DOZEEN_0                   (uint32_t)0x0          // LPUART is enabled in Doze mode.
#define   LPUART_CTRL_DOZEEN_1                   (uint32_t)0x1          // LPUART is disabled in Doze mode.
#define LPUART_CTRL_LOOPS                        ((uint32_t)1 << 7)     // Loop Mode Select
#define   LPUART_CTRL_LOOPS_0                    (uint32_t)0x0          // Normal operation - RXD and TXD use separate pins.
#define   LPUART_CTRL_LOOPS_1                    (uint32_t)0x1          // Loop mode or single-wire mode where transmitter outputs are internally connected to receiver input (see RSRC bit).
                                                                        // Idle Configuration
#define LPUART_CTRL_IDLECFG(_n)                  (((uint32_t)(_n) & 0x7) << 8)
#define LPUART_CTRL_IDLECFG_INSERT(_v, _n)           (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define LPUART_CTRL_IDLECFG_EXTRACT(_v)              (((_v) >> 8) & 0x7)
#define   LPUART_CTRL_IDLECFG_000                (uint32_t)0x0          // 1 idle character
#define   LPUART_CTRL_IDLECFG_001                (uint32_t)0x1          // 2 idle characters
#define   LPUART_CTRL_IDLECFG_010                (uint32_t)0x2          // 4 idle characters
#define   LPUART_CTRL_IDLECFG_011                (uint32_t)0x3          // 8 idle characters
#define   LPUART_CTRL_IDLECFG_100                (uint32_t)0x4          // 16 idle characters
#define   LPUART_CTRL_IDLECFG_101                (uint32_t)0x5          // 32 idle characters
#define   LPUART_CTRL_IDLECFG_110                (uint32_t)0x6          // 64 idle characters
#define   LPUART_CTRL_IDLECFG_111                (uint32_t)0x7          // 128 idle characters
#define LPUART_CTRL_M7                           ((uint32_t)1 << 11)    // 7-Bit Mode Select
#define   LPUART_CTRL_M7_0                       (uint32_t)0x0          // Receiver and transmitter use 8-bit to 10-bit data characters.
#define   LPUART_CTRL_M7_1                       (uint32_t)0x1          // Receiver and transmitter use 7-bit data characters.
#define LPUART_CTRL_MA2IE                        ((uint32_t)1 << 14)    // Match 2 Interrupt Enable
#define   LPUART_CTRL_MA2IE_0                    (uint32_t)0x0          // MA2F interrupt disabled
#define   LPUART_CTRL_MA2IE_1                    (uint32_t)0x1          // MA2F interrupt enabled
#define LPUART_CTRL_MA1IE                        ((uint32_t)1 << 15)    // Match 1 Interrupt Enable
#define   LPUART_CTRL_MA1IE_0                    (uint32_t)0x0          // MA1F interrupt disabled
#define   LPUART_CTRL_MA1IE_1                    (uint32_t)0x1          // MA1F interrupt enabled
#define LPUART_CTRL_SBK                          ((uint32_t)1 << 16)    // Send Break
#define   LPUART_CTRL_SBK_0                      (uint32_t)0x0          // Normal transmitter operation.
#define   LPUART_CTRL_SBK_1                      (uint32_t)0x1          // Queue break character(s) to be sent.
#define LPUART_CTRL_RWU                          ((uint32_t)1 << 17)    // Receiver Wakeup Control
#define   LPUART_CTRL_RWU_0                      (uint32_t)0x0          // Normal receiver operation.
#define   LPUART_CTRL_RWU_1                      (uint32_t)0x1          // LPUART receiver in standby waiting for wakeup condition.
#define LPUART_CTRL_RE                           ((uint32_t)1 << 18)    // Receiver Enable
#define   LPUART_CTRL_RE_0                       (uint32_t)0x0          // Receiver disabled.
#define   LPUART_CTRL_RE_1                       (uint32_t)0x1          // Receiver enabled.
#define LPUART_CTRL_TE                           ((uint32_t)1 << 19)    // Transmitter Enable
#define   LPUART_CTRL_TE_0                       (uint32_t)0x0          // Transmitter disabled.
#define   LPUART_CTRL_TE_1                       (uint32_t)0x1          // Transmitter enabled.
#define LPUART_CTRL_ILIE                         ((uint32_t)1 << 20)    // Idle Line Interrupt Enable
#define   LPUART_CTRL_ILIE_0                     (uint32_t)0x0          // Hardware interrupts from IDLE disabled; use polling.
#define   LPUART_CTRL_ILIE_1                     (uint32_t)0x1          // Hardware interrupt requested when IDLE flag is 1.
#define LPUART_CTRL_RIE                          ((uint32_t)1 << 21)    // Receiver Interrupt Enable
#define   LPUART_CTRL_RIE_0                      (uint32_t)0x0          // Hardware interrupts from RDRF disabled; use polling.
#define   LPUART_CTRL_RIE_1                      (uint32_t)0x1          // Hardware interrupt requested when RDRF flag is 1.
#define LPUART_CTRL_TCIE                         ((uint32_t)1 << 22)    // Transmission Complete Interrupt Enable for
#define   LPUART_CTRL_TCIE_0                     (uint32_t)0x0          // Hardware interrupts from TC disabled; use polling.
#define   LPUART_CTRL_TCIE_1                     (uint32_t)0x1          // Hardware interrupt requested when TC flag is 1.
#define LPUART_CTRL_TIE                          ((uint32_t)1 << 23)    // Transmit Interrupt Enable
#define   LPUART_CTRL_TIE_0                      (uint32_t)0x0          // Hardware interrupts from TDRE disabled; use polling.
#define   LPUART_CTRL_TIE_1                      (uint32_t)0x1          // Hardware interrupt requested when TDRE flag is 1.
#define LPUART_CTRL_PEIE                         ((uint32_t)1 << 24)    // Parity Error Interrupt Enable
#define   LPUART_CTRL_PEIE_0                     (uint32_t)0x0          // PF interrupts disabled; use polling).
#define   LPUART_CTRL_PEIE_1                     (uint32_t)0x1          // Hardware interrupt requested when PF is set.
#define LPUART_CTRL_FEIE                         ((uint32_t)1 << 25)    // Framing Error Interrupt Enable
#define   LPUART_CTRL_FEIE_0                     (uint32_t)0x0          // FE interrupts disabled; use polling.
#define   LPUART_CTRL_FEIE_1                     (uint32_t)0x1          // Hardware interrupt requested when FE is set.
#define LPUART_CTRL_NEIE                         ((uint32_t)1 << 26)    // Noise Error Interrupt Enable
#define   LPUART_CTRL_NEIE_0                     (uint32_t)0x0          // NF interrupts disabled; use polling.
#define   LPUART_CTRL_NEIE_1                     (uint32_t)0x1          // Hardware interrupt requested when NF is set.
#define LPUART_CTRL_ORIE                         ((uint32_t)1 << 27)    // Overrun Interrupt Enable
#define   LPUART_CTRL_ORIE_0                     (uint32_t)0x0          // OR interrupts disabled; use polling.
#define   LPUART_CTRL_ORIE_1                     (uint32_t)0x1          // Hardware interrupt requested when OR is set.
#define LPUART_CTRL_TXINV                        ((uint32_t)1 << 28)    // Transmit Data Inversion
#define   LPUART_CTRL_TXINV_0                    (uint32_t)0x0          // Transmit data not inverted.
#define   LPUART_CTRL_TXINV_1                    (uint32_t)0x1          // Transmit data inverted.
#define LPUART_CTRL_TXDIR                        ((uint32_t)1 << 29)    // TXD Pin Direction in Single-Wire Mode
#define   LPUART_CTRL_TXDIR_0                    (uint32_t)0x0          // TXD pin is an input in single-wire mode.
#define   LPUART_CTRL_TXDIR_1                    (uint32_t)0x1          // TXD pin is an output in single-wire mode.
#define LPUART_CTRL_R9T8                         ((uint32_t)1 << 30)    // Receive Bit 9 / Transmit Bit 8
#define LPUART_CTRL_R8T9                         ((uint32_t)1 << 31)    // Receive Bit 8 / Transmit Bit 9

    uint32_t             DATA;                                          // LPUART Data Register
#define LPUART_DATA_R0T0                         ((uint32_t)1 << 0)     // R0T0
#define LPUART_DATA_R1T1                         ((uint32_t)1 << 1)     // R1T1
#define LPUART_DATA_R2T2                         ((uint32_t)1 << 2)     // R2T2
#define LPUART_DATA_R3T3                         ((uint32_t)1 << 3)     // R3T3
#define LPUART_DATA_R4T4                         ((uint32_t)1 << 4)     // R4T4
#define LPUART_DATA_R5T5                         ((uint32_t)1 << 5)     // R5T5
#define LPUART_DATA_R6T6                         ((uint32_t)1 << 6)     // R6T6
#define LPUART_DATA_R7T7                         ((uint32_t)1 << 7)     // R7T7
#define LPUART_DATA_R8T8                         ((uint32_t)1 << 8)     // R8T8
#define LPUART_DATA_R9T9                         ((uint32_t)1 << 9)     // R9T9
#define LPUART_DATA_IDLINE                       ((uint32_t)1 << 11)    // Idle Line
#define   LPUART_DATA_IDLINE_0                   (uint32_t)0x0          // Receiver was not idle before receiving this character.
#define   LPUART_DATA_IDLINE_1                   (uint32_t)0x1          // Receiver was idle before receiving this character.
#define LPUART_DATA_RXEMPT                       ((uint32_t)1 << 12)    // Receive Buffer Empty
#define   LPUART_DATA_RXEMPT_0                   (uint32_t)0x0          // Receive buffer contains valid data.
#define   LPUART_DATA_RXEMPT_1                   (uint32_t)0x1          // Receive buffer is empty, data returned on read is not valid.
#define LPUART_DATA_FRETSC                       ((uint32_t)1 << 13)    // Frame Error / Transmit Special Character
#define   LPUART_DATA_FRETSC_0                   (uint32_t)0x0          // The dataword was received without a frame error on read, or transmit a normal character on write.
#define   LPUART_DATA_FRETSC_1                   (uint32_t)0x1          // The dataword was received with a frame error, or transmit an idle or break character on transmit.
#define LPUART_DATA_PARITYE                      ((uint32_t)1 << 14)    // PARITYE
#define   LPUART_DATA_PARITYE_0                  (uint32_t)0x0          // The dataword was received without a parity error.
#define   LPUART_DATA_PARITYE_1                  (uint32_t)0x1          // The dataword was received with a parity error.
#define LPUART_DATA_NOISY                        ((uint32_t)1 << 15)    // NOISY
#define   LPUART_DATA_NOISY_0                    (uint32_t)0x0          // The dataword was received without noise.
#define   LPUART_DATA_NOISY_1                    (uint32_t)0x1          // The data was received with noise.

    uint32_t             MATCH;                                         // LPUART Match Address Register
                                                                        // Match Address 1
#define LPUART_MATCH_MA1(_n)                     (((uint32_t)(_n) & 0x3ff) << 0)
#define LPUART_MATCH_MA1_INSERT(_v, _n)              (((_v) & ~0x3ff) | ((uint32_t)(_n) & 0x3ff) << 0)
#define LPUART_MATCH_MA1_EXTRACT(_v)                 (((_v) >> 0) & 0x3ff)
                                                                        // Match Address 2
#define LPUART_MATCH_MA2(_n)                     (((uint32_t)(_n) & 0x3ff) << 16)
#define LPUART_MATCH_MA2_INSERT(_v, _n)              (((_v) & ~0x3ff0000) | ((uint32_t)(_n) & 0x3ff) << 16)
#define LPUART_MATCH_MA2_EXTRACT(_v)                 (((_v) >> 16) & 0x3ff)

    uint32_t             MODIR;                                         // LPUART Modem IrDA Register
#define LPUART_MODIR_TXCTSE                      ((uint32_t)1 << 0)     // Transmitter clear-to-send enable
#define   LPUART_MODIR_TXCTSE_0                  (uint32_t)0x0          // CTS has no effect on the transmitter.
#define   LPUART_MODIR_TXCTSE_1                  (uint32_t)0x1          // Enables clear-to-send operation. The transmitter checks the state of CTS each time it is ready to send a character. If CTS is asserted, the character is sent. If CTS is deasserted, the signal TXD remains in the mark state and transmission is delayed until CTS is asserted. Changes in CTS as a character is being sent do not affect its transmission.
#define LPUART_MODIR_TXRTSE                      ((uint32_t)1 << 1)     // Transmitter request-to-send enable
#define   LPUART_MODIR_TXRTSE_0                  (uint32_t)0x0          // The transmitter has no effect on RTS.
#define   LPUART_MODIR_TXRTSE_1                  (uint32_t)0x1          // When a character is placed into an empty transmitter data buffer , RTS asserts one bit time before the start bit is transmitted. RTS deasserts one bit time after all characters in the transmitter data buffer and shift register are completely sent, including the last stop bit.
#define LPUART_MODIR_TXRTSPOL                    ((uint32_t)1 << 2)     // Transmitter request-to-send polarity
#define   LPUART_MODIR_TXRTSPOL_0                (uint32_t)0x0          // Transmitter RTS is active low.
#define   LPUART_MODIR_TXRTSPOL_1                (uint32_t)0x1          // Transmitter RTS is active high.
#define LPUART_MODIR_RXRTSE                      ((uint32_t)1 << 3)     // Receiver request-to-send enable
#define   LPUART_MODIR_RXRTSE_0                  (uint32_t)0x0          // The receiver has no effect on RTS.
#define LPUART_MODIR_TXCTSC                      ((uint32_t)1 << 4)     // Transmit CTS Configuration
#define   LPUART_MODIR_TXCTSC_0                  (uint32_t)0x0          // CTS input is sampled at the start of each character.
#define   LPUART_MODIR_TXCTSC_1                  (uint32_t)0x1          // CTS input is sampled when the transmitter is idle.
#define LPUART_MODIR_TXCTSSRC                    ((uint32_t)1 << 5)     // Transmit CTS Source
#define   LPUART_MODIR_TXCTSSRC_0                (uint32_t)0x0          // CTS input is the CTS_B pin.
#define   LPUART_MODIR_TXCTSSRC_1                (uint32_t)0x1          // CTS input is the inverted Receiver Match result.
                                                                        // Receive RTS Configuration
#define LPUART_MODIR_RTSWATER(_n)                (((uint32_t)(_n) & 0x3) << 8)
#define LPUART_MODIR_RTSWATER_INSERT(_v, _n)         (((_v) & ~0x300) | ((uint32_t)(_n) & 0x3) << 8)
#define LPUART_MODIR_RTSWATER_EXTRACT(_v)            (((_v) >> 8) & 0x3)
                                                                        // Transmitter narrow pulse
#define LPUART_MODIR_TNP(_n)                     (((uint32_t)(_n) & 0x3) << 16)
#define LPUART_MODIR_TNP_INSERT(_v, _n)              (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define LPUART_MODIR_TNP_EXTRACT(_v)                 (((_v) >> 16) & 0x3)
#define   LPUART_MODIR_TNP_00                    (uint32_t)0x0          // 1/OSR.
#define   LPUART_MODIR_TNP_01                    (uint32_t)0x1          // 2/OSR.
#define   LPUART_MODIR_TNP_10                    (uint32_t)0x2          // 3/OSR.
#define   LPUART_MODIR_TNP_11                    (uint32_t)0x3          // 4/OSR.
#define LPUART_MODIR_IREN                        ((uint32_t)1 << 18)    // Infrared enable
#define   LPUART_MODIR_IREN_0                    (uint32_t)0x0          // IR disabled.
#define   LPUART_MODIR_IREN_1                    (uint32_t)0x1          // IR enabled.

    uint32_t             FIFO;                                          // LPUART FIFO Register
                                                                        // Receive FIFO. Buffer Depth
#define LPUART_FIFO_RXFIFOSIZE(_n)               (((uint32_t)(_n) & 0x7) << 0)
#define LPUART_FIFO_RXFIFOSIZE_INSERT(_v, _n)        (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define LPUART_FIFO_RXFIFOSIZE_EXTRACT(_v)           (((_v) >> 0) & 0x7)
#define   LPUART_FIFO_RXFIFOSIZE_000             (uint32_t)0x0          // Receive FIFO/Buffer depth = 1 dataword.
#define   LPUART_FIFO_RXFIFOSIZE_001             (uint32_t)0x1          // Receive FIFO/Buffer depth = 4 datawords.
#define   LPUART_FIFO_RXFIFOSIZE_010             (uint32_t)0x2          // Receive FIFO/Buffer depth = 8 datawords.
#define   LPUART_FIFO_RXFIFOSIZE_011             (uint32_t)0x3          // Receive FIFO/Buffer depth = 16 datawords.
#define   LPUART_FIFO_RXFIFOSIZE_100             (uint32_t)0x4          // Receive FIFO/Buffer depth = 32 datawords.
#define   LPUART_FIFO_RXFIFOSIZE_101             (uint32_t)0x5          // Receive FIFO/Buffer depth = 64 datawords.
#define   LPUART_FIFO_RXFIFOSIZE_110             (uint32_t)0x6          // Receive FIFO/Buffer depth = 128 datawords.
#define   LPUART_FIFO_RXFIFOSIZE_111             (uint32_t)0x7          // Receive FIFO/Buffer depth = 256 datawords.
#define LPUART_FIFO_RXFE                         ((uint32_t)1 << 3)     // Receive FIFO Enable
#define   LPUART_FIFO_RXFE_0                     (uint32_t)0x0          // Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
#define   LPUART_FIFO_RXFE_1                     (uint32_t)0x1          // Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
                                                                        // Transmit FIFO. Buffer Depth
#define LPUART_FIFO_TXFIFOSIZE(_n)               (((uint32_t)(_n) & 0x7) << 4)
#define LPUART_FIFO_TXFIFOSIZE_INSERT(_v, _n)        (((_v) & ~0x70) | ((uint32_t)(_n) & 0x7) << 4)
#define LPUART_FIFO_TXFIFOSIZE_EXTRACT(_v)           (((_v) >> 4) & 0x7)
#define   LPUART_FIFO_TXFIFOSIZE_000             (uint32_t)0x0          // Transmit FIFO/Buffer depth = 1 dataword.
#define   LPUART_FIFO_TXFIFOSIZE_001             (uint32_t)0x1          // Transmit FIFO/Buffer depth = 4 datawords.
#define   LPUART_FIFO_TXFIFOSIZE_010             (uint32_t)0x2          // Transmit FIFO/Buffer depth = 8 datawords.
#define   LPUART_FIFO_TXFIFOSIZE_011             (uint32_t)0x3          // Transmit FIFO/Buffer depth = 16 datawords.
#define   LPUART_FIFO_TXFIFOSIZE_100             (uint32_t)0x4          // Transmit FIFO/Buffer depth = 32 datawords.
#define   LPUART_FIFO_TXFIFOSIZE_101             (uint32_t)0x5          // Transmit FIFO/Buffer depth = 64 datawords.
#define   LPUART_FIFO_TXFIFOSIZE_110             (uint32_t)0x6          // Transmit FIFO/Buffer depth = 128 datawords.
#define   LPUART_FIFO_TXFIFOSIZE_111             (uint32_t)0x7          // Transmit FIFO/Buffer depth = 256 datawords
#define LPUART_FIFO_TXFE                         ((uint32_t)1 << 7)     // Transmit FIFO Enable
#define   LPUART_FIFO_TXFE_0                     (uint32_t)0x0          // Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
#define   LPUART_FIFO_TXFE_1                     (uint32_t)0x1          // Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
#define LPUART_FIFO_RXUFE                        ((uint32_t)1 << 8)     // Receive FIFO Underflow Interrupt Enable
#define   LPUART_FIFO_RXUFE_0                    (uint32_t)0x0          // RXUF flag does not generate an interrupt to the host.
#define   LPUART_FIFO_RXUFE_1                    (uint32_t)0x1          // RXUF flag generates an interrupt to the host.
#define LPUART_FIFO_TXOFE                        ((uint32_t)1 << 9)     // Transmit FIFO Overflow Interrupt Enable
#define   LPUART_FIFO_TXOFE_0                    (uint32_t)0x0          // TXOF flag does not generate an interrupt to the host.
#define   LPUART_FIFO_TXOFE_1                    (uint32_t)0x1          // TXOF flag generates an interrupt to the host.
                                                                        // Receiver Idle Empty Enable
#define LPUART_FIFO_RXIDEN(_n)                   (((uint32_t)(_n) & 0x7) << 10)
#define LPUART_FIFO_RXIDEN_INSERT(_v, _n)            (((_v) & ~0x1c00) | ((uint32_t)(_n) & 0x7) << 10)
#define LPUART_FIFO_RXIDEN_EXTRACT(_v)               (((_v) >> 10) & 0x7)
#define   LPUART_FIFO_RXIDEN_000                 (uint32_t)0x0          // Disable RDRF assertion due to partially filled FIFO when receiver is idle.
#define   LPUART_FIFO_RXIDEN_001                 (uint32_t)0x1          // Enable RDRF assertion due to partially filled FIFO when receiver is idle for 1 character.
#define   LPUART_FIFO_RXIDEN_010                 (uint32_t)0x2          // Enable RDRF assertion due to partially filled FIFO when receiver is idle for 2 characters.
#define   LPUART_FIFO_RXIDEN_011                 (uint32_t)0x3          // Enable RDRF assertion due to partially filled FIFO when receiver is idle for 4 characters.
#define   LPUART_FIFO_RXIDEN_100                 (uint32_t)0x4          // Enable RDRF assertion due to partially filled FIFO when receiver is idle for 8 characters.
#define   LPUART_FIFO_RXIDEN_101                 (uint32_t)0x5          // Enable RDRF assertion due to partially filled FIFO when receiver is idle for 16 characters.
#define   LPUART_FIFO_RXIDEN_110                 (uint32_t)0x6          // Enable RDRF assertion due to partially filled FIFO when receiver is idle for 32 characters.
#define   LPUART_FIFO_RXIDEN_111                 (uint32_t)0x7          // Enable RDRF assertion due to partially filled FIFO when receiver is idle for 64 characters.
#define LPUART_FIFO_RXFLUSH                      ((uint32_t)1 << 14)    // Receive FIFO/Buffer Flush
#define   LPUART_FIFO_RXFLUSH_0                  (uint32_t)0x0          // No flush operation occurs.
#define   LPUART_FIFO_RXFLUSH_1                  (uint32_t)0x1          // All data in the receive FIFO/buffer is cleared out.
#define LPUART_FIFO_TXFLUSH                      ((uint32_t)1 << 15)    // Transmit FIFO/Buffer Flush
#define   LPUART_FIFO_TXFLUSH_0                  (uint32_t)0x0          // No flush operation occurs.
#define   LPUART_FIFO_TXFLUSH_1                  (uint32_t)0x1          // All data in the transmit FIFO/Buffer is cleared out.
#define LPUART_FIFO_RXUF                         ((uint32_t)1 << 16)    // Receiver Buffer Underflow Flag
#define   LPUART_FIFO_RXUF_0                     (uint32_t)0x0          // No receive buffer underflow has occurred since the last time the flag was cleared.
#define   LPUART_FIFO_RXUF_1                     (uint32_t)0x1          // At least one receive buffer underflow has occurred since the last time the flag was cleared.
#define LPUART_FIFO_TXOF                         ((uint32_t)1 << 17)    // Transmitter Buffer Overflow Flag
#define   LPUART_FIFO_TXOF_0                     (uint32_t)0x0          // No transmit buffer overflow has occurred since the last time the flag was cleared.
#define   LPUART_FIFO_TXOF_1                     (uint32_t)0x1          // At least one transmit buffer overflow has occurred since the last time the flag was cleared.
#define LPUART_FIFO_RXEMPT                       ((uint32_t)1 << 22)    // Receive Buffer/FIFO Empty
#define   LPUART_FIFO_RXEMPT_0                   (uint32_t)0x0          // Receive buffer is not empty.
#define   LPUART_FIFO_RXEMPT_1                   (uint32_t)0x1          // Receive buffer is empty.
#define LPUART_FIFO_TXEMPT                       ((uint32_t)1 << 23)    // Transmit Buffer/FIFO Empty
#define   LPUART_FIFO_TXEMPT_0                   (uint32_t)0x0          // Transmit buffer is not empty.
#define   LPUART_FIFO_TXEMPT_1                   (uint32_t)0x1          // Transmit buffer is empty.

    uint32_t             WATER;                                         // LPUART Watermark Register
                                                                        // Transmit Watermark
#define LPUART_WATER_TXWATER(_n)                 (((uint32_t)(_n) & 0x3) << 0)
#define LPUART_WATER_TXWATER_INSERT(_v, _n)          (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define LPUART_WATER_TXWATER_EXTRACT(_v)             (((_v) >> 0) & 0x3)
                                                                        // Transmit Counter
#define LPUART_WATER_TXCOUNT(_n)                 (((uint32_t)(_n) & 0x7) << 8)
#define LPUART_WATER_TXCOUNT_INSERT(_v, _n)          (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define LPUART_WATER_TXCOUNT_EXTRACT(_v)             (((_v) >> 8) & 0x7)
                                                                        // Receive Watermark
#define LPUART_WATER_RXWATER(_n)                 (((uint32_t)(_n) & 0x3) << 16)
#define LPUART_WATER_RXWATER_INSERT(_v, _n)          (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define LPUART_WATER_RXWATER_EXTRACT(_v)             (((_v) >> 16) & 0x3)
                                                                        // Receive Counter
#define LPUART_WATER_RXCOUNT(_n)                 (((uint32_t)(_n) & 0x7) << 24)
#define LPUART_WATER_RXCOUNT_INSERT(_v, _n)          (((_v) & ~0x7000000) | ((uint32_t)(_n) & 0x7) << 24)
#define LPUART_WATER_RXCOUNT_EXTRACT(_v)             (((_v) >> 24) & 0x7)

} LPUART_regs_t;
                                                                        // --------------------
                                                                        // High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
typedef struct                                                          // --------------------
{
    uint32_t             C0;                                            // CMP Control Register 0
                                                                        // Comparator hard block hysteresis control. See chip data sheet to get the actual hysteresis value with each level
#define CMP0_C0_HYSTCTR(_n)                      (((uint32_t)(_n) & 0x3) << 0)
#define CMP0_C0_HYSTCTR_INSERT(_v, _n)               (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define CMP0_C0_HYSTCTR_EXTRACT(_v)                  (((_v) >> 0) & 0x3)
#define   CMP0_C0_HYSTCTR_00                     (uint32_t)0x0          // The hard block output has level 0 hysteresis internally.
#define   CMP0_C0_HYSTCTR_01                     (uint32_t)0x1          // The hard block output has level 1 hysteresis internally.
#define   CMP0_C0_HYSTCTR_10                     (uint32_t)0x2          // The hard block output has level 2 hysteresis internally.
#define   CMP0_C0_HYSTCTR_11                     (uint32_t)0x3          // The hard block output has level 3 hysteresis internally.
#define CMP0_C0_OFFSET                           ((uint32_t)1 << 2)     // Comparator hard block offset control. See chip data sheet to get the actual offset value with each level
#define   CMP0_C0_OFFSET_0                       (uint32_t)0x0          // The comparator hard block output has level 0 offset internally.
#define   CMP0_C0_OFFSET_1                       (uint32_t)0x1          // The comparator hard block output has level 1 offset internally.
                                                                        // Filter Sample Count
#define CMP0_C0_FILTER_CNT(_n)                   (((uint32_t)(_n) & 0x7) << 4)
#define CMP0_C0_FILTER_CNT_INSERT(_v, _n)            (((_v) & ~0x70) | ((uint32_t)(_n) & 0x7) << 4)
#define CMP0_C0_FILTER_CNT_EXTRACT(_v)               (((_v) >> 4) & 0x7)
#define   CMP0_C0_FILTER_CNT_000                 (uint32_t)0x0          // Filter is disabled. If SE = 1, then COUT is a logic zero (this is not a legal state, and is not recommended). If SE = 0, COUT = COUTA.
#define   CMP0_C0_FILTER_CNT_001                 (uint32_t)0x1          // 1 consecutive sample must agree (comparator output is simply sampled).
#define   CMP0_C0_FILTER_CNT_010                 (uint32_t)0x2          // 2 consecutive samples must agree.
#define   CMP0_C0_FILTER_CNT_011                 (uint32_t)0x3          // 3 consecutive samples must agree.
#define   CMP0_C0_FILTER_CNT_100                 (uint32_t)0x4          // 4 consecutive samples must agree.
#define   CMP0_C0_FILTER_CNT_101                 (uint32_t)0x5          // 5 consecutive samples must agree.
#define   CMP0_C0_FILTER_CNT_110                 (uint32_t)0x6          // 6 consecutive samples must agree.
#define   CMP0_C0_FILTER_CNT_111                 (uint32_t)0x7          // 7 consecutive samples must agree.
#define CMP0_C0_EN                               ((uint32_t)1 << 8)     // Comparator Module Enable
#define   CMP0_C0_EN_0                           (uint32_t)0x0          // Analog Comparator is disabled.
#define   CMP0_C0_EN_1                           (uint32_t)0x1          // Analog Comparator is enabled.
#define CMP0_C0_OPE                              ((uint32_t)1 << 9)     // Comparator Output Pin Enable
#define   CMP0_C0_OPE_0                          (uint32_t)0x0          // When OPE is 0, the comparator output (after window/filter settings dependent on software configuration) is not available to a packaged pin.
#define   CMP0_C0_OPE_1                          (uint32_t)0x1          // When OPE is 1, and if the software has configured the comparator to own a packaged pin, the comparator is available in a packaged pin.
#define CMP0_C0_COS                              ((uint32_t)1 << 10)    // Comparator Output Select
#define   CMP0_C0_COS_0                          (uint32_t)0x0          // Set CMPO to equal COUT (filtered comparator output).
#define   CMP0_C0_COS_1                          (uint32_t)0x1          // Set CMPO to equal COUTA (unfiltered comparator output).
#define CMP0_C0_INVT                             ((uint32_t)1 << 11)    // Comparator invert
#define   CMP0_C0_INVT_0                         (uint32_t)0x0          // Does not invert the comparator output.
#define   CMP0_C0_INVT_1                         (uint32_t)0x1          // Inverts the comparator output.
#define CMP0_C0_PMODE                            ((uint32_t)1 << 12)    // Power Mode Select
#define   CMP0_C0_PMODE_0                        (uint32_t)0x0          // Low Speed (LS) comparison mode is selected.
#define   CMP0_C0_PMODE_1                        (uint32_t)0x1          // High Speed (HS) comparison mode is selected, in VLPx mode, or Stop mode switched to Low Speed (LS) mode.
#define CMP0_C0_WE                               ((uint32_t)1 << 14)    // Windowing Enable
#define   CMP0_C0_WE_0                           (uint32_t)0x0          // Windowing mode is not selected.
#define   CMP0_C0_WE_1                           (uint32_t)0x1          // Windowing mode is selected.
#define CMP0_C0_SE                               ((uint32_t)1 << 15)    // Sample Enable
#define   CMP0_C0_SE_0                           (uint32_t)0x0          // Sampling mode is not selected.
#define   CMP0_C0_SE_1                           (uint32_t)0x1          // Sampling mode is selected.
                                                                        // Filter Sample Period
#define CMP0_C0_FPR(_n)                          (((uint32_t)(_n) & 0xff) << 16)
#define CMP0_C0_FPR_INSERT(_v, _n)                   (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define CMP0_C0_FPR_EXTRACT(_v)                      (((_v) >> 16) & 0xff)
#define CMP0_C0_COUT                             ((uint32_t)1 << 24)    // Analog Comparator Output
#define CMP0_C0_CFF                              ((uint32_t)1 << 25)    // Analog Comparator Flag Falling
#define   CMP0_C0_CFF_0                          (uint32_t)0x0          // A falling edge has not been detected on COUT.
#define   CMP0_C0_CFF_1                          (uint32_t)0x1          // A falling edge on COUT has occurred.
#define CMP0_C0_CFR                              ((uint32_t)1 << 26)    // Analog Comparator Flag Rising
#define   CMP0_C0_CFR_0                          (uint32_t)0x0          // A rising edge has not been detected on COUT.
#define   CMP0_C0_CFR_1                          (uint32_t)0x1          // A rising edge on COUT has occurred.
#define CMP0_C0_IEF                              ((uint32_t)1 << 27)    // Comparator Interrupt Enable Falling
#define   CMP0_C0_IEF_0                          (uint32_t)0x0          // Interrupt is disabled.
#define   CMP0_C0_IEF_1                          (uint32_t)0x1          // Interrupt is enabled.
#define CMP0_C0_IER                              ((uint32_t)1 << 28)    // Comparator Interrupt Enable Rising
#define   CMP0_C0_IER_0                          (uint32_t)0x0          // Interrupt is disabled.
#define   CMP0_C0_IER_1                          (uint32_t)0x1          // Interrupt is enabled.
#define CMP0_C0_DMAEN                            ((uint32_t)1 << 30)    // DMA Enable
#define   CMP0_C0_DMAEN_0                        (uint32_t)0x0          // DMA is disabled.
#define   CMP0_C0_DMAEN_1                        (uint32_t)0x1          // DMA is enabled.

    uint32_t             C1;                                            // CMP Control Register 1
                                                                        // DAC Output Voltage Select
#define CMP0_C1_VOSEL(_n)                        (((uint32_t)(_n) & 0xff) << 0)
#define CMP0_C1_VOSEL_INSERT(_v, _n)                 (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CMP0_C1_VOSEL_EXTRACT(_v)                    (((_v) >> 0) & 0xff)
                                                                        // Minus Input MUX Control
#define CMP0_C1_MSEL(_n)                         (((uint32_t)(_n) & 0x7) << 8)
#define CMP0_C1_MSEL_INSERT(_v, _n)                  (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define CMP0_C1_MSEL_EXTRACT(_v)                     (((_v) >> 8) & 0x7)
#define   CMP0_C1_MSEL_000                       (uint32_t)0x0          // IN0
#define   CMP0_C1_MSEL_001                       (uint32_t)0x1          // IN1
#define   CMP0_C1_MSEL_010                       (uint32_t)0x2          // IN2
#define   CMP0_C1_MSEL_011                       (uint32_t)0x3          // IN3
#define   CMP0_C1_MSEL_100                       (uint32_t)0x4          // IN4
#define   CMP0_C1_MSEL_101                       (uint32_t)0x5          // IN5
#define   CMP0_C1_MSEL_110                       (uint32_t)0x6          // IN6
#define   CMP0_C1_MSEL_111                       (uint32_t)0x7          // IN7
                                                                        // Plus Input MUX Control
#define CMP0_C1_PSEL(_n)                         (((uint32_t)(_n) & 0x7) << 11)
#define CMP0_C1_PSEL_INSERT(_v, _n)                  (((_v) & ~0x3800) | ((uint32_t)(_n) & 0x7) << 11)
#define CMP0_C1_PSEL_EXTRACT(_v)                     (((_v) >> 11) & 0x7)
#define   CMP0_C1_PSEL_000                       (uint32_t)0x0          // IN0
#define   CMP0_C1_PSEL_001                       (uint32_t)0x1          // IN1
#define   CMP0_C1_PSEL_010                       (uint32_t)0x2          // IN2
#define   CMP0_C1_PSEL_011                       (uint32_t)0x3          // IN3
#define   CMP0_C1_PSEL_100                       (uint32_t)0x4          // IN4
#define   CMP0_C1_PSEL_101                       (uint32_t)0x5          // IN5
#define   CMP0_C1_PSEL_110                       (uint32_t)0x6          // IN6
#define   CMP0_C1_PSEL_111                       (uint32_t)0x7          // IN7
#define CMP0_C1_VRSEL                            ((uint32_t)1 << 14)    // Supply Voltage Reference Source Select
#define   CMP0_C1_VRSEL_0                        (uint32_t)0x0          // Vin1 is selected as resistor ladder network supply reference Vin.
#define   CMP0_C1_VRSEL_1                        (uint32_t)0x1          // Vin2 is selected as resistor ladder network supply reference Vin.
#define CMP0_C1_DACEN                            ((uint32_t)1 << 15)    // DAC Enable
#define   CMP0_C1_DACEN_0                        (uint32_t)0x0          // DAC is disabled.
#define   CMP0_C1_DACEN_1                        (uint32_t)0x1          // DAC is enabled.
#define CMP0_C1_CHN0                             ((uint32_t)1 << 16)    // Channel 0 input enable
#define CMP0_C1_CHN1                             ((uint32_t)1 << 17)    // Channel 1 input enable
#define CMP0_C1_CHN2                             ((uint32_t)1 << 18)    // Channel 2 input enable
#define CMP0_C1_CHN3                             ((uint32_t)1 << 19)    // Channel 3 input enable
#define CMP0_C1_CHN4                             ((uint32_t)1 << 20)    // Channel 4 input enable
#define CMP0_C1_CHN5                             ((uint32_t)1 << 21)    // Channel 5 input enable
#define CMP0_C1_CHN6                             ((uint32_t)1 << 22)    // Channel 6 input enable
#define CMP0_C1_CHN7                             ((uint32_t)1 << 23)    // Channel 7 input enable
                                                                        // Selection of the input to the negative port of the comparator
#define CMP0_C1_INNSEL(_n)                       (((uint32_t)(_n) & 0x3) << 24)
#define CMP0_C1_INNSEL_INSERT(_v, _n)                (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define CMP0_C1_INNSEL_EXTRACT(_v)                   (((_v) >> 24) & 0x3)
#define   CMP0_C1_INNSEL_00                      (uint32_t)0x0          // IN0, from the 8-bit DAC output
#define   CMP0_C1_INNSEL_01                      (uint32_t)0x1          // IN1, from the analog 8-1 mux
                                                                        // Selection of the input to the positive port of the comparator
#define CMP0_C1_INPSEL(_n)                       (((uint32_t)(_n) & 0x3) << 27)
#define CMP0_C1_INPSEL_INSERT(_v, _n)                (((_v) & ~0x18000000) | ((uint32_t)(_n) & 0x3) << 27)
#define CMP0_C1_INPSEL_EXTRACT(_v)                   (((_v) >> 27) & 0x3)
#define   CMP0_C1_INPSEL_00                      (uint32_t)0x0          // IN0, from the 8-bit DAC output
#define   CMP0_C1_INPSEL_01                      (uint32_t)0x1          // IN1, from the analog 8-1 mux

    uint32_t             C2;                                            // CMP Control Register 2
                                                                        // The result of the input comparison for channel n
#define CMP0_C2_ACOn(_n)                         (((uint32_t)(_n) & 0xff) << 0)
#define CMP0_C2_ACOn_INSERT(_v, _n)                  (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define CMP0_C2_ACOn_EXTRACT(_v)                     (((_v) >> 0) & 0xff)
                                                                        // Comparator and DAC initialization delay modulus.
#define CMP0_C2_INITMOD(_n)                      (((uint32_t)(_n) & 0x3f) << 8)
#define CMP0_C2_INITMOD_INSERT(_v, _n)               (((_v) & ~0x3f00) | ((uint32_t)(_n) & 0x3f) << 8)
#define CMP0_C2_INITMOD_EXTRACT(_v)                  (((_v) >> 8) & 0x3f)
#define   CMP0_C2_INITMOD_000000                 (uint32_t)0x0          // The modulus is set to 64 (same with 111111).
                                                                        // Number of sample clocks
#define CMP0_C2_NSAM(_n)                         (((uint32_t)(_n) & 0x3) << 14)
#define CMP0_C2_NSAM_INSERT(_v, _n)                  (((_v) & ~0xc000) | ((uint32_t)(_n) & 0x3) << 14)
#define CMP0_C2_NSAM_EXTRACT(_v)                     (((_v) >> 14) & 0x3)
#define   CMP0_C2_NSAM_00                        (uint32_t)0x0          // The comparison result is sampled as soon as the active channel is scanned in one round-robin clock.
#define   CMP0_C2_NSAM_01                        (uint32_t)0x1          // The sampling takes place 1 round-robin clock cycle after the next cycle of the round-robin clock.
#define   CMP0_C2_NSAM_10                        (uint32_t)0x2          // The sampling takes place 2 round-robin clock cycles after the next cycle of the round-robin clock.
#define   CMP0_C2_NSAM_11                        (uint32_t)0x3          // The sampling takes place 3 round-robin clock cycles after the next cycle of the round-robin clock.
#define CMP0_C2_CH0F                             ((uint32_t)1 << 16)    // Channel 0 input changed flag
#define CMP0_C2_CH1F                             ((uint32_t)1 << 17)    // Channel 1 input changed flag
#define CMP0_C2_CH2F                             ((uint32_t)1 << 18)    // Channel 2 input changed flag
#define CMP0_C2_CH3F                             ((uint32_t)1 << 19)    // Channel 3 input changed flag
#define CMP0_C2_CH4F                             ((uint32_t)1 << 20)    // Channel 4 input changed flag
#define CMP0_C2_CH5F                             ((uint32_t)1 << 21)    // Channel 5 input changed flag
#define CMP0_C2_CH6F                             ((uint32_t)1 << 22)    // Channel 6 input changed flag
#define CMP0_C2_CH7F                             ((uint32_t)1 << 23)    // Channel 7 input changed flag
                                                                        // Fixed channel selection
#define CMP0_C2_FXMXCH(_n)                       (((uint32_t)(_n) & 0x7) << 25)
#define CMP0_C2_FXMXCH_INSERT(_v, _n)                (((_v) & ~0xe000000) | ((uint32_t)(_n) & 0x7) << 25)
#define CMP0_C2_FXMXCH_EXTRACT(_v)                   (((_v) >> 25) & 0x7)
#define   CMP0_C2_FXMXCH_000                     (uint32_t)0x0          // Channel 0 is selected as the fixed reference input for the fixed mux port.
#define   CMP0_C2_FXMXCH_001                     (uint32_t)0x1          // Channel 1 is selected as the fixed reference input for the fixed mux port.
#define   CMP0_C2_FXMXCH_010                     (uint32_t)0x2          // Channel 2 is selected as the fixed reference input for the fixed mux port.
#define   CMP0_C2_FXMXCH_011                     (uint32_t)0x3          // Channel 3 is selected as the fixed reference input for the fixed mux port.
#define   CMP0_C2_FXMXCH_100                     (uint32_t)0x4          // Channel 4 is selected as the fixed reference input for the fixed mux port.
#define   CMP0_C2_FXMXCH_101                     (uint32_t)0x5          // Channel 5 is selected as the fixed reference input for the fixed mux port.
#define   CMP0_C2_FXMXCH_110                     (uint32_t)0x6          // Channel 6 is selected as the fixed reference input for the fixed mux port.
#define   CMP0_C2_FXMXCH_111                     (uint32_t)0x7          // Channel 7 is selected as the fixed reference input for the fixed mux port.
#define CMP0_C2_FXMP                             ((uint32_t)1 << 29)    // Fixed MUX Port
#define   CMP0_C2_FXMP_0                         (uint32_t)0x0          // The Plus port is fixed. Only the inputs to the Minus port are swept in each round.
#define   CMP0_C2_FXMP_1                         (uint32_t)0x1          // The Minus port is fixed. Only the inputs to the Plus port are swept in each round.
#define CMP0_C2_RRIE                             ((uint32_t)1 << 30)    // Round-Robin interrupt enable
#define   CMP0_C2_RRIE_0                         (uint32_t)0x0          // The round-robin interrupt is disabled.
#define   CMP0_C2_RRIE_1                         (uint32_t)0x1          // The round-robin interrupt is enabled when a comparison result changes from the last sample.
#define CMP0_C2_RRE                              ((uint32_t)1 << 31)    // Round-Robin Enable
#define   CMP0_C2_RRE_0                          (uint32_t)0x0          // Round-robin operation is disabled.
#define   CMP0_C2_RRE_1                          (uint32_t)0x1          // Round-robin operation is enabled.

} CMP0_regs_t;
                                                                        // --------------------
                                                                        // PMC
typedef struct                                                          // --------------------
{
    uint8_t              LVDSC1;                                        // Low Voltage Detect Status and Control 1 Register
#define PMC_LVDSC1_LVDRE                         ((uint8_t)1 << 4)      // Low Voltage Detect Reset Enable
#define   PMC_LVDSC1_LVDRE_0                     (uint8_t)0x0           // No system resets on low voltage detect events.
#define PMC_LVDSC1_LVDIE                         ((uint8_t)1 << 5)      // Low Voltage Detect Interrupt Enable
#define   PMC_LVDSC1_LVDIE_0                     (uint8_t)0x0           // Hardware interrupt disabled (use polling)
#define   PMC_LVDSC1_LVDIE_1                     (uint8_t)0x1           // Request a hardware interrupt when LVDF = 1
#define PMC_LVDSC1_LVDACK                        ((uint8_t)1 << 6)      // Low Voltage Detect Acknowledge
#define PMC_LVDSC1_LVDF                          ((uint8_t)1 << 7)      // Low Voltage Detect Flag
#define   PMC_LVDSC1_LVDF_0                      (uint8_t)0x0           // Low-voltage event not detected
#define   PMC_LVDSC1_LVDF_1                      (uint8_t)0x1           // Low-voltage event detected

    uint8_t              LVDSC2;                                        // Low Voltage Detect Status and Control 2 Register
#define PMC_LVDSC2_LVWIE                         ((uint8_t)1 << 5)      // Low-Voltage Warning Interrupt Enable
#define   PMC_LVDSC2_LVWIE_0                     (uint8_t)0x0           // Hardware interrupt disabled (use polling)
#define   PMC_LVDSC2_LVWIE_1                     (uint8_t)0x1           // Request a hardware interrupt when LVWF=1
#define PMC_LVDSC2_LVWACK                        ((uint8_t)1 << 6)      // Low-Voltage Warning Acknowledge
#define PMC_LVDSC2_LVWF                          ((uint8_t)1 << 7)      // Low-Voltage Warning Flag
#define   PMC_LVDSC2_LVWF_0                      (uint8_t)0x0           // Low-voltage warning event not detected
#define   PMC_LVDSC2_LVWF_1                      (uint8_t)0x1           // Low-voltage warning event detected

    uint8_t              REGSC;                                         // Regulator Status and Control Register
#define PMC_REGSC_BIASEN                         ((uint8_t)1 << 0)      // Bias Enable Bit
#define   PMC_REGSC_BIASEN_0                     (uint8_t)0x0           // Biasing disabled, core logic can run in full performance
#define   PMC_REGSC_BIASEN_1                     (uint8_t)0x1           // Biasing enabled, core logic is slower and there are restrictions in allowed system clock speed (see Data Sheet for details)
#define PMC_REGSC_CLKBIASDIS                     ((uint8_t)1 << 1)      // Clock Bias Disable Bit
#define   PMC_REGSC_CLKBIASDIS_0                 (uint8_t)0x0           // No effect
#define   PMC_REGSC_CLKBIASDIS_1                 (uint8_t)0x1           // In VLPS mode, the bias currents and reference voltages for the following clock modules are disabled: SIRC, FIRC, PLL. (if available on device)
#define PMC_REGSC_REGFPM                         ((uint8_t)1 << 2)      // Regulator in Full Performance Mode Status Bit
#define   PMC_REGSC_REGFPM_0                     (uint8_t)0x0           // Regulator is in low power mode or transition to/from
#define   PMC_REGSC_REGFPM_1                     (uint8_t)0x1           // Regulator is in full performance mode
#define PMC_REGSC_LPOSTAT                        ((uint8_t)1 << 6)      // LPO Status Bit
#define   PMC_REGSC_LPOSTAT_0                    (uint8_t)0x0           // Low power oscillator in low phase
#define   PMC_REGSC_LPOSTAT_1                    (uint8_t)0x1           // Low power oscillator in high phase
#define PMC_REGSC_LPODIS                         ((uint8_t)1 << 7)      // LPO Disable Bit
#define   PMC_REGSC_LPODIS_0                     (uint8_t)0x0           // Low power oscillator enabled
#define   PMC_REGSC_LPODIS_1                     (uint8_t)0x1           // Low power oscillator disabled

    uint8_t _res0[1];
    uint8_t              LPOTRIM;                                       // Low Power Oscillator Trim Register
                                                                        // LPO trimming bits
#define PMC_LPOTRIM_LPOTRIM(_n)                  (((uint8_t)(_n) & 0x1f) << 0)
#define PMC_LPOTRIM_LPOTRIM_INSERT(_v, _n)           (((_v) & ~0x1f) | ((uint8_t)(_n) & 0x1f) << 0)
#define PMC_LPOTRIM_LPOTRIM_EXTRACT(_v)              (((_v) >> 0) & 0x1f)

} PMC_regs_t;
                                                                        // --------------------
                                                                        // System Mode Controller
typedef struct                                                          // --------------------
{
    const uint32_t       VERID;                                         // SMC Version ID Register
                                                                        // Feature Specification Number
#define SMC_VERID_FEATURE_EXTRACT(_v)                (((_v) >> 0) & 0xffff)
#define   SMC_VERID_FEATURE_0                    (uint32_t)0x0          // Standard features implemented
                                                                        // Minor Version Number
#define SMC_VERID_MINOR_EXTRACT(_v)                  (((_v) >> 16) & 0xff)
                                                                        // Major Version Number
#define SMC_VERID_MAJOR_EXTRACT(_v)                  (((_v) >> 24) & 0xff)

    const uint32_t       PARAM;                                         // SMC Parameter Register
#define SMC_PARAM_EHSRUN                         ((uint32_t)1 << 0)     // Existence of HSRUN feature
#define   SMC_PARAM_EHSRUN_0                     (uint32_t)0x0          // The feature is not available.
#define   SMC_PARAM_EHSRUN_1                     (uint32_t)0x1          // The feature is available.
#define SMC_PARAM_ELLS                           ((uint32_t)1 << 3)     // Existence of LLS feature
#define   SMC_PARAM_ELLS_0                       (uint32_t)0x0          // The feature is not available.
#define   SMC_PARAM_ELLS_1                       (uint32_t)0x1          // The feature is available.
#define SMC_PARAM_ELLS2                          ((uint32_t)1 << 5)     // Existence of LLS2 feature
#define   SMC_PARAM_ELLS2_0                      (uint32_t)0x0          // The feature is not available.
#define   SMC_PARAM_ELLS2_1                      (uint32_t)0x1          // The feature is available.
#define SMC_PARAM_EVLLS0                         ((uint32_t)1 << 6)     // Existence of VLLS0 feature
#define   SMC_PARAM_EVLLS0_0                     (uint32_t)0x0          // The feature is not available.
#define   SMC_PARAM_EVLLS0_1                     (uint32_t)0x1          // The feature is available.

    uint32_t             PMPROT;                                        // Power Mode Protection register
#define SMC_PMPROT_AVLP                          ((uint32_t)1 << 5)     // Allow Very-Low-Power Modes
#define   SMC_PMPROT_AVLP_0                      (uint32_t)0x0          // VLPR and VLPS are not allowed.
#define   SMC_PMPROT_AVLP_1                      (uint32_t)0x1          // VLPR and VLPS are allowed.
#define SMC_PMPROT_AHSRUN                        ((uint32_t)1 << 7)     // Allow High Speed Run mode
#define   SMC_PMPROT_AHSRUN_0                    (uint32_t)0x0          // HSRUN is not allowed
#define   SMC_PMPROT_AHSRUN_1                    (uint32_t)0x1          // HSRUN is allowed

    uint32_t             PMCTRL;                                        // Power Mode Control register
                                                                        // Stop Mode Control
#define SMC_PMCTRL_STOPM(_n)                     (((uint32_t)(_n) & 0x7) << 0)
#define SMC_PMCTRL_STOPM_INSERT(_v, _n)              (((_v) & ~0x7) | ((uint32_t)(_n) & 0x7) << 0)
#define SMC_PMCTRL_STOPM_EXTRACT(_v)                 (((_v) >> 0) & 0x7)
#define   SMC_PMCTRL_STOPM_000                   (uint32_t)0x0          // Normal Stop (STOP)
#define   SMC_PMCTRL_STOPM_010                   (uint32_t)0x2          // Very-Low-Power Stop (VLPS)
#define   SMC_PMCTRL_STOPM_110                   (uint32_t)0x6          // Reseved
#define SMC_PMCTRL_VLPSA                         ((uint32_t)1 << 3)     // Very Low Power Stop Aborted
#define   SMC_PMCTRL_VLPSA_0                     (uint32_t)0x0          // The previous stop mode entry was successful.
#define   SMC_PMCTRL_VLPSA_1                     (uint32_t)0x1          // The previous stop mode entry was aborted.
                                                                        // Run Mode Control
#define SMC_PMCTRL_RUNM(_n)                      (((uint32_t)(_n) & 0x3) << 5)
#define SMC_PMCTRL_RUNM_INSERT(_v, _n)               (((_v) & ~0x60) | ((uint32_t)(_n) & 0x3) << 5)
#define SMC_PMCTRL_RUNM_EXTRACT(_v)                  (((_v) >> 5) & 0x3)
#define   SMC_PMCTRL_RUNM_00                     (uint32_t)0x0          // Normal Run mode (RUN)
#define   SMC_PMCTRL_RUNM_10                     (uint32_t)0x2          // Very-Low-Power Run mode (VLPR)
#define   SMC_PMCTRL_RUNM_11                     (uint32_t)0x3          // High Speed Run mode (HSRUN)

    uint32_t             STOPCTRL;                                      // Stop Control Register
                                                                        // Stop Option
#define SMC_STOPCTRL_STOPO(_n)                   (((uint32_t)(_n) & 0x3) << 6)
#define SMC_STOPCTRL_STOPO_INSERT(_v, _n)            (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define SMC_STOPCTRL_STOPO_EXTRACT(_v)               (((_v) >> 6) & 0x3)
#define   SMC_STOPCTRL_STOPO_01                  (uint32_t)0x1          // STOP1 - Stop with both system and bus clocks disabled
#define   SMC_STOPCTRL_STOPO_10                  (uint32_t)0x2          // STOP2 - Stop with system clock disabled and bus clock enabled

    const uint32_t       PMSTAT;                                        // Power Mode Status register
                                                                        // Power Mode Status
#define SMC_PMSTAT_PMSTAT_EXTRACT(_v)                (((_v) >> 0) & 0xff)

} SMC_regs_t;
                                                                        // --------------------
                                                                        // Reset Control Module
typedef struct                                                          // --------------------
{
    const uint32_t       VERID;                                         // Version ID Register
                                                                        // Feature Specification Number
#define RCM_VERID_FEATURE_EXTRACT(_v)                (((_v) >> 0) & 0xffff)
#define   RCM_VERID_FEATURE_11                   (uint32_t)0x3          // Standard feature set.
                                                                        // Minor Version Number
#define RCM_VERID_MINOR_EXTRACT(_v)                  (((_v) >> 16) & 0xff)
                                                                        // Major Version Number
#define RCM_VERID_MAJOR_EXTRACT(_v)                  (((_v) >> 24) & 0xff)

    const uint32_t       PARAM;                                         // Parameter Register
#define RCM_PARAM_EWAKEUP                        ((uint32_t)1 << 0)     // Existence of SRS[WAKEUP] status indication feature
#define   RCM_PARAM_EWAKEUP_0                    (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_EWAKEUP_1                    (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_ELVD                           ((uint32_t)1 << 1)     // Existence of SRS[LVD] status indication feature
#define   RCM_PARAM_ELVD_0                       (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_ELVD_1                       (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_ELOC                           ((uint32_t)1 << 2)     // Existence of SRS[LOC] status indication feature
#define   RCM_PARAM_ELOC_0                       (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_ELOC_1                       (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_ELOL                           ((uint32_t)1 << 3)     // Existence of SRS[LOL] status indication feature
#define   RCM_PARAM_ELOL_0                       (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_ELOL_1                       (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_EWDOG                          ((uint32_t)1 << 5)     // Existence of SRS[WDOG] status indication feature
#define   RCM_PARAM_EWDOG_0                      (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_EWDOG_1                      (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_EPIN                           ((uint32_t)1 << 6)     // Existence of SRS[PIN] status indication feature
#define   RCM_PARAM_EPIN_0                       (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_EPIN_1                       (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_EPOR                           ((uint32_t)1 << 7)     // Existence of SRS[POR] status indication feature
#define   RCM_PARAM_EPOR_0                       (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_EPOR_1                       (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_EJTAG                          ((uint32_t)1 << 8)     // Existence of SRS[JTAG] status indication feature
#define   RCM_PARAM_EJTAG_0                      (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_EJTAG_1                      (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_ELOCKUP                        ((uint32_t)1 << 9)     // Existence of SRS[LOCKUP] status indication feature
#define   RCM_PARAM_ELOCKUP_0                    (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_ELOCKUP_1                    (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_ESW                            ((uint32_t)1 << 10)    // Existence of SRS[SW] status indication feature
#define   RCM_PARAM_ESW_0                        (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_ESW_1                        (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_EMDM_AP                        ((uint32_t)1 << 11)    // Existence of SRS[MDM_AP] status indication feature
#define   RCM_PARAM_EMDM_AP_0                    (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_EMDM_AP_1                    (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_ESACKERR                       ((uint32_t)1 << 13)    // Existence of SRS[SACKERR] status indication feature
#define   RCM_PARAM_ESACKERR_0                   (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_ESACKERR_1                   (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_ETAMPER                        ((uint32_t)1 << 15)    // Existence of SRS[TAMPER] status indication feature
#define   RCM_PARAM_ETAMPER_0                    (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_ETAMPER_1                    (uint32_t)0x1          // The feature is available.
#define RCM_PARAM_ECORE1                         ((uint32_t)1 << 16)    // Existence of SRS[CORE1] status indication feature
#define   RCM_PARAM_ECORE1_0                     (uint32_t)0x0          // The feature is not available.
#define   RCM_PARAM_ECORE1_1                     (uint32_t)0x1          // The feature is available.

    const uint32_t       SRS;                                           // System Reset Status Register
#define RCM_SRS_LVD                              ((uint32_t)1 << 1)     // Low-Voltage Detect Reset or High-Voltage Detect Reset
#define   RCM_SRS_LVD_0                          (uint32_t)0x0          // Reset not caused by LVD trip, HVD trip or POR
#define   RCM_SRS_LVD_1                          (uint32_t)0x1          // Reset caused by LVD trip, HVD trip or POR
#define RCM_SRS_LOC                              ((uint32_t)1 << 2)     // Loss-of-Clock Reset
#define   RCM_SRS_LOC_0                          (uint32_t)0x0          // Reset not caused by a loss of external clock.
#define   RCM_SRS_LOC_1                          (uint32_t)0x1          // Reset caused by a loss of external clock.
#define RCM_SRS_LOL                              ((uint32_t)1 << 3)     // Loss-of-Lock Reset
#define   RCM_SRS_LOL_0                          (uint32_t)0x0          // Reset not caused by a loss of lock in the PLL/FLL
#define   RCM_SRS_LOL_1                          (uint32_t)0x1          // Reset caused by a loss of lock in the PLL/FLL
#define RCM_SRS_WDOG                             ((uint32_t)1 << 5)     // Watchdog
#define   RCM_SRS_WDOG_0                         (uint32_t)0x0          // Reset not caused by watchdog timeout
#define   RCM_SRS_WDOG_1                         (uint32_t)0x1          // Reset caused by watchdog timeout
#define RCM_SRS_PIN                              ((uint32_t)1 << 6)     // External Reset Pin
#define   RCM_SRS_PIN_0                          (uint32_t)0x0          // Reset not caused by external reset pin
#define   RCM_SRS_PIN_1                          (uint32_t)0x1          // Reset caused by external reset pin
#define RCM_SRS_POR                              ((uint32_t)1 << 7)     // Power-On Reset
#define   RCM_SRS_POR_0                          (uint32_t)0x0          // Reset not caused by POR
#define   RCM_SRS_POR_1                          (uint32_t)0x1          // Reset caused by POR
#define RCM_SRS_JTAG                             ((uint32_t)1 << 8)     // JTAG generated reset
#define   RCM_SRS_JTAG_0                         (uint32_t)0x0          // Reset not caused by JTAG
#define   RCM_SRS_JTAG_1                         (uint32_t)0x1          // Reset caused by JTAG
#define RCM_SRS_LOCKUP                           ((uint32_t)1 << 9)     // Core Lockup
#define   RCM_SRS_LOCKUP_0                       (uint32_t)0x0          // Reset not caused by core LOCKUP event
#define   RCM_SRS_LOCKUP_1                       (uint32_t)0x1          // Reset caused by core LOCKUP event
#define RCM_SRS_SW                               ((uint32_t)1 << 10)    // Software
#define   RCM_SRS_SW_0                           (uint32_t)0x0          // Reset not caused by software setting of SYSRESETREQ bit
#define   RCM_SRS_SW_1                           (uint32_t)0x1          // Reset caused by software setting of SYSRESETREQ bit
#define RCM_SRS_MDM_AP                           ((uint32_t)1 << 11)    // MDM-AP System Reset Request
#define   RCM_SRS_MDM_AP_0                       (uint32_t)0x0          // Reset was not caused by host debugger system setting of the System Reset Request bit
#define   RCM_SRS_MDM_AP_1                       (uint32_t)0x1          // Reset was caused by host debugger system setting of the System Reset Request bit
#define RCM_SRS_SACKERR                          ((uint32_t)1 << 13)    // Stop Acknowledge Error
#define   RCM_SRS_SACKERR_0                      (uint32_t)0x0          // Reset not caused by peripheral failure to acknowledge attempt to enter stop mode
#define   RCM_SRS_SACKERR_1                      (uint32_t)0x1          // Reset caused by peripheral failure to acknowledge attempt to enter stop mode

    uint32_t             RPC;                                           // Reset Pin Control register
                                                                        // Reset Pin Filter Select in Run and Wait Modes
#define RCM_RPC_RSTFLTSRW(_n)                    (((uint32_t)(_n) & 0x3) << 0)
#define RCM_RPC_RSTFLTSRW_INSERT(_v, _n)             (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define RCM_RPC_RSTFLTSRW_EXTRACT(_v)                (((_v) >> 0) & 0x3)
#define   RCM_RPC_RSTFLTSRW_00                   (uint32_t)0x0          // All filtering disabled
#define   RCM_RPC_RSTFLTSRW_01                   (uint32_t)0x1          // Bus clock filter enabled for normal operation
#define   RCM_RPC_RSTFLTSRW_10                   (uint32_t)0x2          // LPO clock filter enabled for normal operation
#define RCM_RPC_RSTFLTSS                         ((uint32_t)1 << 2)     // Reset Pin Filter Select in Stop Mode
#define   RCM_RPC_RSTFLTSS_0                     (uint32_t)0x0          // All filtering disabled
#define   RCM_RPC_RSTFLTSS_1                     (uint32_t)0x1          // LPO clock filter enabled
                                                                        // Reset Pin Filter Bus Clock Select
#define RCM_RPC_RSTFLTSEL(_n)                    (((uint32_t)(_n) & 0x1f) << 8)
#define RCM_RPC_RSTFLTSEL_INSERT(_v, _n)             (((_v) & ~0x1f00) | ((uint32_t)(_n) & 0x1f) << 8)
#define RCM_RPC_RSTFLTSEL_EXTRACT(_v)                (((_v) >> 8) & 0x1f)

    uint8_t _res0[8];
    uint32_t             SSRS;                                          // Sticky System Reset Status Register
#define RCM_SSRS_SLVD                            ((uint32_t)1 << 1)     // Sticky Low-Voltage Detect Reset
#define   RCM_SSRS_SLVD_0                        (uint32_t)0x0          // Reset not caused by LVD trip or POR
#define   RCM_SSRS_SLVD_1                        (uint32_t)0x1          // Reset caused by LVD trip or POR
#define RCM_SSRS_SLOC                            ((uint32_t)1 << 2)     // Sticky Loss-of-Clock Reset
#define   RCM_SSRS_SLOC_0                        (uint32_t)0x0          // Reset not caused by a loss of external clock.
#define   RCM_SSRS_SLOC_1                        (uint32_t)0x1          // Reset caused by a loss of external clock.
#define RCM_SSRS_SLOL                            ((uint32_t)1 << 3)     // Sticky Loss-of-Lock Reset
#define   RCM_SSRS_SLOL_0                        (uint32_t)0x0          // Reset not caused by a loss of lock in the PLL/FLL
#define   RCM_SSRS_SLOL_1                        (uint32_t)0x1          // Reset caused by a loss of lock in the PLL/FLL
#define RCM_SSRS_SWDOG                           ((uint32_t)1 << 5)     // Sticky Watchdog
#define   RCM_SSRS_SWDOG_0                       (uint32_t)0x0          // Reset not caused by watchdog timeout
#define   RCM_SSRS_SWDOG_1                       (uint32_t)0x1          // Reset caused by watchdog timeout
#define RCM_SSRS_SPIN                            ((uint32_t)1 << 6)     // Sticky External Reset Pin
#define   RCM_SSRS_SPIN_0                        (uint32_t)0x0          // Reset not caused by external reset pin
#define   RCM_SSRS_SPIN_1                        (uint32_t)0x1          // Reset caused by external reset pin
#define RCM_SSRS_SPOR                            ((uint32_t)1 << 7)     // Sticky Power-On Reset
#define   RCM_SSRS_SPOR_0                        (uint32_t)0x0          // Reset not caused by POR
#define   RCM_SSRS_SPOR_1                        (uint32_t)0x1          // Reset caused by POR
#define RCM_SSRS_SJTAG                           ((uint32_t)1 << 8)     // Sticky JTAG generated reset
#define   RCM_SSRS_SJTAG_0                       (uint32_t)0x0          // Reset not caused by JTAG
#define   RCM_SSRS_SJTAG_1                       (uint32_t)0x1          // Reset caused by JTAG
#define RCM_SSRS_SLOCKUP                         ((uint32_t)1 << 9)     // Sticky Core Lockup
#define   RCM_SSRS_SLOCKUP_0                     (uint32_t)0x0          // Reset not caused by core LOCKUP event
#define   RCM_SSRS_SLOCKUP_1                     (uint32_t)0x1          // Reset caused by core LOCKUP event
#define RCM_SSRS_SSW                             ((uint32_t)1 << 10)    // Sticky Software
#define   RCM_SSRS_SSW_0                         (uint32_t)0x0          // Reset not caused by software setting of SYSRESETREQ bit
#define   RCM_SSRS_SSW_1                         (uint32_t)0x1          // Reset caused by software setting of SYSRESETREQ bit
#define RCM_SSRS_SMDM_AP                         ((uint32_t)1 << 11)    // Sticky MDM-AP System Reset Request
#define   RCM_SSRS_SMDM_AP_0                     (uint32_t)0x0          // Reset was not caused by host debugger system setting of the System Reset Request bit
#define   RCM_SSRS_SMDM_AP_1                     (uint32_t)0x1          // Reset was caused by host debugger system setting of the System Reset Request bit
#define RCM_SSRS_SSACKERR                        ((uint32_t)1 << 13)    // Sticky Stop Acknowledge Error
#define   RCM_SSRS_SSACKERR_0                    (uint32_t)0x0          // Reset not caused by peripheral failure to acknowledge attempt to enter stop mode
#define   RCM_SSRS_SSACKERR_1                    (uint32_t)0x1          // Reset caused by peripheral failure to acknowledge attempt to enter stop mode

    uint32_t             SRIE;                                          // System Reset Interrupt Enable Register
                                                                        // Reset Delay Time
#define RCM_SRIE_DELAY(_n)                       (((uint32_t)(_n) & 0x3) << 0)
#define RCM_SRIE_DELAY_INSERT(_v, _n)                (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define RCM_SRIE_DELAY_EXTRACT(_v)                   (((_v) >> 0) & 0x3)
#define   RCM_SRIE_DELAY_00                      (uint32_t)0x0          // 10 LPO cycles
#define   RCM_SRIE_DELAY_01                      (uint32_t)0x1          // 34 LPO cycles
#define   RCM_SRIE_DELAY_10                      (uint32_t)0x2          // 130 LPO cycles
#define   RCM_SRIE_DELAY_11                      (uint32_t)0x3          // 514 LPO cycles
#define RCM_SRIE_LOC                             ((uint32_t)1 << 2)     // Loss-of-Clock Interrupt
#define   RCM_SRIE_LOC_0                         (uint32_t)0x0          // Interrupt disabled.
#define   RCM_SRIE_LOC_1                         (uint32_t)0x1          // Interrupt enabled.
#define RCM_SRIE_LOL                             ((uint32_t)1 << 3)     // Loss-of-Lock Interrupt
#define   RCM_SRIE_LOL_0                         (uint32_t)0x0          // Interrupt disabled.
#define   RCM_SRIE_LOL_1                         (uint32_t)0x1          // Interrupt enabled.
#define RCM_SRIE_WDOG                            ((uint32_t)1 << 5)     // Watchdog Interrupt
#define   RCM_SRIE_WDOG_0                        (uint32_t)0x0          // Interrupt disabled.
#define   RCM_SRIE_WDOG_1                        (uint32_t)0x1          // Interrupt enabled.
#define RCM_SRIE_PIN                             ((uint32_t)1 << 6)     // External Reset Pin Interrupt
#define   RCM_SRIE_PIN_0                         (uint32_t)0x0          // Reset not caused by external reset pin
#define   RCM_SRIE_PIN_1                         (uint32_t)0x1          // Reset caused by external reset pin
#define RCM_SRIE_GIE                             ((uint32_t)1 << 7)     // Global Interrupt Enable
#define   RCM_SRIE_GIE_0                         (uint32_t)0x0          // All interrupt sources disabled.
#define   RCM_SRIE_GIE_1                         (uint32_t)0x1          // All interrupt sources enabled. Note that the individual interrupt-enable bits still need to be set to generate interrupts.
#define RCM_SRIE_JTAG                            ((uint32_t)1 << 8)     // JTAG generated reset
#define   RCM_SRIE_JTAG_0                        (uint32_t)0x0          // Interrupt disabled.
#define   RCM_SRIE_JTAG_1                        (uint32_t)0x1          // Interrupt enabled.
#define RCM_SRIE_LOCKUP                          ((uint32_t)1 << 9)     // Core Lockup Interrupt
#define   RCM_SRIE_LOCKUP_0                      (uint32_t)0x0          // Interrupt disabled.
#define   RCM_SRIE_LOCKUP_1                      (uint32_t)0x1          // Interrupt enabled.
#define RCM_SRIE_SW                              ((uint32_t)1 << 10)    // Software Interrupt
#define   RCM_SRIE_SW_0                          (uint32_t)0x0          // Interrupt disabled.
#define   RCM_SRIE_SW_1                          (uint32_t)0x1          // Interrupt enabled.
#define RCM_SRIE_MDM_AP                          ((uint32_t)1 << 11)    // MDM-AP System Reset Request
#define   RCM_SRIE_MDM_AP_0                      (uint32_t)0x0          // Interrupt disabled.
#define   RCM_SRIE_MDM_AP_1                      (uint32_t)0x1          // Interrupt enabled.
#define RCM_SRIE_SACKERR                         ((uint32_t)1 << 13)    // Stop Acknowledge Error Interrupt
#define   RCM_SRIE_SACKERR_0                     (uint32_t)0x0          // Interrupt disabled.
#define   RCM_SRIE_SACKERR_1                     (uint32_t)0x1          // Interrupt enabled.

} RCM_regs_t;
                                                                        // --------------------
                                                                        // General Purpose Input/Output
typedef struct                                                          // --------------------
{
    uint32_t             PDOR;                                          // Port Data Output Register
    uint32_t             PSOR;                                          // Port Set Output Register
    uint32_t             PCOR;                                          // Port Clear Output Register
    uint32_t             PTOR;                                          // Port Toggle Output Register
    const uint32_t       PDIR;                                          // Port Data Input Register
    uint32_t             PDDR;                                          // Port Data Direction Register
    uint32_t             PIDR;                                          // Port Input Disable Register
} PT_regs_t;
                                                                        // --------------------
                                                                        // System Control Registers
typedef struct                                                          // --------------------
{
    uint8_t _res0[8];
    uint32_t             ACTLR;                                         // Auxiliary Control Register,
#define S32_SCB_ACTLR_DISMCYCINT                 ((uint32_t)1 << 0)     // Disables interruption of multi-cycle instructions.
#define S32_SCB_ACTLR_DISDEFWBUF                 ((uint32_t)1 << 1)     // Disables write buffer use during default memory map accesses.
#define S32_SCB_ACTLR_DISFOLD                    ((uint32_t)1 << 2)     // Disables folding of IT instructions.
#define S32_SCB_ACTLR_DISFPCA                    ((uint32_t)1 << 8)     // SBZP / Disables automatic update of CONTROL.FPCA.
#define S32_SCB_ACTLR_DISOOFP                    ((uint32_t)1 << 9)     // Disables floating point instructions completing out of order with respect to integer instructions.

    uint8_t _res1[3316];
    const uint32_t       CPUID;                                         // CPUID Base Register
                                                                        // Indicates patch release: 0x0 = Patch 0
#define S32_SCB_CPUID_REVISION_EXTRACT(_v)           (((_v) >> 0) & 0xf)
                                                                        // Indicates part number
#define S32_SCB_CPUID_PARTNO_EXTRACT(_v)             (((_v) >> 4) & 0xfff)
                                                                        // Indicates processor revision: 0x2 = Revision 2
#define S32_SCB_CPUID_VARIANT_EXTRACT(_v)            (((_v) >> 20) & 0xf)
                                                                        // Implementer code
#define S32_SCB_CPUID_IMPLEMENTER_EXTRACT(_v)        (((_v) >> 24) & 0xff)

    uint32_t             ICSR;                                          // Interrupt Control and State Register
                                                                        // Active exception number
#define S32_SCB_ICSR_VECTACTIVE(_n)              (((uint32_t)(_n) & 0x1ff) << 0)
#define S32_SCB_ICSR_VECTACTIVE_INSERT(_v, _n)       (((_v) & ~0x1ff) | ((uint32_t)(_n) & 0x1ff) << 0)
#define S32_SCB_ICSR_VECTACTIVE_EXTRACT(_v)          (((_v) >> 0) & 0x1ff)
#define S32_SCB_ICSR_RETTOBASE                   ((uint32_t)1 << 11)    // Indicates whether there are preempted active exceptions
#define   S32_SCB_ICSR_RETTOBASE_0               (uint32_t)0x0          // there are preempted active exceptions to execute
#define   S32_SCB_ICSR_RETTOBASE_1               (uint32_t)0x1          // there are no active exceptions, or the currently-executing exception is the only active exception
                                                                        // Exception number of the highest priority pending enabled exception
#define S32_SCB_ICSR_VECTPENDING(_n)             (((uint32_t)(_n) & 0x3f) << 12)
#define S32_SCB_ICSR_VECTPENDING_INSERT(_v, _n)      (((_v) & ~0x3f000) | ((uint32_t)(_n) & 0x3f) << 12)
#define S32_SCB_ICSR_VECTPENDING_EXTRACT(_v)         (((_v) >> 12) & 0x3f)
#define S32_SCB_ICSR_ISRPENDING                  ((uint32_t)1 << 22)    // Interrupt pending flag, excluding NMI and Faults
#define   S32_SCB_ICSR_ISRPENDING_0              (uint32_t)0x0          // interrupt not pending
#define   S32_SCB_ICSR_ISRPENDING_1              (uint32_t)0x1          // interrupt pending
#define S32_SCB_ICSR_ISRPREEMPT                  ((uint32_t)1 << 23)    // You must only use this at debug time. It indicates that a pending interrupt becomes active in the next running cycle. If C_MASKINTS is clear in the Debug Halting Control and Status Register, the interrupt is serviced
#define   S32_SCB_ICSR_ISRPREEMPT_0              (uint32_t)0x0          // Will not service
#define   S32_SCB_ICSR_ISRPREEMPT_1              (uint32_t)0x1          // Will service a pending exception
#define S32_SCB_ICSR_PENDSTCLR                   ((uint32_t)1 << 25)    // SysTick exception clear-pending bit
#define   S32_SCB_ICSR_PENDSTCLR_0               (uint32_t)0x0          // no effect
#define   S32_SCB_ICSR_PENDSTCLR_1               (uint32_t)0x1          // removes the pending state from the SysTick exception
#define S32_SCB_ICSR_PENDSTSET                   ((uint32_t)1 << 26)    // SysTick exception set-pending bit
#define   S32_SCB_ICSR_PENDSTSET_0               (uint32_t)0x0          // write: no effect; read: SysTick exception is not pending
#define   S32_SCB_ICSR_PENDSTSET_1               (uint32_t)0x1          // write: changes SysTick exception state to pending; read: SysTick exception is pending
#define S32_SCB_ICSR_PENDSVCLR                   ((uint32_t)1 << 27)    // PendSV clear-pending bit
#define   S32_SCB_ICSR_PENDSVCLR_0               (uint32_t)0x0          // no effect
#define   S32_SCB_ICSR_PENDSVCLR_1               (uint32_t)0x1          // removes the pending state from the PendSV exception
#define S32_SCB_ICSR_PENDSVSET                   ((uint32_t)1 << 28)    // PendSV set-pending bit
#define   S32_SCB_ICSR_PENDSVSET_0               (uint32_t)0x0          // write: no effect; read: PendSV exception is not pending
#define   S32_SCB_ICSR_PENDSVSET_1               (uint32_t)0x1          // write: changes PendSV exception state to pending; read: PendSV exception is pending
#define S32_SCB_ICSR_NMIPENDSET                  ((uint32_t)1 << 31)    // NMI set-pending bit
#define   S32_SCB_ICSR_NMIPENDSET_0              (uint32_t)0x0          // write: no effect; read: NMI exception is not pending
#define   S32_SCB_ICSR_NMIPENDSET_1              (uint32_t)0x1          // write: changes NMI exception state to pending; read: NMI exception is pending

    uint32_t             VTOR;                                          // Vector Table Offset Register
                                                                        // Vector table base offset
#define S32_SCB_VTOR_TBLOFF(_n)                  (((uint32_t)(_n) & 0x1ffffff) << 7)
#define S32_SCB_VTOR_TBLOFF_INSERT(_v, _n)           (((_v) & ~0xffffff80) | ((uint32_t)(_n) & 0x1ffffff) << 7)
#define S32_SCB_VTOR_TBLOFF_EXTRACT(_v)              (((_v) >> 7) & 0x1ffffff)

    uint32_t             AIRCR;                                         // Application Interrupt and Reset Control Register
#define S32_SCB_AIRCR_VECTRESET                  ((uint32_t)1 << 0)     // Reserved for Debug use. This bit reads as 0. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.
#define S32_SCB_AIRCR_VECTCLRACTIVE              ((uint32_t)1 << 1)     // Reserved for Debug use. This bit reads as 0. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.
#define S32_SCB_AIRCR_SYSRESETREQ                ((uint32_t)1 << 2)     // System reset request bit is implementation defined
#define   S32_SCB_AIRCR_SYSRESETREQ_0            (uint32_t)0x0          // no system reset request
#define   S32_SCB_AIRCR_SYSRESETREQ_1            (uint32_t)0x1          // asserts a signal to the outer system that requests a reset
                                                                        // Interrupt priority grouping field. This field determines the split of group priority from subpriority.
#define S32_SCB_AIRCR_PRIGROUP(_n)               (((uint32_t)(_n) & 0x7) << 8)
#define S32_SCB_AIRCR_PRIGROUP_INSERT(_v, _n)        (((_v) & ~0x700) | ((uint32_t)(_n) & 0x7) << 8)
#define S32_SCB_AIRCR_PRIGROUP_EXTRACT(_v)           (((_v) >> 8) & 0x7)
#define S32_SCB_AIRCR_ENDIANNESS                 ((uint32_t)1 << 15)    // Data endianness bit is implementation defined
#define   S32_SCB_AIRCR_ENDIANNESS_0             (uint32_t)0x0          // Little-endian
#define   S32_SCB_AIRCR_ENDIANNESS_1             (uint32_t)0x1          // Big-endian
                                                                        // Register key
#define S32_SCB_AIRCR_VECTKEY(_n)                (((uint32_t)(_n) & 0xffff) << 16)
#define S32_SCB_AIRCR_VECTKEY_INSERT(_v, _n)         (((_v) & ~0xffff0000) | ((uint32_t)(_n) & 0xffff) << 16)
#define S32_SCB_AIRCR_VECTKEY_EXTRACT(_v)            (((_v) >> 16) & 0xffff)

    uint32_t             SCR;                                           // System Control Register
#define S32_SCB_SCR_SLEEPONEXIT                  ((uint32_t)1 << 1)     // Indicates sleep-on-exit when returning from Handler mode to Thread mode
#define   S32_SCB_SCR_SLEEPONEXIT_0              (uint32_t)0x0          // o not sleep when returning to Thread mode
#define   S32_SCB_SCR_SLEEPONEXIT_1              (uint32_t)0x1          // enter sleep, or deep sleep, on return from an ISR
#define S32_SCB_SCR_SLEEPDEEP                    ((uint32_t)1 << 2)     // Controls whether the processor uses sleep or deep sleep as its low power mode
#define   S32_SCB_SCR_SLEEPDEEP_0                (uint32_t)0x0          // sleep
#define   S32_SCB_SCR_SLEEPDEEP_1                (uint32_t)0x1          // deep sleep
#define S32_SCB_SCR_SEVONPEND                    ((uint32_t)1 << 4)     // Send Event on Pending bit
#define   S32_SCB_SCR_SEVONPEND_0                (uint32_t)0x0          // only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
#define   S32_SCB_SCR_SEVONPEND_1                (uint32_t)0x1          // enabled events and all interrupts, including disabled interrupts, can wakeup the processor

    uint32_t             CCR;                                           // Configuration and Control Register
#define S32_SCB_CCR_NONBASETHRDENA               ((uint32_t)1 << 0)     // Indicates how the processor enters Thread mode
#define   S32_SCB_CCR_NONBASETHRDENA_0           (uint32_t)0x0          // processor can enter Thread mode only when no exception is active
#define   S32_SCB_CCR_NONBASETHRDENA_1           (uint32_t)0x1          // processor can enter Thread mode from any level under the control of an EXC_RETURN value
#define S32_SCB_CCR_USERSETMPEND                 ((uint32_t)1 << 1)     // Enables unprivileged software access to the STIR
#define   S32_SCB_CCR_USERSETMPEND_0             (uint32_t)0x0          // disable
#define   S32_SCB_CCR_USERSETMPEND_1             (uint32_t)0x1          // enable
#define S32_SCB_CCR_UNALIGN_TRP                  ((uint32_t)1 << 3)     // Enables unaligned access traps
#define   S32_SCB_CCR_UNALIGN_TRP_0              (uint32_t)0x0          // do not trap unaligned halfword and word accesses
#define   S32_SCB_CCR_UNALIGN_TRP_1              (uint32_t)0x1          // trap unaligned halfword and word accesses
#define S32_SCB_CCR_DIV_0_TRP                    ((uint32_t)1 << 4)     // Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0
#define   S32_SCB_CCR_DIV_0_TRP_0                (uint32_t)0x0          // do not trap divide by 0
#define   S32_SCB_CCR_DIV_0_TRP_1                (uint32_t)0x1          // trap divide by 0
#define S32_SCB_CCR_BFHFNMIGN                    ((uint32_t)1 << 8)     // Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions.
#define   S32_SCB_CCR_BFHFNMIGN_0                (uint32_t)0x0          // data bus faults caused by load and store instructions cause a lock-up
#define   S32_SCB_CCR_BFHFNMIGN_1                (uint32_t)0x1          // handlers running at priority -1 and -2 ignore data bus faults caused by load and store instructions
#define S32_SCB_CCR_STKALIGN                     ((uint32_t)1 << 9)     // Indicates stack alignment on exception entry
#define   S32_SCB_CCR_STKALIGN_0                 (uint32_t)0x0          // 4-byte aligned
#define   S32_SCB_CCR_STKALIGN_1                 (uint32_t)0x1          // 8-byte aligned

    uint32_t             SHPR1;                                         // System Handler Priority Register 1
                                                                        // Priority of system handler 4, MemManage
#define S32_SCB_SHPR1_PRI_4(_n)                  (((uint32_t)(_n) & 0xff) << 0)
#define S32_SCB_SHPR1_PRI_4_INSERT(_v, _n)           (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define S32_SCB_SHPR1_PRI_4_EXTRACT(_v)              (((_v) >> 0) & 0xff)
                                                                        // Priority of system handler 5, BusFault
#define S32_SCB_SHPR1_PRI_5(_n)                  (((uint32_t)(_n) & 0xff) << 8)
#define S32_SCB_SHPR1_PRI_5_INSERT(_v, _n)           (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define S32_SCB_SHPR1_PRI_5_EXTRACT(_v)              (((_v) >> 8) & 0xff)
                                                                        // Priority of system handler 6, UsageFault
#define S32_SCB_SHPR1_PRI_6(_n)                  (((uint32_t)(_n) & 0xff) << 16)
#define S32_SCB_SHPR1_PRI_6_INSERT(_v, _n)           (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define S32_SCB_SHPR1_PRI_6_EXTRACT(_v)              (((_v) >> 16) & 0xff)

    uint32_t             SHPR2;                                         // System Handler Priority Register 2
                                                                        // Priority of system handler 11, SVCall
#define S32_SCB_SHPR2_PRI_11(_n)                 (((uint32_t)(_n) & 0xff) << 24)
#define S32_SCB_SHPR2_PRI_11_INSERT(_v, _n)          (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define S32_SCB_SHPR2_PRI_11_EXTRACT(_v)             (((_v) >> 24) & 0xff)

    uint32_t             SHPR3;                                         // System Handler Priority Register 3
                                                                        // Priority of system handler 12, DebugMonitor
#define S32_SCB_SHPR3_PRI_12(_n)                 (((uint32_t)(_n) & 0xff) << 0)
#define S32_SCB_SHPR3_PRI_12_INSERT(_v, _n)          (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define S32_SCB_SHPR3_PRI_12_EXTRACT(_v)             (((_v) >> 0) & 0xff)
                                                                        // Priority of system handler 14, PendSV
#define S32_SCB_SHPR3_PRI_14(_n)                 (((uint32_t)(_n) & 0xff) << 16)
#define S32_SCB_SHPR3_PRI_14_INSERT(_v, _n)          (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define S32_SCB_SHPR3_PRI_14_EXTRACT(_v)             (((_v) >> 16) & 0xff)
                                                                        // Priority of system handler 15, SysTick exception
#define S32_SCB_SHPR3_PRI_15(_n)                 (((uint32_t)(_n) & 0xff) << 24)
#define S32_SCB_SHPR3_PRI_15_INSERT(_v, _n)          (((_v) & ~0xff000000) | ((uint32_t)(_n) & 0xff) << 24)
#define S32_SCB_SHPR3_PRI_15_EXTRACT(_v)             (((_v) >> 24) & 0xff)

    uint32_t             SHCSR;                                         // System Handler Control and State Register
#define S32_SCB_SHCSR_MEMFAULTACT                ((uint32_t)1 << 0)     // MemManage exception active bit, reads as 1 if exception is active
#define   S32_SCB_SHCSR_MEMFAULTACT_0            (uint32_t)0x0          // exception is not active
#define   S32_SCB_SHCSR_MEMFAULTACT_1            (uint32_t)0x1          // exception is active
#define S32_SCB_SHCSR_BUSFAULTACT                ((uint32_t)1 << 1)     // BusFault exception active bit, reads as 1 if exception is active
#define   S32_SCB_SHCSR_BUSFAULTACT_0            (uint32_t)0x0          // exception is not active
#define   S32_SCB_SHCSR_BUSFAULTACT_1            (uint32_t)0x1          // exception is active
#define S32_SCB_SHCSR_USGFAULTACT                ((uint32_t)1 << 3)     // UsageFault exception active bit, reads as 1 if exception is active
#define   S32_SCB_SHCSR_USGFAULTACT_0            (uint32_t)0x0          // exception is not active
#define   S32_SCB_SHCSR_USGFAULTACT_1            (uint32_t)0x1          // exception is active
#define S32_SCB_SHCSR_SVCALLACT                  ((uint32_t)1 << 7)     // SVCall active bit, reads as 1 if SVC call is active
#define   S32_SCB_SHCSR_SVCALLACT_0              (uint32_t)0x0          // exception is not active
#define   S32_SCB_SHCSR_SVCALLACT_1              (uint32_t)0x1          // exception is active
#define S32_SCB_SHCSR_MONITORACT                 ((uint32_t)1 << 8)     // Debug monitor active bit, reads as 1 if Debug monitor is active
#define   S32_SCB_SHCSR_MONITORACT_0             (uint32_t)0x0          // exception is not active
#define   S32_SCB_SHCSR_MONITORACT_1             (uint32_t)0x1          // exception is active
#define S32_SCB_SHCSR_PENDSVACT                  ((uint32_t)1 << 10)    // PendSV exception active bit, reads as 1 if exception is active
#define   S32_SCB_SHCSR_PENDSVACT_0              (uint32_t)0x0          // exception is not active
#define   S32_SCB_SHCSR_PENDSVACT_1              (uint32_t)0x1          // exception is active
#define S32_SCB_SHCSR_SYSTICKACT                 ((uint32_t)1 << 11)    // SysTick exception active bit, reads as 1 if exception is active
#define   S32_SCB_SHCSR_SYSTICKACT_0             (uint32_t)0x0          // exception is not active
#define   S32_SCB_SHCSR_SYSTICKACT_1             (uint32_t)0x1          // exception is active
#define S32_SCB_SHCSR_USGFAULTPENDED             ((uint32_t)1 << 12)    // UsageFault exception pending bit, reads as 1 if exception is pending
#define   S32_SCB_SHCSR_USGFAULTPENDED_0         (uint32_t)0x0          // exception is not pending
#define   S32_SCB_SHCSR_USGFAULTPENDED_1         (uint32_t)0x1          // exception is pending
#define S32_SCB_SHCSR_MEMFAULTPENDED             ((uint32_t)1 << 13)    // MemManage exception pending bit, reads as 1 if exception is pending
#define   S32_SCB_SHCSR_MEMFAULTPENDED_0         (uint32_t)0x0          // exception is not pending
#define   S32_SCB_SHCSR_MEMFAULTPENDED_1         (uint32_t)0x1          // exception is pending
#define S32_SCB_SHCSR_BUSFAULTPENDED             ((uint32_t)1 << 14)    // BusFault exception pending bit, reads as 1 if exception is pending
#define   S32_SCB_SHCSR_BUSFAULTPENDED_0         (uint32_t)0x0          // exception is not pending
#define   S32_SCB_SHCSR_BUSFAULTPENDED_1         (uint32_t)0x1          // exception is pending
#define S32_SCB_SHCSR_SVCALLPENDED               ((uint32_t)1 << 15)    // SVCall pending bit, reads as 1 if exception is pending
#define   S32_SCB_SHCSR_SVCALLPENDED_0           (uint32_t)0x0          // exception is not pending
#define   S32_SCB_SHCSR_SVCALLPENDED_1           (uint32_t)0x1          // exception is pending
#define S32_SCB_SHCSR_MEMFAULTENA                ((uint32_t)1 << 16)    // MemManage enable bit, set to 1 to enable
#define   S32_SCB_SHCSR_MEMFAULTENA_0            (uint32_t)0x0          // disable the exception
#define   S32_SCB_SHCSR_MEMFAULTENA_1            (uint32_t)0x1          // enable the exception
#define S32_SCB_SHCSR_BUSFAULTENA                ((uint32_t)1 << 17)    // BusFault enable bit, set to 1 to enable
#define   S32_SCB_SHCSR_BUSFAULTENA_0            (uint32_t)0x0          // disable the exception
#define   S32_SCB_SHCSR_BUSFAULTENA_1            (uint32_t)0x1          // enable the exception
#define S32_SCB_SHCSR_USGFAULTENA                ((uint32_t)1 << 18)    // UsageFault enable bit, set to 1 to enable
#define   S32_SCB_SHCSR_USGFAULTENA_0            (uint32_t)0x0          // disable the exception
#define   S32_SCB_SHCSR_USGFAULTENA_1            (uint32_t)0x1          // enable the exception

    uint32_t             CFSR;                                          // Configurable Fault Status Registers
#define S32_SCB_CFSR_IACCVIOL                    ((uint32_t)1 << 0)     // Instruction access violation flag
#define   S32_SCB_CFSR_IACCVIOL_0                (uint32_t)0x0          // no instruction access violation fault
#define   S32_SCB_CFSR_IACCVIOL_1                (uint32_t)0x1          // the processor attempted an instruction fetch from a location that does not permit execution
#define S32_SCB_CFSR_DACCVIOL                    ((uint32_t)1 << 1)     // Data access violation flag
#define   S32_SCB_CFSR_DACCVIOL_0                (uint32_t)0x0          // no data access violation fault
#define   S32_SCB_CFSR_DACCVIOL_1                (uint32_t)0x1          // the processor attempted a load or store at a location that does not permit the operation
#define S32_SCB_CFSR_MUNSTKERR                   ((uint32_t)1 << 3)     // MemManage fault on unstacking for a return from exception
#define   S32_SCB_CFSR_MUNSTKERR_0               (uint32_t)0x0          // no unstacking fault
#define   S32_SCB_CFSR_MUNSTKERR_1               (uint32_t)0x1          // unstack for an exception return has caused one or more access violations
#define S32_SCB_CFSR_MSTKERR                     ((uint32_t)1 << 4)     // MemManage fault on stacking for exception entry
#define   S32_SCB_CFSR_MSTKERR_0                 (uint32_t)0x0          // no stacking fault
#define   S32_SCB_CFSR_MSTKERR_1                 (uint32_t)0x1          // stacking for an exception entry has caused one or more access violations
#define S32_SCB_CFSR_MLSPERR                     ((uint32_t)1 << 5)     // Indicates whether MemManage fault occured during floating-point lazy state preservation
#define   S32_SCB_CFSR_MLSPERR_0                 (uint32_t)0x0          // No MemManage fault occurred during floating-point lazy state preservation
#define   S32_SCB_CFSR_MLSPERR_1                 (uint32_t)0x1          // A MemManage fault occurred during floating-point lazy state preservation
#define S32_SCB_CFSR_MMARVALID                   ((uint32_t)1 << 7)     // MemManage Fault Address Register (MMFAR) valid flag
#define   S32_SCB_CFSR_MMARVALID_0               (uint32_t)0x0          // value in MMAR is not a valid fault address
#define   S32_SCB_CFSR_MMARVALID_1               (uint32_t)0x1          // MMAR holds a valid fault address
#define S32_SCB_CFSR_IBUSERR                     ((uint32_t)1 << 8)     // Instruction bus error
#define   S32_SCB_CFSR_IBUSERR_0                 (uint32_t)0x0          // no instruction bus error
#define   S32_SCB_CFSR_IBUSERR_1                 (uint32_t)0x1          // instruction bus error
#define S32_SCB_CFSR_PRECISERR                   ((uint32_t)1 << 9)     // Precise data bus error
#define   S32_SCB_CFSR_PRECISERR_0               (uint32_t)0x0          // no precise data bus error
#define   S32_SCB_CFSR_PRECISERR_1               (uint32_t)0x1          // a data bus error has occurred, and the PC value stacked for the exception return points to the instruction that caused the fault
#define S32_SCB_CFSR_IMPRECISERR                 ((uint32_t)1 << 10)    // Imprecise data bus error
#define   S32_SCB_CFSR_IMPRECISERR_0             (uint32_t)0x0          // no imprecise data bus error
#define   S32_SCB_CFSR_IMPRECISERR_1             (uint32_t)0x1          // a data bus error has occurred, but the return address in the stack frame is not related to the instruction that caused the error
#define S32_SCB_CFSR_UNSTKERR                    ((uint32_t)1 << 11)    // BusFault on unstacking for a return from exception
#define   S32_SCB_CFSR_UNSTKERR_0                (uint32_t)0x0          // no unstacking fault
#define   S32_SCB_CFSR_UNSTKERR_1                (uint32_t)0x1          // unstack for an exception return has caused one or more BusFaults
#define S32_SCB_CFSR_STKERR                      ((uint32_t)1 << 12)    // BusFault on stacking for exception entry
#define   S32_SCB_CFSR_STKERR_0                  (uint32_t)0x0          // no stacking fault
#define   S32_SCB_CFSR_STKERR_1                  (uint32_t)0x1          // stacking for an exception entry has caused one or more BusFaults
#define S32_SCB_CFSR_LSPERR                      ((uint32_t)1 << 13)    // Indicates whether bus fault fault occured during floating-point lazy state preservation
#define   S32_SCB_CFSR_LSPERR_0                  (uint32_t)0x0          // No bus fault occurred during floating-point lazy state preservation
#define   S32_SCB_CFSR_LSPERR_1                  (uint32_t)0x1          // A bus fault occurred during floating-point lazy state preservation
#define S32_SCB_CFSR_BFARVALID                   ((uint32_t)1 << 15)    // BusFault Address Register (BFAR) valid flag
#define   S32_SCB_CFSR_BFARVALID_0               (uint32_t)0x0          // value in BFAR is not a valid fault address
#define   S32_SCB_CFSR_BFARVALID_1               (uint32_t)0x1          // BFAR holds a valid fault address
#define S32_SCB_CFSR_UNDEFINSTR                  ((uint32_t)1 << 16)    // Undefined instruction UsageFault
#define   S32_SCB_CFSR_UNDEFINSTR_0              (uint32_t)0x0          // no undefined instruction UsageFault
#define   S32_SCB_CFSR_UNDEFINSTR_1              (uint32_t)0x1          // the processor has attempted to execute an undefined instruction
#define S32_SCB_CFSR_INVSTATE                    ((uint32_t)1 << 17)    // Invalid state UsageFault
#define   S32_SCB_CFSR_INVSTATE_0                (uint32_t)0x0          // no invalid state UsageFault
#define   S32_SCB_CFSR_INVSTATE_1                (uint32_t)0x1          // the processor has attempted to execute an instruction that makes illegal use of the EPSR
#define S32_SCB_CFSR_INVPC                       ((uint32_t)1 << 18)    // Invalid PC load UsageFault, caused by an invalid PC load by EXC_RETURN
#define   S32_SCB_CFSR_INVPC_0                   (uint32_t)0x0          // no invalid PC load UsageFault
#define   S32_SCB_CFSR_INVPC_1                   (uint32_t)0x1          // the processor has attempted an illegal load of EXC_RETURN to the PC
#define S32_SCB_CFSR_NOCP                        ((uint32_t)1 << 19)    // No coprocessor UsageFault. The processor does not support coprocessor instructions
#define   S32_SCB_CFSR_NOCP_0                    (uint32_t)0x0          // no UsageFault caused by attempting to access a coprocessor
#define   S32_SCB_CFSR_NOCP_1                    (uint32_t)0x1          // the processor has attempted to access a coprocessor
#define S32_SCB_CFSR_UNALIGNED                   ((uint32_t)1 << 24)    // Unaligned access UsageFault
#define   S32_SCB_CFSR_UNALIGNED_0               (uint32_t)0x0          // no unaligned access fault, or unaligned access trapping not enabled
#define   S32_SCB_CFSR_UNALIGNED_1               (uint32_t)0x1          // the processor has made an unaligned memory access
#define S32_SCB_CFSR_DIVBYZERO                   ((uint32_t)1 << 25)    // Divide by zero UsageFault
#define   S32_SCB_CFSR_DIVBYZERO_0               (uint32_t)0x0          // no divide by zero fault, or divide by zero trapping not enabled
#define   S32_SCB_CFSR_DIVBYZERO_1               (uint32_t)0x1          // the processor has executed an SDIV or UDIV instruction with a divisor of 0

    uint32_t             HFSR;                                          // HardFault Status register
#define S32_SCB_HFSR_VECTTBL                     ((uint32_t)1 << 1)     // Indicates a BusFault on a vector table read during exception processing
#define   S32_SCB_HFSR_VECTTBL_0                 (uint32_t)0x0          // no BusFault on vector table read
#define   S32_SCB_HFSR_VECTTBL_1                 (uint32_t)0x1          // BusFault on vector table read
#define S32_SCB_HFSR_FORCED                      ((uint32_t)1 << 30)    // Indicates a forced hard fault, generated by escalation of a fault with configurable priority that cannot be handles, either because of priority or because it is disabled
#define   S32_SCB_HFSR_FORCED_0                  (uint32_t)0x0          // no forced HardFault
#define   S32_SCB_HFSR_FORCED_1                  (uint32_t)0x1          // forced HardFault
#define S32_SCB_HFSR_DEBUGEVT                    ((uint32_t)1 << 31)    // Reserved for Debug use. When writing to the register you must write 0 to this bit, otherwise behavior is Unpredictable.

    uint32_t             DFSR;                                          // Debug Fault Status Register
#define S32_SCB_DFSR_HALTED                      ((uint32_t)1 << 0)     // no description available
#define   S32_SCB_DFSR_HALTED_0                  (uint32_t)0x0          // No active halt request debug event
#define   S32_SCB_DFSR_HALTED_1                  (uint32_t)0x1          // Halt request debug event active
#define S32_SCB_DFSR_BKPT                        ((uint32_t)1 << 1)     // no description available
#define   S32_SCB_DFSR_BKPT_0                    (uint32_t)0x0          // No current breakpoint debug event
#define   S32_SCB_DFSR_BKPT_1                    (uint32_t)0x1          // At least one current breakpoint debug event
#define S32_SCB_DFSR_DWTTRAP                     ((uint32_t)1 << 2)     // no description available
#define   S32_SCB_DFSR_DWTTRAP_0                 (uint32_t)0x0          // No current debug events generated by the DWT
#define   S32_SCB_DFSR_DWTTRAP_1                 (uint32_t)0x1          // At least one current debug event generated by the DWT
#define S32_SCB_DFSR_VCATCH                      ((uint32_t)1 << 3)     // no description available
#define   S32_SCB_DFSR_VCATCH_0                  (uint32_t)0x0          // No Vector catch triggered
#define   S32_SCB_DFSR_VCATCH_1                  (uint32_t)0x1          // Vector catch triggered
#define S32_SCB_DFSR_EXTERNAL                    ((uint32_t)1 << 4)     // no description available
#define   S32_SCB_DFSR_EXTERNAL_0                (uint32_t)0x0          // No EDBGRQ debug event
#define   S32_SCB_DFSR_EXTERNAL_1                (uint32_t)0x1          // EDBGRQ debug event

    uint32_t             MMFAR;                                         // MemManage Address Register
    uint32_t             BFAR;                                          // BusFault Address Register
    uint32_t             AFSR;                                          // Auxiliary Fault Status Register
    uint8_t _res2[72];
    uint32_t             CPACR;                                         // Coprocessor Access Control Register
                                                                        // Access privileges for coprocessor 10.
#define S32_SCB_CPACR_CP10(_n)                   (((uint32_t)(_n) & 0x3) << 20)
#define S32_SCB_CPACR_CP10_INSERT(_v, _n)            (((_v) & ~0x300000) | ((uint32_t)(_n) & 0x3) << 20)
#define S32_SCB_CPACR_CP10_EXTRACT(_v)               (((_v) >> 20) & 0x3)
#define   S32_SCB_CPACR_CP10_00                  (uint32_t)0x0          // Access denied. Any attempted access generates a NOCP UsageFault
#define   S32_SCB_CPACR_CP10_01                  (uint32_t)0x1          // Privileged access only. An unprivileged access generates a NOCP fault.
#define   S32_SCB_CPACR_CP10_10                  (uint32_t)0x2          // Reserved. The result of any access is UNPREDICTABLE.
#define   S32_SCB_CPACR_CP10_11                  (uint32_t)0x3          // Full access.
                                                                        // Access privileges for coprocessor 11.
#define S32_SCB_CPACR_CP11(_n)                   (((uint32_t)(_n) & 0x3) << 22)
#define S32_SCB_CPACR_CP11_INSERT(_v, _n)            (((_v) & ~0xc00000) | ((uint32_t)(_n) & 0x3) << 22)
#define S32_SCB_CPACR_CP11_EXTRACT(_v)               (((_v) >> 22) & 0x3)
#define   S32_SCB_CPACR_CP11_00                  (uint32_t)0x0          // Access denied. Any attempted access generates a NOCP UsageFault
#define   S32_SCB_CPACR_CP11_01                  (uint32_t)0x1          // Privileged access only. An unprivileged access generates a NOCP fault.
#define   S32_SCB_CPACR_CP11_10                  (uint32_t)0x2          // Reserved. The result of any access is UNPREDICTABLE.
#define   S32_SCB_CPACR_CP11_11                  (uint32_t)0x3          // Full access.

    uint8_t _res3[424];
    uint32_t             FPCCR;                                         // Floating-point Context Control Register
#define S32_SCB_FPCCR_LSPACT                     ((uint32_t)1 << 0)     // Lazy state preservation.
#define   S32_SCB_FPCCR_LSPACT_0                 (uint32_t)0x0          // Lazy state preservation is not active.
#define   S32_SCB_FPCCR_LSPACT_1                 (uint32_t)0x1          // Lazy state preservation is active. floating-point stack frame has been allocated but saving state to it has been deferred.
#define S32_SCB_FPCCR_USER                       ((uint32_t)1 << 1)     // Privilege level when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_USER_0                   (uint32_t)0x0          // Privilege level was not user when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_USER_1                   (uint32_t)0x1          // Privilege level was user when the floating-point stack frame was allocated.
#define S32_SCB_FPCCR_THREAD                     ((uint32_t)1 << 3)     // Mode when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_THREAD_0                 (uint32_t)0x0          // Mode was not Thread Mode when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_THREAD_1                 (uint32_t)0x1          // Mode was Thread Mode when the floating-point stack frame was allocated.
#define S32_SCB_FPCCR_HFRDY                      ((uint32_t)1 << 4)     // Permission to set the HardFault handler to the pending state when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_HFRDY_0                  (uint32_t)0x0          // Priority did not permit setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_HFRDY_1                  (uint32_t)0x1          // Priority permitted setting the HardFault handler to the pending state when the floating-point stack frame was allocated.
#define S32_SCB_FPCCR_MMRDY                      ((uint32_t)1 << 5)     // Permission to set the MemManage handler to the pending state when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_MMRDY_0                  (uint32_t)0x0          // MemManage is disabled or priority did not permit setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_MMRDY_1                  (uint32_t)0x1          // MemManage is enabled and priority permitted setting the MemManage handler to the pending state when the floating-point stack frame was allocated.
#define S32_SCB_FPCCR_BFRDY                      ((uint32_t)1 << 6)     // Permission to set the BusFault handler to the pending state when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_BFRDY_0                  (uint32_t)0x0          // BusFault is disabled or priority did not permit setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_BFRDY_1                  (uint32_t)0x1          // BusFault is disabled or priority did not permit setting the BusFault handler to the pending state when the floating-point stack frame was allocated.
#define S32_SCB_FPCCR_MONRDY                     ((uint32_t)1 << 8)     // Permission to set the MON_PEND when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_MONRDY_0                 (uint32_t)0x0          // DebugMonitor is disabled or priority did not permit setting MON_PEND when the floating-point stack frame was allocated.
#define   S32_SCB_FPCCR_MONRDY_1                 (uint32_t)0x1          // DebugMonitor is enabled and priority permits setting MON_PEND when the floating-point stack frame was allocated.
#define S32_SCB_FPCCR_LSPEN                      ((uint32_t)1 << 30)    // Lazy state preservation for floating-point context.
#define   S32_SCB_FPCCR_LSPEN_0                  (uint32_t)0x0          // Disable automatic lazy state preservation for floating-point context.
#define   S32_SCB_FPCCR_LSPEN_1                  (uint32_t)0x1          // Enable automatic lazy state preservation for floating-point context.
#define S32_SCB_FPCCR_ASPEN                      ((uint32_t)1 << 31)    // Enables CONTROL2 setting on execution of a floating-point instruction. This results in automatic hardware state preservation and restoration, for floating-point context, on exception entry and exit.
#define   S32_SCB_FPCCR_ASPEN_0                  (uint32_t)0x0          // Disable CONTROL2 setting on execution of a floating-point instruction.
#define   S32_SCB_FPCCR_ASPEN_1                  (uint32_t)0x1          // Enable CONTROL2 setting on execution of a floating-point instruction.

    uint32_t             FPCAR;                                         // Floating-point Context Address Register
                                                                        // The location of the unpopulated floating-point register space allocated on an exception stack frame.
#define S32_SCB_FPCAR_ADDRESS(_n)                (((uint32_t)(_n) & 0x1fffffff) << 3)
#define S32_SCB_FPCAR_ADDRESS_INSERT(_v, _n)         (((_v) & ~0xfffffff8) | ((uint32_t)(_n) & 0x1fffffff) << 3)
#define S32_SCB_FPCAR_ADDRESS_EXTRACT(_v)            (((_v) >> 3) & 0x1fffffff)

    uint32_t             FPDSCR;                                        // Floating-point Default Status Control Register
                                                                        // Default value for FPSCR.RMode (Rounding Mode control field).
#define S32_SCB_FPDSCR_RMode(_n)                 (((uint32_t)(_n) & 0x3) << 22)
#define S32_SCB_FPDSCR_RMode_INSERT(_v, _n)          (((_v) & ~0xc00000) | ((uint32_t)(_n) & 0x3) << 22)
#define S32_SCB_FPDSCR_RMode_EXTRACT(_v)             (((_v) >> 22) & 0x3)
#define   S32_SCB_FPDSCR_RMode_00                (uint32_t)0x0          // Round to Nearest (RN) mode
#define   S32_SCB_FPDSCR_RMode_01                (uint32_t)0x1          // Round towards Plus Infinity (RP) mode.
#define   S32_SCB_FPDSCR_RMode_10                (uint32_t)0x2          // Round towards Minus Infinity (RM) mode.
#define   S32_SCB_FPDSCR_RMode_11                (uint32_t)0x3          // Round towards Zero (RZ) mode.
#define S32_SCB_FPDSCR_FZ                        ((uint32_t)1 << 24)    // Default value for FPSCR.FZ (Flush-to-zero mode control bit).
#define   S32_SCB_FPDSCR_FZ_0                    (uint32_t)0x0          // Flush-to-zero mode disabled. Behavior of the floating-point system is fully compliant with the IEEE 754 standard.
#define   S32_SCB_FPDSCR_FZ_1                    (uint32_t)0x1          // Flush-to-zero mode enabled.
#define S32_SCB_FPDSCR_DN                        ((uint32_t)1 << 25)    // Default value for FPSCR.DN (Default NaN mode control bit).
#define   S32_SCB_FPDSCR_DN_0                    (uint32_t)0x0          // NaN operands propagate through to the output of a floating-point operation.
#define   S32_SCB_FPDSCR_DN_1                    (uint32_t)0x1          // Any operation involving one or more NaNs returns the Default NaN.
#define S32_SCB_FPDSCR_AHP                       ((uint32_t)1 << 26)    // Default value for FPSCR.AHP (Alternative half-precision control bit).
#define   S32_SCB_FPDSCR_AHP_0                   (uint32_t)0x0          // IEEE half-precision format selected.
#define   S32_SCB_FPDSCR_AHP_1                   (uint32_t)0x1          // Alternative half-precision format selected.

} S32_SCB_regs_t;
                                                                        // --------------------
                                                                        // System timer
typedef struct                                                          // --------------------
{
    uint32_t             CSR;                                           // SysTick Control and Status Register
#define S32_SysTick_CSR_ENABLE                   ((uint32_t)1 << 0)     // Enables the counter
#define   S32_SysTick_CSR_ENABLE_0               (uint32_t)0x0          // counter disabled
#define   S32_SysTick_CSR_ENABLE_1               (uint32_t)0x1          // counter enabled
#define S32_SysTick_CSR_TICKINT                  ((uint32_t)1 << 1)     // Enables SysTick exception request
#define   S32_SysTick_CSR_TICKINT_0              (uint32_t)0x0          // counting down to 0 does not assert the SysTick exception request
#define   S32_SysTick_CSR_TICKINT_1              (uint32_t)0x1          // counting down to 0 asserts the SysTick exception request
#define S32_SysTick_CSR_CLKSOURCE                ((uint32_t)1 << 2)     // Indicates the clock source
#define   S32_SysTick_CSR_CLKSOURCE_0            (uint32_t)0x0          // external clock
#define   S32_SysTick_CSR_CLKSOURCE_1            (uint32_t)0x1          // processor clock
#define S32_SysTick_CSR_COUNTFLAG                ((uint32_t)1 << 16)    // Returns 1 if timer counted to 0 since last time this was read

    uint32_t             RVR;                                           // SysTick Reload Value Register
                                                                        // Value to load into the SysTick Current Value Register when the counter reaches 0
#define S32_SysTick_RVR_RELOAD(_n)               (((uint32_t)(_n) & 0xffffff) << 0)
#define S32_SysTick_RVR_RELOAD_INSERT(_v, _n)        (((_v) & ~0xffffff) | ((uint32_t)(_n) & 0xffffff) << 0)
#define S32_SysTick_RVR_RELOAD_EXTRACT(_v)           (((_v) >> 0) & 0xffffff)

    uint32_t             CVR;                                           // SysTick Current Value Register
                                                                        // Current value at the time the register is accessed
#define S32_SysTick_CVR_CURRENT(_n)              (((uint32_t)(_n) & 0xffffff) << 0)
#define S32_SysTick_CVR_CURRENT_INSERT(_v, _n)       (((_v) & ~0xffffff) | ((uint32_t)(_n) & 0xffffff) << 0)
#define S32_SysTick_CVR_CURRENT_EXTRACT(_v)          (((_v) >> 0) & 0xffffff)

    const uint32_t       CALIB;                                         // SysTick Calibration Value Register
                                                                        // Reload value to use for 10ms timing
#define S32_SysTick_CALIB_TENMS_EXTRACT(_v)          (((_v) >> 0) & 0xffffff)
#define S32_SysTick_CALIB_SKEW                   ((uint32_t)1 << 30)    // Indicates whether the TENMS value is exact
#define   S32_SysTick_CALIB_SKEW_0               (uint32_t)0x0          // TENMS value is exact
#define   S32_SysTick_CALIB_SKEW_1               (uint32_t)0x1          // TENMS value is inexact, or not given
#define S32_SysTick_CALIB_NOREF                  ((uint32_t)1 << 31)    // Indicates whether the device provides a reference clock to the processor
#define   S32_SysTick_CALIB_NOREF_0              (uint32_t)0x0          // The reference clock is provided
#define   S32_SysTick_CALIB_NOREF_1              (uint32_t)0x1          // The reference clock is not provided

} S32_SysTick_regs_t;
                                                                        // --------------------
                                                                        // Nested Vectored Interrupt Controller
typedef struct                                                          // --------------------
{
    uint32_t             NVICISER0;                                     // Interrupt Set Enable Register n
    uint32_t             NVICISER1;                                     // Interrupt Set Enable Register n
    uint32_t             NVICISER2;                                     // Interrupt Set Enable Register n
    uint32_t             NVICISER3;                                     // Interrupt Set Enable Register n
    uint32_t             NVICISER4;                                     // Interrupt Set Enable Register n
    uint32_t             NVICISER5;                                     // Interrupt Set Enable Register n
    uint32_t             NVICISER6;                                     // Interrupt Set Enable Register n
    uint32_t             NVICISER7;                                     // Interrupt Set Enable Register n
    uint8_t _res0[96];
    uint32_t             NVICICER0;                                     // Interrupt Clear Enable Register n
    uint32_t             NVICICER1;                                     // Interrupt Clear Enable Register n
    uint32_t             NVICICER2;                                     // Interrupt Clear Enable Register n
    uint32_t             NVICICER3;                                     // Interrupt Clear Enable Register n
    uint32_t             NVICICER4;                                     // Interrupt Clear Enable Register n
    uint32_t             NVICICER5;                                     // Interrupt Clear Enable Register n
    uint32_t             NVICICER6;                                     // Interrupt Clear Enable Register n
    uint32_t             NVICICER7;                                     // Interrupt Clear Enable Register n
    uint8_t _res1[96];
    uint32_t             NVICISPR0;                                     // Interrupt Set Pending Register n
    uint32_t             NVICISPR1;                                     // Interrupt Set Pending Register n
    uint32_t             NVICISPR2;                                     // Interrupt Set Pending Register n
    uint32_t             NVICISPR3;                                     // Interrupt Set Pending Register n
    uint32_t             NVICISPR4;                                     // Interrupt Set Pending Register n
    uint32_t             NVICISPR5;                                     // Interrupt Set Pending Register n
    uint32_t             NVICISPR6;                                     // Interrupt Set Pending Register n
    uint32_t             NVICISPR7;                                     // Interrupt Set Pending Register n
    uint8_t _res2[96];
    uint32_t             NVICICPR0;                                     // Interrupt Clear Pending Register n
    uint32_t             NVICICPR1;                                     // Interrupt Clear Pending Register n
    uint32_t             NVICICPR2;                                     // Interrupt Clear Pending Register n
    uint32_t             NVICICPR3;                                     // Interrupt Clear Pending Register n
    uint32_t             NVICICPR4;                                     // Interrupt Clear Pending Register n
    uint32_t             NVICICPR5;                                     // Interrupt Clear Pending Register n
    uint32_t             NVICICPR6;                                     // Interrupt Clear Pending Register n
    uint32_t             NVICICPR7;                                     // Interrupt Clear Pending Register n
    uint8_t _res3[96];
    uint32_t             NVICIABR0;                                     // Interrupt Active bit Register n
    uint32_t             NVICIABR1;                                     // Interrupt Active bit Register n
    uint32_t             NVICIABR2;                                     // Interrupt Active bit Register n
    uint32_t             NVICIABR3;                                     // Interrupt Active bit Register n
    uint32_t             NVICIABR4;                                     // Interrupt Active bit Register n
    uint32_t             NVICIABR5;                                     // Interrupt Active bit Register n
    uint32_t             NVICIABR6;                                     // Interrupt Active bit Register n
    uint32_t             NVICIABR7;                                     // Interrupt Active bit Register n
    uint8_t _res4[224];
    uint8_t              NVICIP0;                                       // Interrupt Priority Register n
    uint8_t              NVICIP1;                                       // Interrupt Priority Register n
    uint8_t              NVICIP2;                                       // Interrupt Priority Register n
    uint8_t              NVICIP3;                                       // Interrupt Priority Register n
    uint8_t              NVICIP4;                                       // Interrupt Priority Register n
    uint8_t              NVICIP5;                                       // Interrupt Priority Register n
    uint8_t              NVICIP6;                                       // Interrupt Priority Register n
    uint8_t              NVICIP7;                                       // Interrupt Priority Register n
    uint8_t              NVICIP8;                                       // Interrupt Priority Register n
    uint8_t              NVICIP9;                                       // Interrupt Priority Register n
    uint8_t              NVICIP10;                                      // Interrupt Priority Register n
    uint8_t              NVICIP11;                                      // Interrupt Priority Register n
    uint8_t              NVICIP12;                                      // Interrupt Priority Register n
    uint8_t              NVICIP13;                                      // Interrupt Priority Register n
    uint8_t              NVICIP14;                                      // Interrupt Priority Register n
    uint8_t              NVICIP15;                                      // Interrupt Priority Register n
    uint8_t              NVICIP16;                                      // Interrupt Priority Register n
    uint8_t              NVICIP17;                                      // Interrupt Priority Register n
    uint8_t              NVICIP18;                                      // Interrupt Priority Register n
    uint8_t              NVICIP19;                                      // Interrupt Priority Register n
    uint8_t              NVICIP20;                                      // Interrupt Priority Register n
    uint8_t              NVICIP21;                                      // Interrupt Priority Register n
    uint8_t              NVICIP22;                                      // Interrupt Priority Register n
    uint8_t              NVICIP23;                                      // Interrupt Priority Register n
    uint8_t              NVICIP24;                                      // Interrupt Priority Register n
    uint8_t              NVICIP25;                                      // Interrupt Priority Register n
    uint8_t              NVICIP26;                                      // Interrupt Priority Register n
    uint8_t              NVICIP27;                                      // Interrupt Priority Register n
    uint8_t              NVICIP28;                                      // Interrupt Priority Register n
    uint8_t              NVICIP29;                                      // Interrupt Priority Register n
    uint8_t              NVICIP30;                                      // Interrupt Priority Register n
    uint8_t              NVICIP31;                                      // Interrupt Priority Register n
    uint8_t              NVICIP32;                                      // Interrupt Priority Register n
    uint8_t              NVICIP33;                                      // Interrupt Priority Register n
    uint8_t              NVICIP34;                                      // Interrupt Priority Register n
    uint8_t              NVICIP35;                                      // Interrupt Priority Register n
    uint8_t              NVICIP36;                                      // Interrupt Priority Register n
    uint8_t              NVICIP37;                                      // Interrupt Priority Register n
    uint8_t              NVICIP38;                                      // Interrupt Priority Register n
    uint8_t              NVICIP39;                                      // Interrupt Priority Register n
    uint8_t              NVICIP40;                                      // Interrupt Priority Register n
    uint8_t              NVICIP41;                                      // Interrupt Priority Register n
    uint8_t              NVICIP42;                                      // Interrupt Priority Register n
    uint8_t              NVICIP43;                                      // Interrupt Priority Register n
    uint8_t              NVICIP44;                                      // Interrupt Priority Register n
    uint8_t              NVICIP45;                                      // Interrupt Priority Register n
    uint8_t              NVICIP46;                                      // Interrupt Priority Register n
    uint8_t              NVICIP47;                                      // Interrupt Priority Register n
    uint8_t              NVICIP48;                                      // Interrupt Priority Register n
    uint8_t              NVICIP49;                                      // Interrupt Priority Register n
    uint8_t              NVICIP50;                                      // Interrupt Priority Register n
    uint8_t              NVICIP51;                                      // Interrupt Priority Register n
    uint8_t              NVICIP52;                                      // Interrupt Priority Register n
    uint8_t              NVICIP53;                                      // Interrupt Priority Register n
    uint8_t              NVICIP54;                                      // Interrupt Priority Register n
    uint8_t              NVICIP55;                                      // Interrupt Priority Register n
    uint8_t              NVICIP56;                                      // Interrupt Priority Register n
    uint8_t              NVICIP57;                                      // Interrupt Priority Register n
    uint8_t              NVICIP58;                                      // Interrupt Priority Register n
    uint8_t              NVICIP59;                                      // Interrupt Priority Register n
    uint8_t              NVICIP60;                                      // Interrupt Priority Register n
    uint8_t              NVICIP61;                                      // Interrupt Priority Register n
    uint8_t              NVICIP62;                                      // Interrupt Priority Register n
    uint8_t              NVICIP63;                                      // Interrupt Priority Register n
    uint8_t              NVICIP64;                                      // Interrupt Priority Register n
    uint8_t              NVICIP65;                                      // Interrupt Priority Register n
    uint8_t              NVICIP66;                                      // Interrupt Priority Register n
    uint8_t              NVICIP67;                                      // Interrupt Priority Register n
    uint8_t              NVICIP68;                                      // Interrupt Priority Register n
    uint8_t              NVICIP69;                                      // Interrupt Priority Register n
    uint8_t              NVICIP70;                                      // Interrupt Priority Register n
    uint8_t              NVICIP71;                                      // Interrupt Priority Register n
    uint8_t              NVICIP72;                                      // Interrupt Priority Register n
    uint8_t              NVICIP73;                                      // Interrupt Priority Register n
    uint8_t              NVICIP74;                                      // Interrupt Priority Register n
    uint8_t              NVICIP75;                                      // Interrupt Priority Register n
    uint8_t              NVICIP76;                                      // Interrupt Priority Register n
    uint8_t              NVICIP77;                                      // Interrupt Priority Register n
    uint8_t              NVICIP78;                                      // Interrupt Priority Register n
    uint8_t              NVICIP79;                                      // Interrupt Priority Register n
    uint8_t              NVICIP80;                                      // Interrupt Priority Register n
    uint8_t              NVICIP81;                                      // Interrupt Priority Register n
    uint8_t              NVICIP82;                                      // Interrupt Priority Register n
    uint8_t              NVICIP83;                                      // Interrupt Priority Register n
    uint8_t              NVICIP84;                                      // Interrupt Priority Register n
    uint8_t              NVICIP85;                                      // Interrupt Priority Register n
    uint8_t              NVICIP86;                                      // Interrupt Priority Register n
    uint8_t              NVICIP87;                                      // Interrupt Priority Register n
    uint8_t              NVICIP88;                                      // Interrupt Priority Register n
    uint8_t              NVICIP89;                                      // Interrupt Priority Register n
    uint8_t              NVICIP90;                                      // Interrupt Priority Register n
    uint8_t              NVICIP91;                                      // Interrupt Priority Register n
    uint8_t              NVICIP92;                                      // Interrupt Priority Register n
    uint8_t              NVICIP93;                                      // Interrupt Priority Register n
    uint8_t              NVICIP94;                                      // Interrupt Priority Register n
    uint8_t              NVICIP95;                                      // Interrupt Priority Register n
    uint8_t              NVICIP96;                                      // Interrupt Priority Register n
    uint8_t              NVICIP97;                                      // Interrupt Priority Register n
    uint8_t              NVICIP98;                                      // Interrupt Priority Register n
    uint8_t              NVICIP99;                                      // Interrupt Priority Register n
    uint8_t              NVICIP100;                                     // Interrupt Priority Register n
    uint8_t              NVICIP101;                                     // Interrupt Priority Register n
    uint8_t              NVICIP102;                                     // Interrupt Priority Register n
    uint8_t              NVICIP103;                                     // Interrupt Priority Register n
    uint8_t              NVICIP104;                                     // Interrupt Priority Register n
    uint8_t              NVICIP105;                                     // Interrupt Priority Register n
    uint8_t              NVICIP106;                                     // Interrupt Priority Register n
    uint8_t              NVICIP107;                                     // Interrupt Priority Register n
    uint8_t              NVICIP108;                                     // Interrupt Priority Register n
    uint8_t              NVICIP109;                                     // Interrupt Priority Register n
    uint8_t              NVICIP110;                                     // Interrupt Priority Register n
    uint8_t              NVICIP111;                                     // Interrupt Priority Register n
    uint8_t              NVICIP112;                                     // Interrupt Priority Register n
    uint8_t              NVICIP113;                                     // Interrupt Priority Register n
    uint8_t              NVICIP114;                                     // Interrupt Priority Register n
    uint8_t              NVICIP115;                                     // Interrupt Priority Register n
    uint8_t              NVICIP116;                                     // Interrupt Priority Register n
    uint8_t              NVICIP117;                                     // Interrupt Priority Register n
    uint8_t              NVICIP118;                                     // Interrupt Priority Register n
    uint8_t              NVICIP119;                                     // Interrupt Priority Register n
    uint8_t              NVICIP120;                                     // Interrupt Priority Register n
    uint8_t              NVICIP121;                                     // Interrupt Priority Register n
    uint8_t              NVICIP122;                                     // Interrupt Priority Register n
    uint8_t              NVICIP123;                                     // Interrupt Priority Register n
    uint8_t              NVICIP124;                                     // Interrupt Priority Register n
    uint8_t              NVICIP125;                                     // Interrupt Priority Register n
    uint8_t              NVICIP126;                                     // Interrupt Priority Register n
    uint8_t              NVICIP127;                                     // Interrupt Priority Register n
    uint8_t              NVICIP128;                                     // Interrupt Priority Register n
    uint8_t              NVICIP129;                                     // Interrupt Priority Register n
    uint8_t              NVICIP130;                                     // Interrupt Priority Register n
    uint8_t              NVICIP131;                                     // Interrupt Priority Register n
    uint8_t              NVICIP132;                                     // Interrupt Priority Register n
    uint8_t              NVICIP133;                                     // Interrupt Priority Register n
    uint8_t              NVICIP134;                                     // Interrupt Priority Register n
    uint8_t              NVICIP135;                                     // Interrupt Priority Register n
    uint8_t              NVICIP136;                                     // Interrupt Priority Register n
    uint8_t              NVICIP137;                                     // Interrupt Priority Register n
    uint8_t              NVICIP138;                                     // Interrupt Priority Register n
    uint8_t              NVICIP139;                                     // Interrupt Priority Register n
    uint8_t              NVICIP140;                                     // Interrupt Priority Register n
    uint8_t              NVICIP141;                                     // Interrupt Priority Register n
    uint8_t              NVICIP142;                                     // Interrupt Priority Register n
    uint8_t              NVICIP143;                                     // Interrupt Priority Register n
    uint8_t              NVICIP144;                                     // Interrupt Priority Register n
    uint8_t              NVICIP145;                                     // Interrupt Priority Register n
    uint8_t              NVICIP146;                                     // Interrupt Priority Register n
    uint8_t              NVICIP147;                                     // Interrupt Priority Register n
    uint8_t              NVICIP148;                                     // Interrupt Priority Register n
    uint8_t              NVICIP149;                                     // Interrupt Priority Register n
    uint8_t              NVICIP150;                                     // Interrupt Priority Register n
    uint8_t              NVICIP151;                                     // Interrupt Priority Register n
    uint8_t              NVICIP152;                                     // Interrupt Priority Register n
    uint8_t              NVICIP153;                                     // Interrupt Priority Register n
    uint8_t              NVICIP154;                                     // Interrupt Priority Register n
    uint8_t              NVICIP155;                                     // Interrupt Priority Register n
    uint8_t              NVICIP156;                                     // Interrupt Priority Register n
    uint8_t              NVICIP157;                                     // Interrupt Priority Register n
    uint8_t              NVICIP158;                                     // Interrupt Priority Register n
    uint8_t              NVICIP159;                                     // Interrupt Priority Register n
    uint8_t              NVICIP160;                                     // Interrupt Priority Register n
    uint8_t              NVICIP161;                                     // Interrupt Priority Register n
    uint8_t              NVICIP162;                                     // Interrupt Priority Register n
    uint8_t              NVICIP163;                                     // Interrupt Priority Register n
    uint8_t              NVICIP164;                                     // Interrupt Priority Register n
    uint8_t              NVICIP165;                                     // Interrupt Priority Register n
    uint8_t              NVICIP166;                                     // Interrupt Priority Register n
    uint8_t              NVICIP167;                                     // Interrupt Priority Register n
    uint8_t              NVICIP168;                                     // Interrupt Priority Register n
    uint8_t              NVICIP169;                                     // Interrupt Priority Register n
    uint8_t              NVICIP170;                                     // Interrupt Priority Register n
    uint8_t              NVICIP171;                                     // Interrupt Priority Register n
    uint8_t              NVICIP172;                                     // Interrupt Priority Register n
    uint8_t              NVICIP173;                                     // Interrupt Priority Register n
    uint8_t              NVICIP174;                                     // Interrupt Priority Register n
    uint8_t              NVICIP175;                                     // Interrupt Priority Register n
    uint8_t              NVICIP176;                                     // Interrupt Priority Register n
    uint8_t              NVICIP177;                                     // Interrupt Priority Register n
    uint8_t              NVICIP178;                                     // Interrupt Priority Register n
    uint8_t              NVICIP179;                                     // Interrupt Priority Register n
    uint8_t              NVICIP180;                                     // Interrupt Priority Register n
    uint8_t              NVICIP181;                                     // Interrupt Priority Register n
    uint8_t              NVICIP182;                                     // Interrupt Priority Register n
    uint8_t              NVICIP183;                                     // Interrupt Priority Register n
    uint8_t              NVICIP184;                                     // Interrupt Priority Register n
    uint8_t              NVICIP185;                                     // Interrupt Priority Register n
    uint8_t              NVICIP186;                                     // Interrupt Priority Register n
    uint8_t              NVICIP187;                                     // Interrupt Priority Register n
    uint8_t              NVICIP188;                                     // Interrupt Priority Register n
    uint8_t              NVICIP189;                                     // Interrupt Priority Register n
    uint8_t              NVICIP190;                                     // Interrupt Priority Register n
    uint8_t              NVICIP191;                                     // Interrupt Priority Register n
    uint8_t              NVICIP192;                                     // Interrupt Priority Register n
    uint8_t              NVICIP193;                                     // Interrupt Priority Register n
    uint8_t              NVICIP194;                                     // Interrupt Priority Register n
    uint8_t              NVICIP195;                                     // Interrupt Priority Register n
    uint8_t              NVICIP196;                                     // Interrupt Priority Register n
    uint8_t              NVICIP197;                                     // Interrupt Priority Register n
    uint8_t              NVICIP198;                                     // Interrupt Priority Register n
    uint8_t              NVICIP199;                                     // Interrupt Priority Register n
    uint8_t              NVICIP200;                                     // Interrupt Priority Register n
    uint8_t              NVICIP201;                                     // Interrupt Priority Register n
    uint8_t              NVICIP202;                                     // Interrupt Priority Register n
    uint8_t              NVICIP203;                                     // Interrupt Priority Register n
    uint8_t              NVICIP204;                                     // Interrupt Priority Register n
    uint8_t              NVICIP205;                                     // Interrupt Priority Register n
    uint8_t              NVICIP206;                                     // Interrupt Priority Register n
    uint8_t              NVICIP207;                                     // Interrupt Priority Register n
    uint8_t              NVICIP208;                                     // Interrupt Priority Register n
    uint8_t              NVICIP209;                                     // Interrupt Priority Register n
    uint8_t              NVICIP210;                                     // Interrupt Priority Register n
    uint8_t              NVICIP211;                                     // Interrupt Priority Register n
    uint8_t              NVICIP212;                                     // Interrupt Priority Register n
    uint8_t              NVICIP213;                                     // Interrupt Priority Register n
    uint8_t              NVICIP214;                                     // Interrupt Priority Register n
    uint8_t              NVICIP215;                                     // Interrupt Priority Register n
    uint8_t              NVICIP216;                                     // Interrupt Priority Register n
    uint8_t              NVICIP217;                                     // Interrupt Priority Register n
    uint8_t              NVICIP218;                                     // Interrupt Priority Register n
    uint8_t              NVICIP219;                                     // Interrupt Priority Register n
    uint8_t              NVICIP220;                                     // Interrupt Priority Register n
    uint8_t              NVICIP221;                                     // Interrupt Priority Register n
    uint8_t              NVICIP222;                                     // Interrupt Priority Register n
    uint8_t              NVICIP223;                                     // Interrupt Priority Register n
    uint8_t              NVICIP224;                                     // Interrupt Priority Register n
    uint8_t              NVICIP225;                                     // Interrupt Priority Register n
    uint8_t              NVICIP226;                                     // Interrupt Priority Register n
    uint8_t              NVICIP227;                                     // Interrupt Priority Register n
    uint8_t              NVICIP228;                                     // Interrupt Priority Register n
    uint8_t              NVICIP229;                                     // Interrupt Priority Register n
    uint8_t              NVICIP230;                                     // Interrupt Priority Register n
    uint8_t              NVICIP231;                                     // Interrupt Priority Register n
    uint8_t              NVICIP232;                                     // Interrupt Priority Register n
    uint8_t              NVICIP233;                                     // Interrupt Priority Register n
    uint8_t              NVICIP234;                                     // Interrupt Priority Register n
    uint8_t              NVICIP235;                                     // Interrupt Priority Register n
    uint8_t              NVICIP236;                                     // Interrupt Priority Register n
    uint8_t              NVICIP237;                                     // Interrupt Priority Register n
    uint8_t              NVICIP238;                                     // Interrupt Priority Register n
    uint8_t              NVICIP239;                                     // Interrupt Priority Register n
    uint8_t _res5[2576];
    uint32_t             NVICSTIR;                                      // Software Trigger Interrupt Register
                                                                        // Interrupt ID of the interrupt to trigger, in the range 0-239. For example, a value of 0x03 specifies interrupt IRQ3.
#define S32_NVIC_NVICSTIR_INTID(_n)              (((uint32_t)(_n) & 0x1ff) << 0)
#define S32_NVIC_NVICSTIR_INTID_INSERT(_v, _n)       (((_v) & ~0x1ff) | ((uint32_t)(_n) & 0x1ff) << 0)

} S32_NVIC_regs_t;
                                                                        // --------------------
                                                                        // Core Platform Miscellaneous Control Module
typedef struct                                                          // --------------------
{
    uint8_t _res0[8];
    const uint16_t       PLASC;                                         // Crossbar Switch (AXBS) Slave Configuration
                                                                        // Each bit in the ASC field indicates whether there is a corresponding connection to the crossbar switch's slave input port.
#define MCM_PLASC_ASC_EXTRACT(_v)                    (((_v) >> 0) & 0xff)
#define   MCM_PLASC_ASC_0                        (uint16_t)0x0          // A bus slave connection to AXBS input port n is absent
#define   MCM_PLASC_ASC_1                        (uint16_t)0x1          // A bus slave connection to AXBS input port n is present

    const uint16_t       PLAMC;                                         // Crossbar Switch (AXBS) Master Configuration
                                                                        // Each bit in the AMC field indicates whether there is a corresponding connection to the AXBS master input port.
#define MCM_PLAMC_AMC_EXTRACT(_v)                    (((_v) >> 0) & 0xff)
#define   MCM_PLAMC_AMC_0                        (uint16_t)0x0          // A bus master connection to AXBS input port n is absent
#define   MCM_PLAMC_AMC_1                        (uint16_t)0x1          // A bus master connection to AXBS input port n is present

    uint32_t             CPCR;                                          // Core Platform Control Register
                                                                        // AXBS Halt State Machine Status
#define MCM_CPCR_HLT_FSM_ST(_n)                  (((uint32_t)(_n) & 0x3) << 0)
#define MCM_CPCR_HLT_FSM_ST_INSERT(_v, _n)           (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define MCM_CPCR_HLT_FSM_ST_EXTRACT(_v)              (((_v) >> 0) & 0x3)
#define   MCM_CPCR_HLT_FSM_ST_00                 (uint32_t)0x0          // Waiting for request
#define   MCM_CPCR_HLT_FSM_ST_01                 (uint32_t)0x1          // Waiting for platform idle
#define   MCM_CPCR_HLT_FSM_ST_11                 (uint32_t)0x3          // Platform stalled
#define   MCM_CPCR_HLT_FSM_ST_10                 (uint32_t)0x2          // Unused state
#define MCM_CPCR_AXBS_HLT_REQ                    ((uint32_t)1 << 2)     // AXBS Halt Request
#define   MCM_CPCR_AXBS_HLT_REQ_0                (uint32_t)0x0          // AXBS is not receiving halt request
#define   MCM_CPCR_AXBS_HLT_REQ_1                (uint32_t)0x1          // AXBS is receiving halt request
#define MCM_CPCR_AXBS_HLTD                       ((uint32_t)1 << 3)     // AXBS Halted
#define   MCM_CPCR_AXBS_HLTD_0                   (uint32_t)0x0          // AXBS is not currently halted
#define   MCM_CPCR_AXBS_HLTD_1                   (uint32_t)0x1          // AXBS is currently halted
#define MCM_CPCR_FMC_PF_IDLE                     ((uint32_t)1 << 4)     // Flash Memory Controller Program Flash Idle
#define   MCM_CPCR_FMC_PF_IDLE_0                 (uint32_t)0x0          // FMC program flash is not idle
#define   MCM_CPCR_FMC_PF_IDLE_1                 (uint32_t)0x1          // FMC program flash is currently idle
#define MCM_CPCR_PBRIDGE_IDLE                    ((uint32_t)1 << 6)     // Peripheral Bridge Idle
#define   MCM_CPCR_PBRIDGE_IDLE_0                (uint32_t)0x0          // PBRIDGE is not idle
#define   MCM_CPCR_PBRIDGE_IDLE_1                (uint32_t)0x1          // PBRIDGE is currently idle
#define MCM_CPCR_CBRR                            ((uint32_t)1 << 9)     // Crossbar Round-robin Arbitration Enable
#define   MCM_CPCR_CBRR_0                        (uint32_t)0x0          // Fixed-priority arbitration
#define   MCM_CPCR_CBRR_1                        (uint32_t)0x1          // Round-robin arbitration
                                                                        // SRAM_U Arbitration Priority
#define MCM_CPCR_SRAMUAP(_n)                     (((uint32_t)(_n) & 0x3) << 24)
#define MCM_CPCR_SRAMUAP_INSERT(_v, _n)              (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define MCM_CPCR_SRAMUAP_EXTRACT(_v)                 (((_v) >> 24) & 0x3)
#define   MCM_CPCR_SRAMUAP_00                    (uint32_t)0x0          // Round robin
#define   MCM_CPCR_SRAMUAP_01                    (uint32_t)0x1          // Special round robin (favors SRAM backdoor accesses over the processor)
#define   MCM_CPCR_SRAMUAP_10                    (uint32_t)0x2          // Fixed priority. Processor has highest, backdoor has lowest
#define   MCM_CPCR_SRAMUAP_11                    (uint32_t)0x3          // Fixed priority. Backdoor has highest, processor has lowest
#define MCM_CPCR_SRAMUWP                         ((uint32_t)1 << 26)    // SRAM_U Write Protect
                                                                        // SRAM_L Arbitration Priority
#define MCM_CPCR_SRAMLAP(_n)                     (((uint32_t)(_n) & 0x3) << 28)
#define MCM_CPCR_SRAMLAP_INSERT(_v, _n)              (((_v) & ~0x30000000) | ((uint32_t)(_n) & 0x3) << 28)
#define MCM_CPCR_SRAMLAP_EXTRACT(_v)                 (((_v) >> 28) & 0x3)
#define   MCM_CPCR_SRAMLAP_00                    (uint32_t)0x0          // Round robin
#define   MCM_CPCR_SRAMLAP_01                    (uint32_t)0x1          // Special round robin (favors SRAM backdoor accesses over the processor)
#define   MCM_CPCR_SRAMLAP_10                    (uint32_t)0x2          // Fixed priority. Processor has highest, backdoor has lowest
#define   MCM_CPCR_SRAMLAP_11                    (uint32_t)0x3          // Fixed priority. Backdoor has highest, processor has lowest
#define MCM_CPCR_SRAMLWP                         ((uint32_t)1 << 30)    // SRAM_L Write Protect

    uint32_t             ISCR;                                          // Interrupt Status and Control Register
#define MCM_ISCR_FIOC                            ((uint32_t)1 << 8)     // FPU Invalid Operation Interrupt Status
#define   MCM_ISCR_FIOC_0                        (uint32_t)0x0          // No interrupt
#define   MCM_ISCR_FIOC_1                        (uint32_t)0x1          // Interrupt occurred
#define MCM_ISCR_FDZC                            ((uint32_t)1 << 9)     // FPU Divide-by-Zero Interrupt Status
#define   MCM_ISCR_FDZC_0                        (uint32_t)0x0          // No interrupt
#define   MCM_ISCR_FDZC_1                        (uint32_t)0x1          // Interrupt occurred
#define MCM_ISCR_FOFC                            ((uint32_t)1 << 10)    // FPU Overflow Interrupt Status
#define   MCM_ISCR_FOFC_0                        (uint32_t)0x0          // No interrupt
#define   MCM_ISCR_FOFC_1                        (uint32_t)0x1          // Interrupt occurred
#define MCM_ISCR_FUFC                            ((uint32_t)1 << 11)    // FPU Underflow Interrupt Status
#define   MCM_ISCR_FUFC_0                        (uint32_t)0x0          // No interrupt
#define   MCM_ISCR_FUFC_1                        (uint32_t)0x1          // Interrupt occurred
#define MCM_ISCR_FIXC                            ((uint32_t)1 << 12)    // FPU Inexact Interrupt Status
#define   MCM_ISCR_FIXC_0                        (uint32_t)0x0          // No interrupt
#define   MCM_ISCR_FIXC_1                        (uint32_t)0x1          // Interrupt occurred
#define MCM_ISCR_FIDC                            ((uint32_t)1 << 15)    // FPU Input Denormal Interrupt Status
#define   MCM_ISCR_FIDC_0                        (uint32_t)0x0          // No interrupt
#define   MCM_ISCR_FIDC_1                        (uint32_t)0x1          // Interrupt occurred
#define MCM_ISCR_FIOCE                           ((uint32_t)1 << 24)    // FPU Invalid Operation Interrupt Enable
#define   MCM_ISCR_FIOCE_0                       (uint32_t)0x0          // Disable interrupt
#define   MCM_ISCR_FIOCE_1                       (uint32_t)0x1          // Enable interrupt
#define MCM_ISCR_FDZCE                           ((uint32_t)1 << 25)    // FPU Divide-by-Zero Interrupt Enable
#define   MCM_ISCR_FDZCE_0                       (uint32_t)0x0          // Disable interrupt
#define   MCM_ISCR_FDZCE_1                       (uint32_t)0x1          // Enable interrupt
#define MCM_ISCR_FOFCE                           ((uint32_t)1 << 26)    // FPU Overflow Interrupt Enable
#define   MCM_ISCR_FOFCE_0                       (uint32_t)0x0          // Disable interrupt
#define   MCM_ISCR_FOFCE_1                       (uint32_t)0x1          // Enable interrupt
#define MCM_ISCR_FUFCE                           ((uint32_t)1 << 27)    // FPU Underflow Interrupt Enable
#define   MCM_ISCR_FUFCE_0                       (uint32_t)0x0          // Disable interrupt
#define   MCM_ISCR_FUFCE_1                       (uint32_t)0x1          // Enable interrupt
#define MCM_ISCR_FIXCE                           ((uint32_t)1 << 28)    // FPU Inexact Interrupt Enable
#define   MCM_ISCR_FIXCE_0                       (uint32_t)0x0          // Disable interrupt
#define   MCM_ISCR_FIXCE_1                       (uint32_t)0x1          // Enable interrupt
#define MCM_ISCR_FIDCE                           ((uint32_t)1 << 31)    // FPU Input Denormal Interrupt Enable
#define   MCM_ISCR_FIDCE_0                       (uint32_t)0x0          // Disable interrupt
#define   MCM_ISCR_FIDCE_1                       (uint32_t)0x1          // Enable interrupt

    uint8_t _res1[28];
    uint32_t             PID;                                           // Process ID Register
                                                                        // M0_PID and M1_PID for MPU
#define MCM_PID_PID(_n)                          (((uint32_t)(_n) & 0xff) << 0)
#define MCM_PID_PID_INSERT(_v, _n)                   (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define MCM_PID_PID_EXTRACT(_v)                      (((_v) >> 0) & 0xff)

    uint8_t _res2[12];
    uint32_t             CPO;                                           // Compute Operation Control Register
#define MCM_CPO_CPOREQ                           ((uint32_t)1 << 0)     // Compute Operation Request
#define   MCM_CPO_CPOREQ_0                       (uint32_t)0x0          // Request is cleared.
#define   MCM_CPO_CPOREQ_1                       (uint32_t)0x1          // Request Compute Operation.
#define MCM_CPO_CPOACK                           ((uint32_t)1 << 1)     // Compute Operation Acknowledge
#define   MCM_CPO_CPOACK_0                       (uint32_t)0x0          // Compute operation entry has not completed or compute operation exit has completed.
#define   MCM_CPO_CPOACK_1                       (uint32_t)0x1          // Compute operation entry has completed or compute operation exit has not completed.
#define MCM_CPO_CPOWOI                           ((uint32_t)1 << 2)     // Compute Operation Wakeup On Interrupt
#define   MCM_CPO_CPOWOI_0                       (uint32_t)0x0          // No effect.
#define   MCM_CPO_CPOWOI_1                       (uint32_t)0x1          // When set, the CPOREQ is cleared on any interrupt or exception vector fetch.

    uint8_t _res3[956];
    uint32_t             LMDR0;                                         // Local Memory Descriptor Register
                                                                        // Control Field 0 LMDR0[CF0] bit field is Reserved and Read-Only 0 for S32K11x variants.
#define MCM_LMDR0_CF0(_n)                        (((uint32_t)(_n) & 0xf) << 0)
#define MCM_LMDR0_CF0_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define MCM_LMDR0_CF0_EXTRACT(_v)                    (((_v) >> 0) & 0xf)
                                                                        // Memory Type
#define MCM_LMDR0_MT(_n)                         (((uint32_t)(_n) & 0x7) << 13)
#define MCM_LMDR0_MT_INSERT(_v, _n)                  (((_v) & ~0xe000) | ((uint32_t)(_n) & 0x7) << 13)
#define MCM_LMDR0_MT_EXTRACT(_v)                     (((_v) >> 13) & 0x7)
#define   MCM_LMDR0_MT_000                       (uint32_t)0x0          // SRAM_L
#define   MCM_LMDR0_MT_001                       (uint32_t)0x1          // SRAM_U
#define MCM_LMDR0_LOCK                           ((uint32_t)1 << 16)    // LOCK
#define   MCM_LMDR0_LOCK_0                       (uint32_t)0x0          // Writes to the LMDRn[7:0] are allowed.
#define   MCM_LMDR0_LOCK_1                       (uint32_t)0x1          // Writes to the LMDRn[7:0] are ignored.
                                                                        // LMEM Data Path Width. This field defines the width of the local memory.
#define MCM_LMDR0_DPW(_n)                        (((uint32_t)(_n) & 0x7) << 17)
#define MCM_LMDR0_DPW_INSERT(_v, _n)                 (((_v) & ~0xe0000) | ((uint32_t)(_n) & 0x7) << 17)
#define MCM_LMDR0_DPW_EXTRACT(_v)                    (((_v) >> 17) & 0x7)
#define   MCM_LMDR0_DPW_010                      (uint32_t)0x2          // LMEMn 32-bits wide
#define   MCM_LMDR0_DPW_011                      (uint32_t)0x3          // LMEMn 64-bits wide
                                                                        // Level 1 Cache Ways
#define MCM_LMDR0_WY(_n)                         (((uint32_t)(_n) & 0xf) << 20)
#define MCM_LMDR0_WY_INSERT(_v, _n)                  (((_v) & ~0xf00000) | ((uint32_t)(_n) & 0xf) << 20)
#define MCM_LMDR0_WY_EXTRACT(_v)                     (((_v) >> 20) & 0xf)
#define   MCM_LMDR0_WY_0000                      (uint32_t)0x0          // No Cache
#define   MCM_LMDR0_WY_0010                      (uint32_t)0x2          // 2-Way Set Associative
#define   MCM_LMDR0_WY_0100                      (uint32_t)0x4          // 4-Way Set Associative
                                                                        // LMEM Size
#define MCM_LMDR0_LMSZ(_n)                       (((uint32_t)(_n) & 0xf) << 24)
#define MCM_LMDR0_LMSZ_INSERT(_v, _n)                (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define MCM_LMDR0_LMSZ_EXTRACT(_v)                   (((_v) >> 24) & 0xf)
#define   MCM_LMDR0_LMSZ_0000                    (uint32_t)0x0          // no LMEMn (0 KB)
#define   MCM_LMDR0_LMSZ_0001                    (uint32_t)0x1          // 1 KB LMEMn
#define   MCM_LMDR0_LMSZ_0010                    (uint32_t)0x2          // 2 KB LMEMn
#define   MCM_LMDR0_LMSZ_0011                    (uint32_t)0x3          // 4 KB LMEMn
#define   MCM_LMDR0_LMSZ_0100                    (uint32_t)0x4          // 8 KB LMEMn
#define   MCM_LMDR0_LMSZ_0101                    (uint32_t)0x5          // 16 KB LMEMn
#define   MCM_LMDR0_LMSZ_0110                    (uint32_t)0x6          // 32 KB LMEMn
#define   MCM_LMDR0_LMSZ_0111                    (uint32_t)0x7          // 64 KB LMEMn
#define   MCM_LMDR0_LMSZ_1000                    (uint32_t)0x8          // 128 KB LMEMn
#define   MCM_LMDR0_LMSZ_1001                    (uint32_t)0x9          // 256 KB LMEMn
#define   MCM_LMDR0_LMSZ_1010                    (uint32_t)0xa          // 512 KB LMEMn
#define   MCM_LMDR0_LMSZ_1011                    (uint32_t)0xb          // 1024 KB LMEMn
#define   MCM_LMDR0_LMSZ_1100                    (uint32_t)0xc          // 2048 KB LMEMn
#define   MCM_LMDR0_LMSZ_1101                    (uint32_t)0xd          // 4096 KB LMEMn
#define   MCM_LMDR0_LMSZ_1110                    (uint32_t)0xe          // 8192 KB LMEMn
#define   MCM_LMDR0_LMSZ_1111                    (uint32_t)0xf          // 16384 KB LMEMn
#define MCM_LMDR0_LMSZH                          ((uint32_t)1 << 28)    // LMEM Size Hole
#define   MCM_LMDR0_LMSZH_0                      (uint32_t)0x0          // LMEMn is a power-of-2 capacity.
#define   MCM_LMDR0_LMSZH_1                      (uint32_t)0x1          // LMEMn is not a power-of-2, with a capacity is 0.75 * LMSZ.
#define MCM_LMDR0_V                              ((uint32_t)1 << 31)    // Local Memory Valid
#define   MCM_LMDR0_V_0                          (uint32_t)0x0          // LMEMn is not present.
#define   MCM_LMDR0_V_1                          (uint32_t)0x1          // LMEMn is present.

    uint32_t             LMDR1;                                         // Local Memory Descriptor Register
                                                                        // Control Field 0 LMDR0[CF0] bit field is Reserved and Read-Only 0 for S32K11x variants.
#define MCM_LMDR1_CF0(_n)                        (((uint32_t)(_n) & 0xf) << 0)
#define MCM_LMDR1_CF0_INSERT(_v, _n)                 (((_v) & ~0xf) | ((uint32_t)(_n) & 0xf) << 0)
#define MCM_LMDR1_CF0_EXTRACT(_v)                    (((_v) >> 0) & 0xf)
                                                                        // Memory Type
#define MCM_LMDR1_MT(_n)                         (((uint32_t)(_n) & 0x7) << 13)
#define MCM_LMDR1_MT_INSERT(_v, _n)                  (((_v) & ~0xe000) | ((uint32_t)(_n) & 0x7) << 13)
#define MCM_LMDR1_MT_EXTRACT(_v)                     (((_v) >> 13) & 0x7)
#define   MCM_LMDR1_MT_000                       (uint32_t)0x0          // SRAM_L
#define   MCM_LMDR1_MT_001                       (uint32_t)0x1          // SRAM_U
#define MCM_LMDR1_LOCK                           ((uint32_t)1 << 16)    // LOCK
#define   MCM_LMDR1_LOCK_0                       (uint32_t)0x0          // Writes to the LMDRn[7:0] are allowed.
#define   MCM_LMDR1_LOCK_1                       (uint32_t)0x1          // Writes to the LMDRn[7:0] are ignored.
                                                                        // LMEM Data Path Width. This field defines the width of the local memory.
#define MCM_LMDR1_DPW(_n)                        (((uint32_t)(_n) & 0x7) << 17)
#define MCM_LMDR1_DPW_INSERT(_v, _n)                 (((_v) & ~0xe0000) | ((uint32_t)(_n) & 0x7) << 17)
#define MCM_LMDR1_DPW_EXTRACT(_v)                    (((_v) >> 17) & 0x7)
#define   MCM_LMDR1_DPW_010                      (uint32_t)0x2          // LMEMn 32-bits wide
#define   MCM_LMDR1_DPW_011                      (uint32_t)0x3          // LMEMn 64-bits wide
                                                                        // Level 1 Cache Ways
#define MCM_LMDR1_WY(_n)                         (((uint32_t)(_n) & 0xf) << 20)
#define MCM_LMDR1_WY_INSERT(_v, _n)                  (((_v) & ~0xf00000) | ((uint32_t)(_n) & 0xf) << 20)
#define MCM_LMDR1_WY_EXTRACT(_v)                     (((_v) >> 20) & 0xf)
#define   MCM_LMDR1_WY_0000                      (uint32_t)0x0          // No Cache
#define   MCM_LMDR1_WY_0010                      (uint32_t)0x2          // 2-Way Set Associative
#define   MCM_LMDR1_WY_0100                      (uint32_t)0x4          // 4-Way Set Associative
                                                                        // LMEM Size
#define MCM_LMDR1_LMSZ(_n)                       (((uint32_t)(_n) & 0xf) << 24)
#define MCM_LMDR1_LMSZ_INSERT(_v, _n)                (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define MCM_LMDR1_LMSZ_EXTRACT(_v)                   (((_v) >> 24) & 0xf)
#define   MCM_LMDR1_LMSZ_0000                    (uint32_t)0x0          // no LMEMn (0 KB)
#define   MCM_LMDR1_LMSZ_0001                    (uint32_t)0x1          // 1 KB LMEMn
#define   MCM_LMDR1_LMSZ_0010                    (uint32_t)0x2          // 2 KB LMEMn
#define   MCM_LMDR1_LMSZ_0011                    (uint32_t)0x3          // 4 KB LMEMn
#define   MCM_LMDR1_LMSZ_0100                    (uint32_t)0x4          // 8 KB LMEMn
#define   MCM_LMDR1_LMSZ_0101                    (uint32_t)0x5          // 16 KB LMEMn
#define   MCM_LMDR1_LMSZ_0110                    (uint32_t)0x6          // 32 KB LMEMn
#define   MCM_LMDR1_LMSZ_0111                    (uint32_t)0x7          // 64 KB LMEMn
#define   MCM_LMDR1_LMSZ_1000                    (uint32_t)0x8          // 128 KB LMEMn
#define   MCM_LMDR1_LMSZ_1001                    (uint32_t)0x9          // 256 KB LMEMn
#define   MCM_LMDR1_LMSZ_1010                    (uint32_t)0xa          // 512 KB LMEMn
#define   MCM_LMDR1_LMSZ_1011                    (uint32_t)0xb          // 1024 KB LMEMn
#define   MCM_LMDR1_LMSZ_1100                    (uint32_t)0xc          // 2048 KB LMEMn
#define   MCM_LMDR1_LMSZ_1101                    (uint32_t)0xd          // 4096 KB LMEMn
#define   MCM_LMDR1_LMSZ_1110                    (uint32_t)0xe          // 8192 KB LMEMn
#define   MCM_LMDR1_LMSZ_1111                    (uint32_t)0xf          // 16384 KB LMEMn
#define MCM_LMDR1_LMSZH                          ((uint32_t)1 << 28)    // LMEM Size Hole
#define   MCM_LMDR1_LMSZH_0                      (uint32_t)0x0          // LMEMn is a power-of-2 capacity.
#define   MCM_LMDR1_LMSZH_1                      (uint32_t)0x1          // LMEMn is not a power-of-2, with a capacity is 0.75 * LMSZ.
#define MCM_LMDR1_V                              ((uint32_t)1 << 31)    // Local Memory Valid
#define   MCM_LMDR1_V_0                          (uint32_t)0x0          // LMEMn is not present.
#define   MCM_LMDR1_V_1                          (uint32_t)0x1          // LMEMn is present.

    uint32_t             LMDR2;                                         // Local Memory Descriptor Register2
                                                                        // Control Field 1
#define MCM_LMDR2_CF1(_n)                        (((uint32_t)(_n) & 0xf) << 4)
#define MCM_LMDR2_CF1_INSERT(_v, _n)                 (((_v) & ~0xf0) | ((uint32_t)(_n) & 0xf) << 4)
#define MCM_LMDR2_CF1_EXTRACT(_v)                    (((_v) >> 4) & 0xf)
                                                                        // Memory Type
#define MCM_LMDR2_MT(_n)                         (((uint32_t)(_n) & 0x7) << 13)
#define MCM_LMDR2_MT_INSERT(_v, _n)                  (((_v) & ~0xe000) | ((uint32_t)(_n) & 0x7) << 13)
#define MCM_LMDR2_MT_EXTRACT(_v)                     (((_v) >> 13) & 0x7)
#define   MCM_LMDR2_MT_010                       (uint32_t)0x2          // PC Cache
#define MCM_LMDR2_LOCK                           ((uint32_t)1 << 16)    // LOCK
#define   MCM_LMDR2_LOCK_0                       (uint32_t)0x0          // Writes to the LMDRn[7:0] are allowed.
#define   MCM_LMDR2_LOCK_1                       (uint32_t)0x1          // Writes to the LMDRn[7:0] are ignored.
                                                                        // LMEM Data Path Width. This field defines the width of the local memory.
#define MCM_LMDR2_DPW(_n)                        (((uint32_t)(_n) & 0x7) << 17)
#define MCM_LMDR2_DPW_INSERT(_v, _n)                 (((_v) & ~0xe0000) | ((uint32_t)(_n) & 0x7) << 17)
#define MCM_LMDR2_DPW_EXTRACT(_v)                    (((_v) >> 17) & 0x7)
#define   MCM_LMDR2_DPW_010                      (uint32_t)0x2          // LMEMn 32-bits wide
#define   MCM_LMDR2_DPW_011                      (uint32_t)0x3          // LMEMn 64-bits wide
                                                                        // Level 1 Cache Ways
#define MCM_LMDR2_WY(_n)                         (((uint32_t)(_n) & 0xf) << 20)
#define MCM_LMDR2_WY_INSERT(_v, _n)                  (((_v) & ~0xf00000) | ((uint32_t)(_n) & 0xf) << 20)
#define MCM_LMDR2_WY_EXTRACT(_v)                     (((_v) >> 20) & 0xf)
#define   MCM_LMDR2_WY_0000                      (uint32_t)0x0          // No Cache
#define   MCM_LMDR2_WY_0010                      (uint32_t)0x2          // 2-Way Set Associative
#define   MCM_LMDR2_WY_0100                      (uint32_t)0x4          // 4-Way Set Associative
                                                                        // LMEM Size
#define MCM_LMDR2_LMSZ(_n)                       (((uint32_t)(_n) & 0xf) << 24)
#define MCM_LMDR2_LMSZ_INSERT(_v, _n)                (((_v) & ~0xf000000) | ((uint32_t)(_n) & 0xf) << 24)
#define MCM_LMDR2_LMSZ_EXTRACT(_v)                   (((_v) >> 24) & 0xf)
#define   MCM_LMDR2_LMSZ_0100                    (uint32_t)0x4          // 4 KB LMEMn
#define MCM_LMDR2_LMSZH                          ((uint32_t)1 << 28)    // LMEM Size Hole
#define   MCM_LMDR2_LMSZH_0                      (uint32_t)0x0          // LMEMn is a power-of-2 capacity.
#define   MCM_LMDR2_LMSZH_1                      (uint32_t)0x1          // LMEMn is not a power-of-2, with a capacity is 0.75 * LMSZ.
#define MCM_LMDR2_V                              ((uint32_t)1 << 31)    // Local Memory Valid
#define   MCM_LMDR2_V_0                          (uint32_t)0x0          // LMEMn is not present.
#define   MCM_LMDR2_V_1                          (uint32_t)0x1          // LMEMn is present.

    uint8_t _res4[116];
    uint32_t             LMPECR;                                        // LMEM Parity and ECC Control Register
#define MCM_LMPECR_ERNCR                         ((uint32_t)1 << 0)     // Enable RAM ECC Noncorrectable Reporting This bit field is Reserved and Read-Only 0 for S32K11x variants. This bit field cannot mask ECC reporting, as a result the ECC would always be reported.
#define   MCM_LMPECR_ERNCR_0                     (uint32_t)0x0          // Reporting disabled
#define   MCM_LMPECR_ERNCR_1                     (uint32_t)0x1          // Reporting enabled
#define MCM_LMPECR_ER1BR                         ((uint32_t)1 << 8)     // Enable RAM ECC 1 Bit Reporting This bit field is Reserved and Read-Only 0 for S32K11x variants. This bit field cannot mask ECC reporting, as a result the ECC would always be reported.
#define   MCM_LMPECR_ER1BR_0                     (uint32_t)0x0          // Reporting disabled
#define   MCM_LMPECR_ER1BR_1                     (uint32_t)0x1          // Reporting enabled
#define MCM_LMPECR_ECPR                          ((uint32_t)1 << 20)    // Enable Cache Parity Reporting
#define   MCM_LMPECR_ECPR_0                      (uint32_t)0x0          // Reporting disabled
#define   MCM_LMPECR_ECPR_1                      (uint32_t)0x1          // Reporting enabled

    uint8_t _res5[4];
    uint32_t             LMPEIR;                                        // LMEM Parity and ECC Interrupt Register
                                                                        // ENCn = ECC Noncorrectable Error n
#define MCM_LMPEIR_ENC(_n)                       (((uint32_t)(_n) & 0xff) << 0)
#define MCM_LMPEIR_ENC_INSERT(_v, _n)                (((_v) & ~0xff) | ((uint32_t)(_n) & 0xff) << 0)
#define MCM_LMPEIR_ENC_EXTRACT(_v)                   (((_v) >> 0) & 0xff)
                                                                        // E1Bn = ECC 1-bit Error n
#define MCM_LMPEIR_E1B(_n)                       (((uint32_t)(_n) & 0xff) << 8)
#define MCM_LMPEIR_E1B_INSERT(_v, _n)                (((_v) & ~0xff00) | ((uint32_t)(_n) & 0xff) << 8)
#define MCM_LMPEIR_E1B_EXTRACT(_v)                   (((_v) >> 8) & 0xff)
                                                                        // Cache Parity Error
#define MCM_LMPEIR_PE(_n)                        (((uint32_t)(_n) & 0xff) << 16)
#define MCM_LMPEIR_PE_INSERT(_v, _n)                 (((_v) & ~0xff0000) | ((uint32_t)(_n) & 0xff) << 16)
#define MCM_LMPEIR_PE_EXTRACT(_v)                    (((_v) >> 16) & 0xff)
                                                                        // Parity or ECC Error Location
#define MCM_LMPEIR_PEELOC(_n)                    (((uint32_t)(_n) & 0x1f) << 24)
#define MCM_LMPEIR_PEELOC_INSERT(_v, _n)             (((_v) & ~0x1f000000) | ((uint32_t)(_n) & 0x1f) << 24)
#define MCM_LMPEIR_PEELOC_EXTRACT(_v)                (((_v) >> 24) & 0x1f)
#define   MCM_LMPEIR_PEELOC_00                   (uint32_t)0x0          // Non-correctable ECC event from SRAM_L
#define   MCM_LMPEIR_PEELOC_01                   (uint32_t)0x1          // Non-correctable ECC event from SRAM_U
#define MCM_LMPEIR_V                             ((uint32_t)1 << 31)    // Valid Bit

    uint8_t _res6[4];
    const uint32_t       LMFAR;                                         // LMEM Fault Address Register
    const uint32_t       LMFATR;                                        // LMEM Fault Attribute Register
                                                                        // Parity/ECC Fault Protection
#define MCM_LMFATR_PEFPRT_EXTRACT(_v)                (((_v) >> 0) & 0xf)
                                                                        // Parity/ECC Fault Master Size
#define MCM_LMFATR_PEFSIZE_EXTRACT(_v)               (((_v) >> 4) & 0x7)
#define   MCM_LMFATR_PEFSIZE_000                 (uint32_t)0x0          // 8-bit access
#define   MCM_LMFATR_PEFSIZE_001                 (uint32_t)0x1          // 16-bit access
#define   MCM_LMFATR_PEFSIZE_010                 (uint32_t)0x2          // 32-bit access
#define   MCM_LMFATR_PEFSIZE_011                 (uint32_t)0x3          // 64-bit access
#define MCM_LMFATR_PEFW                          ((uint32_t)1 << 7)     // Parity/ECC Fault Write
                                                                        // Parity/ECC Fault Master Number
#define MCM_LMFATR_PEFMST_EXTRACT(_v)                (((_v) >> 8) & 0xff)
#define MCM_LMFATR_OVR                           ((uint32_t)1 << 31)    // Overrun

    uint8_t _res7[8];
    const uint32_t       LMFDHR;                                        // LMEM Fault Data High Register
    const uint32_t       LMFDLR;                                        // LMEM Fault Data Low Register
} MCM_regs_t;
                                                                        // --------------------
                                                                        // Local Memory Controller
typedef struct                                                          // --------------------
{
    uint32_t             LMEM_PCCCR;                                    // Cache control register
#define LMEM_LMEM_PCCCR_ENCACHE                  ((uint32_t)1 << 0)     // Cache enable
#define   LMEM_LMEM_PCCCR_ENCACHE_0              (uint32_t)0x0          // Cache disabled
#define   LMEM_LMEM_PCCCR_ENCACHE_1              (uint32_t)0x1          // Cache enabled
#define LMEM_LMEM_PCCCR_PCCR2                    ((uint32_t)1 << 2)     // Forces all cacheable spaces to write through
#define LMEM_LMEM_PCCCR_PCCR3                    ((uint32_t)1 << 3)     // Forces no allocation on cache misses (must also have PCCR2 asserted)
#define LMEM_LMEM_PCCCR_INVW0                    ((uint32_t)1 << 24)    // Invalidate Way 0
#define   LMEM_LMEM_PCCCR_INVW0_0                (uint32_t)0x0          // No operation
#define   LMEM_LMEM_PCCCR_INVW0_1                (uint32_t)0x1          // When setting the GO bit, invalidate all lines in way 0.
#define LMEM_LMEM_PCCCR_PUSHW0                   ((uint32_t)1 << 25)    // Push Way 0
#define   LMEM_LMEM_PCCCR_PUSHW0_0               (uint32_t)0x0          // No operation
#define   LMEM_LMEM_PCCCR_PUSHW0_1               (uint32_t)0x1          // When setting the GO bit, push all modified lines in way 0
#define LMEM_LMEM_PCCCR_INVW1                    ((uint32_t)1 << 26)    // Invalidate Way 1
#define   LMEM_LMEM_PCCCR_INVW1_0                (uint32_t)0x0          // No operation
#define   LMEM_LMEM_PCCCR_INVW1_1                (uint32_t)0x1          // When setting the GO bit, invalidate all lines in way 1
#define LMEM_LMEM_PCCCR_PUSHW1                   ((uint32_t)1 << 27)    // Push Way 1
#define   LMEM_LMEM_PCCCR_PUSHW1_0               (uint32_t)0x0          // No operation
#define   LMEM_LMEM_PCCCR_PUSHW1_1               (uint32_t)0x1          // When setting the GO bit, push all modified lines in way 1
#define LMEM_LMEM_PCCCR_GO                       ((uint32_t)1 << 31)    // Initiate Cache Command
#define   LMEM_LMEM_PCCCR_GO_0                   (uint32_t)0x0          // Write: no effect. Read: no cache command active.
#define   LMEM_LMEM_PCCCR_GO_1                   (uint32_t)0x1          // Write: initiate command indicated by bits 27-24. Read: cache command active.

    uint32_t             LMEM_PCCLCR;                                   // Cache line control register
#define LMEM_LMEM_PCCLCR_LGO                     ((uint32_t)1 << 0)     // Initiate Cache Line Command
#define   LMEM_LMEM_PCCLCR_LGO_0                 (uint32_t)0x0          // Write: no effect. Read: no line command active.
#define   LMEM_LMEM_PCCLCR_LGO_1                 (uint32_t)0x1          // Write: initiate line command indicated by bits 27-24. Read: line command active.
                                                                        // Cache address
#define LMEM_LMEM_PCCLCR_CACHEADDR(_n)           (((uint32_t)(_n) & 0xfff) << 2)
#define LMEM_LMEM_PCCLCR_CACHEADDR_INSERT(_v, _n)    (((_v) & ~0x3ffc) | ((uint32_t)(_n) & 0xfff) << 2)
#define LMEM_LMEM_PCCLCR_CACHEADDR_EXTRACT(_v)       (((_v) >> 2) & 0xfff)
#define LMEM_LMEM_PCCLCR_WSEL                    ((uint32_t)1 << 14)    // Way select
#define   LMEM_LMEM_PCCLCR_WSEL_0                (uint32_t)0x0          // Way 0
#define   LMEM_LMEM_PCCLCR_WSEL_1                (uint32_t)0x1          // Way 1
#define LMEM_LMEM_PCCLCR_TDSEL                   ((uint32_t)1 << 16)    // Tag/Data Select
#define   LMEM_LMEM_PCCLCR_TDSEL_0               (uint32_t)0x0          // Data
#define   LMEM_LMEM_PCCLCR_TDSEL_1               (uint32_t)0x1          // Tag
#define LMEM_LMEM_PCCLCR_LCIVB                   ((uint32_t)1 << 20)    // Line Command Initial Valid Bit
#define LMEM_LMEM_PCCLCR_LCIMB                   ((uint32_t)1 << 21)    // Line Command Initial Modified Bit
#define LMEM_LMEM_PCCLCR_LCWAY                   ((uint32_t)1 << 22)    // Line Command Way
                                                                        // Line Command
#define LMEM_LMEM_PCCLCR_LCMD(_n)                (((uint32_t)(_n) & 0x3) << 24)
#define LMEM_LMEM_PCCLCR_LCMD_INSERT(_v, _n)         (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define LMEM_LMEM_PCCLCR_LCMD_EXTRACT(_v)            (((_v) >> 24) & 0x3)
#define   LMEM_LMEM_PCCLCR_LCMD_00               (uint32_t)0x0          // Search and read or write
#define   LMEM_LMEM_PCCLCR_LCMD_01               (uint32_t)0x1          // Invalidate
#define   LMEM_LMEM_PCCLCR_LCMD_10               (uint32_t)0x2          // Push
#define   LMEM_LMEM_PCCLCR_LCMD_11               (uint32_t)0x3          // Clear
#define LMEM_LMEM_PCCLCR_LADSEL                  ((uint32_t)1 << 26)    // Line Address Select
#define   LMEM_LMEM_PCCLCR_LADSEL_0              (uint32_t)0x0          // Cache address
#define   LMEM_LMEM_PCCLCR_LADSEL_1              (uint32_t)0x1          // Physical address
#define LMEM_LMEM_PCCLCR_LACC                    ((uint32_t)1 << 27)    // Line access type
#define   LMEM_LMEM_PCCLCR_LACC_0                (uint32_t)0x0          // Read
#define   LMEM_LMEM_PCCLCR_LACC_1                (uint32_t)0x1          // Write

    uint32_t             LMEM_PCCSAR;                                   // Cache search address register
#define LMEM_LMEM_PCCSAR_LGO                     ((uint32_t)1 << 0)     // Initiate Cache Line Command
#define   LMEM_LMEM_PCCSAR_LGO_0                 (uint32_t)0x0          // Write: no effect. Read: no line command active.
#define   LMEM_LMEM_PCCSAR_LGO_1                 (uint32_t)0x1          // Write: initiate line command indicated by bits CLCR[27:24]. Read: line command active.
                                                                        // Physical Address
#define LMEM_LMEM_PCCSAR_PHYADDR(_n)             (((uint32_t)(_n) & 0x3fffffff) << 2)
#define LMEM_LMEM_PCCSAR_PHYADDR_INSERT(_v, _n)      (((_v) & ~0xfffffffc) | ((uint32_t)(_n) & 0x3fffffff) << 2)
#define LMEM_LMEM_PCCSAR_PHYADDR_EXTRACT(_v)         (((_v) >> 2) & 0x3fffffff)

    uint32_t             LMEM_PCCCVR;                                   // Cache read/write value register
    uint8_t _res0[16];
    uint32_t             PCCRMR;                                        // Cache regions mode register
                                                                        // Region 15 mode
#define LMEM_PCCRMR_R15(_n)                      (((uint32_t)(_n) & 0x3) << 0)
#define LMEM_PCCRMR_R15_INSERT(_v, _n)               (((_v) & ~0x3) | ((uint32_t)(_n) & 0x3) << 0)
#define LMEM_PCCRMR_R15_EXTRACT(_v)                  (((_v) >> 0) & 0x3)
#define   LMEM_PCCRMR_R15_00                     (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R15_01                     (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R15_10                     (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R15_11                     (uint32_t)0x3          // Write-back
                                                                        // Region 14 mode
#define LMEM_PCCRMR_R14(_n)                      (((uint32_t)(_n) & 0x3) << 2)
#define LMEM_PCCRMR_R14_INSERT(_v, _n)               (((_v) & ~0xc) | ((uint32_t)(_n) & 0x3) << 2)
#define LMEM_PCCRMR_R14_EXTRACT(_v)                  (((_v) >> 2) & 0x3)
#define   LMEM_PCCRMR_R14_00                     (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R14_01                     (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R14_10                     (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R14_11                     (uint32_t)0x3          // Write-back
                                                                        // Region 13 mode
#define LMEM_PCCRMR_R13(_n)                      (((uint32_t)(_n) & 0x3) << 4)
#define LMEM_PCCRMR_R13_INSERT(_v, _n)               (((_v) & ~0x30) | ((uint32_t)(_n) & 0x3) << 4)
#define LMEM_PCCRMR_R13_EXTRACT(_v)                  (((_v) >> 4) & 0x3)
#define   LMEM_PCCRMR_R13_00                     (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R13_01                     (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R13_10                     (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R13_11                     (uint32_t)0x3          // Write-back
                                                                        // Region 12 mode
#define LMEM_PCCRMR_R12(_n)                      (((uint32_t)(_n) & 0x3) << 6)
#define LMEM_PCCRMR_R12_INSERT(_v, _n)               (((_v) & ~0xc0) | ((uint32_t)(_n) & 0x3) << 6)
#define LMEM_PCCRMR_R12_EXTRACT(_v)                  (((_v) >> 6) & 0x3)
#define   LMEM_PCCRMR_R12_00                     (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R12_01                     (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R12_10                     (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R12_11                     (uint32_t)0x3          // Write-back
                                                                        // Region 11 mode
#define LMEM_PCCRMR_R11(_n)                      (((uint32_t)(_n) & 0x3) << 8)
#define LMEM_PCCRMR_R11_INSERT(_v, _n)               (((_v) & ~0x300) | ((uint32_t)(_n) & 0x3) << 8)
#define LMEM_PCCRMR_R11_EXTRACT(_v)                  (((_v) >> 8) & 0x3)
#define   LMEM_PCCRMR_R11_00                     (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R11_01                     (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R11_10                     (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R11_11                     (uint32_t)0x3          // Write-back
                                                                        // Region 10 mode
#define LMEM_PCCRMR_R10(_n)                      (((uint32_t)(_n) & 0x3) << 10)
#define LMEM_PCCRMR_R10_INSERT(_v, _n)               (((_v) & ~0xc00) | ((uint32_t)(_n) & 0x3) << 10)
#define LMEM_PCCRMR_R10_EXTRACT(_v)                  (((_v) >> 10) & 0x3)
#define   LMEM_PCCRMR_R10_00                     (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R10_01                     (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R10_10                     (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R10_11                     (uint32_t)0x3          // Write-back
                                                                        // Region 9 mode
#define LMEM_PCCRMR_R9(_n)                       (((uint32_t)(_n) & 0x3) << 12)
#define LMEM_PCCRMR_R9_INSERT(_v, _n)                (((_v) & ~0x3000) | ((uint32_t)(_n) & 0x3) << 12)
#define LMEM_PCCRMR_R9_EXTRACT(_v)                   (((_v) >> 12) & 0x3)
#define   LMEM_PCCRMR_R9_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R9_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R9_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R9_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 8 mode
#define LMEM_PCCRMR_R8(_n)                       (((uint32_t)(_n) & 0x3) << 14)
#define LMEM_PCCRMR_R8_INSERT(_v, _n)                (((_v) & ~0xc000) | ((uint32_t)(_n) & 0x3) << 14)
#define LMEM_PCCRMR_R8_EXTRACT(_v)                   (((_v) >> 14) & 0x3)
#define   LMEM_PCCRMR_R8_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R8_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R8_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R8_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 7 mode
#define LMEM_PCCRMR_R7(_n)                       (((uint32_t)(_n) & 0x3) << 16)
#define LMEM_PCCRMR_R7_INSERT(_v, _n)                (((_v) & ~0x30000) | ((uint32_t)(_n) & 0x3) << 16)
#define LMEM_PCCRMR_R7_EXTRACT(_v)                   (((_v) >> 16) & 0x3)
#define   LMEM_PCCRMR_R7_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R7_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R7_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R7_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 6 mode
#define LMEM_PCCRMR_R6(_n)                       (((uint32_t)(_n) & 0x3) << 18)
#define LMEM_PCCRMR_R6_INSERT(_v, _n)                (((_v) & ~0xc0000) | ((uint32_t)(_n) & 0x3) << 18)
#define LMEM_PCCRMR_R6_EXTRACT(_v)                   (((_v) >> 18) & 0x3)
#define   LMEM_PCCRMR_R6_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R6_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R6_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R6_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 5 mode
#define LMEM_PCCRMR_R5(_n)                       (((uint32_t)(_n) & 0x3) << 20)
#define LMEM_PCCRMR_R5_INSERT(_v, _n)                (((_v) & ~0x300000) | ((uint32_t)(_n) & 0x3) << 20)
#define LMEM_PCCRMR_R5_EXTRACT(_v)                   (((_v) >> 20) & 0x3)
#define   LMEM_PCCRMR_R5_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R5_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R5_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R5_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 4 mode
#define LMEM_PCCRMR_R4(_n)                       (((uint32_t)(_n) & 0x3) << 22)
#define LMEM_PCCRMR_R4_INSERT(_v, _n)                (((_v) & ~0xc00000) | ((uint32_t)(_n) & 0x3) << 22)
#define LMEM_PCCRMR_R4_EXTRACT(_v)                   (((_v) >> 22) & 0x3)
#define   LMEM_PCCRMR_R4_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R4_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R4_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R4_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 3 mode
#define LMEM_PCCRMR_R3(_n)                       (((uint32_t)(_n) & 0x3) << 24)
#define LMEM_PCCRMR_R3_INSERT(_v, _n)                (((_v) & ~0x3000000) | ((uint32_t)(_n) & 0x3) << 24)
#define LMEM_PCCRMR_R3_EXTRACT(_v)                   (((_v) >> 24) & 0x3)
#define   LMEM_PCCRMR_R3_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R3_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R3_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R3_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 2 mode
#define LMEM_PCCRMR_R2(_n)                       (((uint32_t)(_n) & 0x3) << 26)
#define LMEM_PCCRMR_R2_INSERT(_v, _n)                (((_v) & ~0xc000000) | ((uint32_t)(_n) & 0x3) << 26)
#define LMEM_PCCRMR_R2_EXTRACT(_v)                   (((_v) >> 26) & 0x3)
#define   LMEM_PCCRMR_R2_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R2_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R2_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R2_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 1 mode
#define LMEM_PCCRMR_R1(_n)                       (((uint32_t)(_n) & 0x3) << 28)
#define LMEM_PCCRMR_R1_INSERT(_v, _n)                (((_v) & ~0x30000000) | ((uint32_t)(_n) & 0x3) << 28)
#define LMEM_PCCRMR_R1_EXTRACT(_v)                   (((_v) >> 28) & 0x3)
#define   LMEM_PCCRMR_R1_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R1_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R1_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R1_11                      (uint32_t)0x3          // Write-back
                                                                        // Region 0 mode
#define LMEM_PCCRMR_R0(_n)                       (((uint32_t)(_n) & 0x3) << 30)
#define LMEM_PCCRMR_R0_INSERT(_v, _n)                (((_v) & ~0xc0000000) | ((uint32_t)(_n) & 0x3) << 30)
#define LMEM_PCCRMR_R0_EXTRACT(_v)                   (((_v) >> 30) & 0x3)
#define   LMEM_PCCRMR_R0_00                      (uint32_t)0x0          // Non-cacheable
#define   LMEM_PCCRMR_R0_01                      (uint32_t)0x1          // Non-cacheable
#define   LMEM_PCCRMR_R0_10                      (uint32_t)0x2          // Write-through
#define   LMEM_PCCRMR_R0_11                      (uint32_t)0x3          // Write-back

} LMEM_regs_t;

#define CSE_PRAM         ((volatile CSE_PRAM_regs_t *)0x14001000U)
#define AIPS             ((volatile AIPS_regs_t *)0x40000000U)
#define MSCM             ((volatile MSCM_regs_t *)0x40001000U)
#define DMA              ((volatile DMA_regs_t *)0x40008000U)
#define MPU              ((volatile MPU_regs_t *)0x4000d000U)
#define ERM              ((volatile ERM_regs_t *)0x40018000U)
#define EIM              ((volatile EIM_regs_t *)0x40019000U)
#define FTFC             ((volatile FTFC_regs_t *)0x40020000U)
#define DMAMUX           ((volatile DMAMUX_regs_t *)0x40021000U)
#define CAN0             ((volatile CAN_regs_t *)0x40024000U)
#define CAN1             ((volatile CAN_regs_t *)0x40025000U)
#define CAN2             ((volatile CAN_regs_t *)0x4002b000U)
#define FTM0             ((volatile FTM_regs_t *)0x40038000U)
#define FTM1             ((volatile FTM_regs_t *)0x40039000U)
#define FTM2             ((volatile FTM_regs_t *)0x4003a000U)
#define FTM3             ((volatile FTM_regs_t *)0x40026000U)
#define ADC0             ((volatile ADC_regs_t *)0x4003b000U)
#define ADC1             ((volatile ADC_regs_t *)0x40027000U)
#define LPSPI0           ((volatile LPSPI_regs_t *)0x4002c000U)
#define LPSPI1           ((volatile LPSPI_regs_t *)0x4002d000U)
#define LPSPI2           ((volatile LPSPI_regs_t *)0x4002e000U)
#define PDB0             ((volatile PDB_regs_t *)0x40036000U)
#define PDB1             ((volatile PDB_regs_t *)0x40031000U)
#define CRC              ((volatile CRC_regs_t *)0x40032000U)
#define LPIT0            ((volatile LPIT0_regs_t *)0x40037000U)
#define RTC              ((volatile RTC_regs_t *)0x4003d000U)
#define LPTMR0           ((volatile LPTMR0_regs_t *)0x40040000U)
#define SIM              ((volatile SIM_regs_t *)0x40048000U)
#define PORTA            ((volatile PORT_regs_t *)0x40049000U)
#define PORTB            ((volatile PORT_regs_t *)0x4004a000U)
#define PORTC            ((volatile PORT_regs_t *)0x4004b000U)
#define PORTD            ((volatile PORT_regs_t *)0x4004c000U)
#define PORTE            ((volatile PORT_regs_t *)0x4004d000U)
#define WDOG             ((volatile WDOG_regs_t *)0x40052000U)
#define FLEXIO           ((volatile FLEXIO_regs_t *)0x4005a000U)
#define EWM              ((volatile EWM_regs_t *)0x40061000U)
#define TRGMUX           ((volatile TRGMUX_regs_t *)0x40063000U)
#define SCG              ((volatile SCG_regs_t *)0x40064000U)
#define PCC              ((volatile PCC_regs_t *)0x40065000U)
#define LPI2C0           ((volatile LPI2C0_regs_t *)0x40066000U)
#define LPUART0          ((volatile LPUART_regs_t *)0x4006a000U)
#define LPUART1          ((volatile LPUART_regs_t *)0x4006b000U)
#define LPUART2          ((volatile LPUART_regs_t *)0x4006c000U)
#define CMP0             ((volatile CMP0_regs_t *)0x40073000U)
#define PMC              ((volatile PMC_regs_t *)0x4007d000U)
#define SMC              ((volatile SMC_regs_t *)0x4007e000U)
#define RCM              ((volatile RCM_regs_t *)0x4007f000U)
#define PTA              ((volatile PT_regs_t *)0x400ff000U)
#define PTB              ((volatile PT_regs_t *)0x400ff040U)
#define PTC              ((volatile PT_regs_t *)0x400ff080U)
#define PTD              ((volatile PT_regs_t *)0x400ff0c0U)
#define PTE              ((volatile PT_regs_t *)0x400ff100U)
#define S32_SCB          ((volatile S32_SCB_regs_t *)0xe000e000U)
#define S32_SysTick      ((volatile S32_SysTick_regs_t *)0xe000e010U)
#define S32_NVIC         ((volatile S32_NVIC_regs_t *)0xe000e100U)
#define MCM              ((volatile MCM_regs_t *)0xe0080000U)
#define LMEM             ((volatile LMEM_regs_t *)0xe0082000U)

